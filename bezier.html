<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quadratic Bezier Curve in WebGPU</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; position: relative; }
        canvas { border: 1px solid #fff; cursor: crosshair; width: 800px; height: 600px; }
        #fps { position: absolute; top: 10px; left: 10px; color: #fff; font-family: monospace; font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px 10px; }
    </style>
</head>
<body>
    <div id="fps">FPS: 0</div>
    <canvas id="canvas"></canvas>
    <script type="module">
        const canvas = document.getElementById('canvas');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = 800 * dpr;
        canvas.height = 600 * dpr;

        async function init() {
            // Load shader from external file
            const response = await fetch('bezier.wgsl');
            const wgsl = await response.text();
            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                alert('No GPU adapter found.');
                return;
            }
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format, alphaMode: 'premultiplied' });

            const shaderModule = device.createShaderModule({ code: wgsl });
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main'
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: { topology: 'triangle-list' }
            });

            const uniformBuffer = device.createBuffer({
                size: 40,  // 2 floats (resolution) + 4 * 2 floats (4 control points)
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const bindGroup = device.createBindGroup({
                layout: pipeline.getBindGroupLayout(0),
                entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
            });

            const width = canvas.width;
            const height = canvas.height;
            const aspect = width / height;
            const scale = Math.max(aspect, 1.0);

            // Initial points in normalized UV space - cubic Bezier with 4 control points
            let points = {
                p0: [-1.0, -0.3],
                p1: [-0.3, 0.7],
                p2: [0.3, 0.7],
                p3: [1.0, -0.3]
            };

            let draggingPoint = null;

            function screenToUV(offsetX, offsetY) {
                let fragCoordX = offsetX * dpr;
                let fragCoordY = height - (offsetY * dpr);
                let uvX = (fragCoordX * 2.0 - width) / height;
                let uvY = (fragCoordY * 2.0 - height) / height;
                uvX *= aspect;
                uvX /= scale;
                uvY /= scale;
                return { x: uvX, y: uvY };
            }

            function uvToScreen(uvX, uvY) {
                let tempX = uvX * scale / aspect;
                let tempY = uvY * scale;
                let fragCoordX = (tempX * height + width) / 2.0;
                let fragCoordY = (tempY * height + height) / 2.0;
                let screenX = fragCoordX / dpr;
                let screenY = (height - fragCoordY) / dpr;
                return { screenX, screenY };
            }

            function updateUniforms() {
                const data = new Float32Array([
                    width, height,
                    ...points.p0, ...points.p1, ...points.p2, ...points.p3
                ]);
                device.queue.writeBuffer(uniformBuffer, 0, data);
            }

            function render() {
                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }, // White background
                        loadOp: 'clear',
                        storeOp: 'store'
                    }]
                });
                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(3);
                renderPass.end();
                device.queue.submit([commandEncoder.finish()]);
            }

            function findNearestPoint(offsetX, offsetY) {
                const candidates = [
                    { key: 'p0', ...uvToScreen(points.p0[0], points.p0[1]) },
                    { key: 'p1', ...uvToScreen(points.p1[0], points.p1[1]) },
                    { key: 'p2', ...uvToScreen(points.p2[0], points.p2[1]) },
                    { key: 'p3', ...uvToScreen(points.p3[0], points.p3[1]) }
                ];
                let nearest = candidates.reduce((min, cand) => {
                    const dist = Math.hypot(offsetX - cand.screenX, offsetY - cand.screenY);
                    return dist < min.dist ? { ...cand, dist } : min;
                }, { dist: Infinity });
                console.log('Click offset:', offsetX, offsetY, 'Nearest:', nearest.key, 'dist px:', nearest.dist);
                return nearest.dist < 40 ? nearest.key : null;
            }

            canvas.addEventListener('mousedown', (e) => {
                draggingPoint = findNearestPoint(e.offsetX, e.offsetY);
                console.log('Dragging point:', draggingPoint);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (draggingPoint) {
                    const uv = screenToUV(e.offsetX, e.offsetY);
                    points[draggingPoint] = [uv.x, uv.y];
                    updateUniforms();
                    render();
                }
            });

            canvas.addEventListener('mouseup', () => {
                draggingPoint = null;
            });

            // FPS counter
            const fpsElement = document.getElementById('fps');
            let frameCount = 0;
            let lastTime = performance.now();

            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - lastTime;

                if (elapsed >= 1000) {
                    const fps = Math.round((frameCount * 1000) / elapsed);
                    fpsElement.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastTime = currentTime;
                }

                requestAnimationFrame(updateFPS);
            }

            // Initial render
            updateUniforms();
            render();
            updateFPS();
        }

        init().catch(console.error);
    </script>
</body>
</html>
