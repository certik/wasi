<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quadratic Bezier Curve in WebGPU</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; position: relative; }
        canvas { border: 1px solid #fff; cursor: crosshair; width: 800px; height: 600px; }
        #fps { position: absolute; top: 10px; left: 10px; color: #fff; font-family: monospace; font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px 10px; }
    </style>
</head>
<body>
    <div id="fps">FPS: 0</div>
    <canvas id="canvas"></canvas>
    <script type="module">
        const canvas = document.getElementById('canvas');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = 800 * dpr;
        canvas.height = 600 * dpr;
        const wgsl = `
            struct Uniforms {
                resolution: vec2<f32>,
                p0: vec2<f32>,
                p1: vec2<f32>,
                p2: vec2<f32>,
                p3: vec2<f32>,
            }

            @group(0) @binding(0)
            var<uniform> uniforms: Uniforms;

            fn sdSegment(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>) -> f32 {
                let pa = p - a;
                let ba = b - a;
                let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                return length(pa - ba * h);
            }

            fn sdPoint(p: vec2<f32>, pt: vec2<f32>) -> f32 {
                return length(p - pt);
            }

            const eps: f32 = 0.0001;

            // Return true if x is not a NaN nor an infinite
            fn isfinite(x: f32) -> bool {
                return (bitcast<u32>(x) & 0x7f800000u) != 0x7f800000u;
            }

            fn poly5(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, t: f32) -> f32 {
                return ((((a * t + b) * t + c) * t + d) * t + e) * t + f;
            }

            // Newton bisection for 5th degree polynomial
            fn bisect5(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, t_in: vec2<f32>, v: vec2<f32>) -> f32 {
                var t = t_in;
                var x = (t.x + t.y) * 0.5;
                let s = select(-1.0, 1.0, v.x < v.y);

                for (var i = 0; i < 32; i++) {
                    // Evaluate polynomial and derivative using Horner's method
                    var y = a * x + b;
                    var q = a * x + y;
                    y = y * x + c;
                    q = q * x + y;
                    y = y * x + d;
                    q = q * x + y;
                    y = y * x + e;
                    q = q * x + y;
                    y = y * x + f;

                    t = select(vec2(t.x, x), vec2(x, t.y), s * y < 0.0);
                    var next = x - y / q;
                    next = select((t.x + t.y) * 0.5, next, next >= t.x && next <= t.y);
                    if (abs(next - x) < eps) {
                        return next;
                    }
                    x = next;
                }
                return x;
            }

            // Quadratic root finder: solve axÂ²+bx+c=0 (clamped to [0,1])
            fn root_find2(a: f32, b: f32, c: f32) -> array<f32, 6> {
                var result: array<f32, 6>;
                result[5] = 0.0; // count

                let disc = b * b - 4.0 * a * c;
                if (disc < 0.0) {
                    return result;
                }
                if (disc == 0.0) {
                    let s = -0.5 * b / a;
                    if (isfinite(s)) {
                        result[0] = s;
                        result[5] = 1.0;
                    }
                    return result;
                }

                let h = sqrt(disc);
                let q = -0.5 * (b + select(-h, h, b > 0.0));
                var v = vec2(q / a, c / q);
                if (v.x > v.y) {
                    v = v.yx;
                }

                var count = 0;
                if (isfinite(v.x) && v.x >= 0.0 && v.x <= 1.0) {
                    result[count] = v.x;
                    count++;
                }
                if (isfinite(v.y) && v.y >= 0.0 && v.y <= 1.0) {
                    result[count] = v.y;
                    count++;
                }
                result[5] = f32(count);
                return result;
            }

            // Find roots using bisection on quintic
            fn cy_find5(r4: array<f32, 6>, a: f32, b: f32, c: f32, d: f32, e: f32, f: f32) -> array<f32, 6> {
                var result: array<f32, 6>;
                var count = 0;
                let n = i32(r4[5]);

                var px = 0.0;
                var py = poly5(a, b, c, d, e, f, 0.0);

                for (var i = 0; i <= n; i++) {
                    let x = select(r4[i], 1.0, i == n);
                    let y = poly5(a, b, c, d, e, f, x);

                    if (py * y <= 0.0 && !(py * y == 0.0)) {
                        let v = bisect5(a, b, c, d, e, f, vec2(px, x), vec2(py, y));
                        result[count] = v;
                        count++;
                    }
                    px = x;
                    py = y;
                }

                result[5] = f32(count);
                return result;
            }

            // Hierarchical root finder for 5th degree polynomial
            fn root_find5(da: f32, db: f32, dc: f32, dd: f32, de: f32, df: f32) -> array<f32, 6> {
                // Degree 2
                let r2 = root_find2(10.0 * da, 4.0 * db, dc);

                // Degree 3
                let r3 = cy_find5(r2, 0.0, 0.0, 10.0 * da, 6.0 * db, 3.0 * dc, dd);

                // Degree 4
                let r4 = cy_find5(r3, 0.0, 5.0 * da, 4.0 * db, 3.0 * dc, dd + dd, de);

                // Degree 5
                let r = cy_find5(r4, da, db, dc, dd, de, df);

                return r;
            }

            fn dot2(v: vec2<f32>) -> f32 {
                return dot(v, v);
            }

            // Cubic Bezier distance function
            fn bezier(p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> f32 {
                // Start by testing distance to boundary points
                let dp0 = p0 - p;
                let dp3 = p3 - p;
                var dist = min(dot2(dp0), dot2(dp3));

                // Bezier cubic points to polynomial coefficients
                let a = -p0 + 3.0 * (p1 - p2) + p3;
                let b = 3.0 * (p0 - 2.0 * p1 + p2);
                let c = 3.0 * (p1 - p0);
                let d = p0;

                // Solve D'(t)=0 where D(t) is distance squared
                let dmp = d - p;
                let da = 3.0 * dot(a, a);
                let db = 5.0 * dot(a, b);
                let dc = 4.0 * dot(a, c) + 2.0 * dot(b, b);
                let dd = 3.0 * (dot(a, dmp) + dot(b, c));
                let de = 2.0 * dot(b, dmp) + dot(c, c);
                let df = dot(c, dmp);

                let roots = root_find5(da, db, dc, dd, de, df);
                let count = i32(roots[5]);

                for (var i = 0; i < count; i++) {
                    let t = roots[i];
                    let dp = ((a * t + b) * t + c) * t + dmp;
                    dist = min(dist, dot2(dp));
                }

                return sqrt(dist);
            }

            // Distance field debug visualization (Inigo Quilez colorscheme)
            fn df_debug(d: f32) -> vec3<f32> {
                var col = vec3<f32>(0.0, 0.2, 0.5);
                col *= 0.7 + 0.3 * cos(120.0 * abs(d));
                return mix(col, vec3<f32>(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));
            }

            fn sat(x: f32) -> f32 {
                return clamp(x, 0.0, 1.0);
            }

            // Render control points and tangent segments
            fn points_segments(c_in: vec3<f32>, p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> vec3<f32> {
                var c = c_in;

                // Points
                let d0 = dot2(p - p0);
                let d1 = dot2(p - p1);
                let d2 = dot2(p - p2);
                let d3 = dot2(p - p3);
                let d = 0.02 - sqrt(min(min(min(d0, d1), d2), d3));
                c = mix(c, vec3<f32>(1.0, 0.5, 0.0), sat(0.5 + d / fwidth(d)));

                // Segments
                let s0 = sdSegment(p, p0, p1);
                let s1 = sdSegment(p, p2, p3);
                let s = 0.005 - min(s0, s1);
                c = mix(c, vec3<f32>(1.0, 0.5, 0.0), sat(0.5 + s / fwidth(s)) * 0.5);

                return c;
            }

            @vertex
            fn vs_main(@builtin(vertex_index) in_vertex_index: u32) -> @builtin(position) vec4<f32> {
                let positions = array<vec2<f32>, 3>(
                    vec2<f32>(-1.0, -1.0),
                    vec2<f32>( 3.0, -1.0),
                    vec2<f32>(-1.0,  3.0)
                );
                return vec4<f32>(positions[in_vertex_index], 0.0, 1.0);
            }

            @fragment
            fn fs_main(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
                let fragCoord = vec2<f32>(pos.x, uniforms.resolution.y - pos.y);
                var uv = (fragCoord * 2.0 - uniforms.resolution) / uniforms.resolution.y;
                let aspect = uniforms.resolution.x / uniforms.resolution.y;
                uv.x *= aspect;
                let scale = max(aspect, 1.0);
                uv /= scale;

                // Calculate distance to cubic Bezier curve
                let d = bezier(uv, uniforms.p0, uniforms.p1, uniforms.p2, uniforms.p3);

                // Apply distance field visualization
                var o = df_debug(d);

                // Overlay control points and tangent segments
                o = points_segments(o, uv, uniforms.p0, uniforms.p1, uniforms.p2, uniforms.p3);

                // Apply gamma correction
                return vec4<f32>(pow(o, vec3<f32>(1.0 / 2.2)), 1.0);
            }
        `;

        async function init() {
            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                alert('No GPU adapter found.');
                return;
            }
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format, alphaMode: 'premultiplied' });

            const shaderModule = device.createShaderModule({ code: wgsl });
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main'
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: { topology: 'triangle-list' }
            });

            const uniformBuffer = device.createBuffer({
                size: 40,  // 2 floats (resolution) + 4 * 2 floats (4 control points)
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const bindGroup = device.createBindGroup({
                layout: pipeline.getBindGroupLayout(0),
                entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
            });

            const width = canvas.width;
            const height = canvas.height;
            const aspect = width / height;
            const scale = Math.max(aspect, 1.0);

            // Initial points in normalized UV space - cubic Bezier with 4 control points
            let points = {
                p0: [-1.0, -0.3],
                p1: [-0.3, 0.7],
                p2: [0.3, 0.7],
                p3: [1.0, -0.3]
            };

            let draggingPoint = null;

            function screenToUV(offsetX, offsetY) {
                let fragCoordX = offsetX * dpr;
                let fragCoordY = height - (offsetY * dpr);
                let uvX = (fragCoordX * 2.0 - width) / height;
                let uvY = (fragCoordY * 2.0 - height) / height;
                uvX *= aspect;
                uvX /= scale;
                uvY /= scale;
                return { x: uvX, y: uvY };
            }

            function uvToScreen(uvX, uvY) {
                let tempX = uvX * scale / aspect;
                let tempY = uvY * scale;
                let fragCoordX = (tempX * height + width) / 2.0;
                let fragCoordY = (tempY * height + height) / 2.0;
                let screenX = fragCoordX / dpr;
                let screenY = (height - fragCoordY) / dpr;
                return { screenX, screenY };
            }

            function updateUniforms() {
                const data = new Float32Array([
                    width, height,
                    ...points.p0, ...points.p1, ...points.p2, ...points.p3
                ]);
                device.queue.writeBuffer(uniformBuffer, 0, data);
            }

            function render() {
                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }, // White background
                        loadOp: 'clear',
                        storeOp: 'store'
                    }]
                });
                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.draw(3);
                renderPass.end();
                device.queue.submit([commandEncoder.finish()]);
            }

            function findNearestPoint(offsetX, offsetY) {
                const candidates = [
                    { key: 'p0', ...uvToScreen(points.p0[0], points.p0[1]) },
                    { key: 'p1', ...uvToScreen(points.p1[0], points.p1[1]) },
                    { key: 'p2', ...uvToScreen(points.p2[0], points.p2[1]) },
                    { key: 'p3', ...uvToScreen(points.p3[0], points.p3[1]) }
                ];
                let nearest = candidates.reduce((min, cand) => {
                    const dist = Math.hypot(offsetX - cand.screenX, offsetY - cand.screenY);
                    return dist < min.dist ? { ...cand, dist } : min;
                }, { dist: Infinity });
                console.log('Click offset:', offsetX, offsetY, 'Nearest:', nearest.key, 'dist px:', nearest.dist);
                return nearest.dist < 40 ? nearest.key : null;
            }

            canvas.addEventListener('mousedown', (e) => {
                draggingPoint = findNearestPoint(e.offsetX, e.offsetY);
                console.log('Dragging point:', draggingPoint);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (draggingPoint) {
                    const uv = screenToUV(e.offsetX, e.offsetY);
                    points[draggingPoint] = [uv.x, uv.y];
                    updateUniforms();
                    render();
                }
            });

            canvas.addEventListener('mouseup', () => {
                draggingPoint = null;
            });

            // FPS counter
            const fpsElement = document.getElementById('fps');
            let frameCount = 0;
            let lastTime = performance.now();

            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - lastTime;

                if (elapsed >= 1000) {
                    const fps = Math.round((frameCount * 1000) / elapsed);
                    fpsElement.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastTime = currentTime;
                }

                requestAnimationFrame(updateFPS);
            }

            // Initial render
            updateUniforms();
            render();
            updateFPS();
        }

        init().catch(console.error);
    </script>
</body>
</html>
