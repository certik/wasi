<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        const textureFormatStringToEnum = {
            'rgba8unorm': 0x00000016,
            'rgba8unorm-srgb': 0x00000017,
            'bgra8unorm': 0x0000001B,
            'bgra8unorm-srgb': 0x0000001C,
            'stencil8': 0x0000002C,
            'depth16unorm': 0x0000002D,
            'depth24plus': 0x0000002E,
            'depth24plus-stencil8': 0x0000002F,
            'depth32float': 0x00000030,
            'depth32float-stencil8': 0x00000031,
        };

        const textureFormatEnumToString = {};
        for (const [name, value] of Object.entries(textureFormatStringToEnum)) {
            textureFormatEnumToString[value] = name;
        }

        function enumFromTextureFormat(name) {
            const value = textureFormatStringToEnum[name];
            if (value === undefined) {
                console.warn(`[WebGPU] Unknown texture format: ${name}`);
                return textureFormatStringToEnum['bgra8unorm'];
            }
            return value;
        }

        function textureFormatFromEnum(value) {
            const format = textureFormatEnumToString[value];
            if (!format) {
                console.warn(`[WebGPU] Unknown texture format enum: 0x${value.toString(16)}`);
                return 'bgra8unorm';
            }
            return format;
        }

        const GMBufferSlot = Object.freeze({
            POSITIONS: 0,
            UVS: 1,
            SURFACE_TYPES: 2,
            TRIANGLE_IDS: 3,
            NORMALS: 4,
            INDICES: 5,
            UNIFORM: 6,
            OVERLAY_UNIFORM: 7,
            OVERLAY_TEXT: 8,
            OVERLAY_MAP: 9,
            OVERLAY_VERTEX: 10,
        });

        function createWasmWebGPUHost(adapter, device) {
            let memory = null;
            let nextHandle = 1;
            const decoder = new TextDecoder('utf-8');

            const buffers = new Map();
            const shaderModules = new Map();
            const devices = new Map();
            const queues = new Map();
            const bindGroupLayouts = new Map();
            const pipelineLayouts = new Map();
            const renderPipelines = new Map();
            const bindGroups = new Map();
            const samplers = new Map();
            const textureViews = new Map();

            const GMResource = {
                BUFFER: 0,
                SAMPLER: 1,
                TEXTURE_VIEW: 2,
                STORAGE_TEXTURE: 3,
            };

            const bufferBindingTypeMap = new Map([
                [0x00000002, 'uniform'],
                [0x00000003, 'storage'],
                [0x00000004, 'read-only-storage'],
            ]);

            const samplerTypeMap = new Map([
                [0x00000002, 'filtering'],
                [0x00000003, 'non-filtering'],
                [0x00000004, 'comparison'],
            ]);

            const textureSampleTypeMap = new Map([
                [0x00000002, 'float'],
                [0x00000003, 'unfilterable-float'],
                [0x00000004, 'depth'],
                [0x00000005, 'sint'],
                [0x00000006, 'uint'],
            ]);

            const textureViewDimensionMap = new Map([
                [0x00000001, '1d'],
                [0x00000002, '2d'],
                [0x00000003, '2d-array'],
                [0x00000004, 'cube'],
                [0x00000005, 'cube-array'],
                [0x00000006, '3d'],
            ]);

            const vertexFormatMap = new Map([
                [0x0000001C, 'float32'],
                [0x0000001D, 'float32x2'],
                [0x0000001E, 'float32x3'],
                [0x0000001F, 'float32x4'],
            ]);

            const vertexStepModeMap = new Map([
                [0x00000001, 'vertex'],
                [0x00000002, 'instance'],
            ]);

            const primitiveTopologyMap = new Map([
                [0x00000004, 'triangle-list'],
                [0x00000005, 'triangle-strip'],
                [0x00000001, 'point-list'],
                [0x00000002, 'line-list'],
                [0x00000003, 'line-strip'],
            ]);

            const cullModeMap = new Map([
                [0x00000001, 'none'],
                [0x00000002, 'front'],
                [0x00000003, 'back'],
            ]);

            const frontFaceMap = new Map([
                [0x00000001, 'ccw'],
                [0x00000002, 'cw'],
            ]);

            const compareFunctionMap = new Map([
                [0x00000002, 'less'],
                [0x00000008, 'always'],
                [0x00000004, 'less-equal'],
                [0x00000005, 'greater'],
            ]);

            const filterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const mipmapFilterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const addressModeMap = new Map([
                [0x00000001, 'clamp-to-edge'],
                [0x00000002, 'repeat'],
                [0x00000003, 'mirror-repeat'],
            ]);

            const blendFactorMap = new Map([
                [0x00000001, 'zero'],
                [0x00000002, 'one'],
                [0x00000005, 'src-alpha'],
                [0x00000006, 'one-minus-src-alpha'],
                [0x00000009, 'dst-alpha'],
                [0x0000000A, 'one-minus-dst-alpha'],
            ]);

            const blendOperationMap = new Map([
                [0x00000001, 'add'],
                [0x00000002, 'subtract'],
                [0x00000003, 'reverse-subtract'],
                [0x00000004, 'min'],
                [0x00000005, 'max'],
            ]);

            const deviceHandle = nextHandle++;
            devices.set(deviceHandle, device);
            const queueHandle = nextHandle++;
            queues.set(queueHandle, device.queue);

            function requireMemory() {
                if (!memory) {
                    throw new Error('WebGPU memory not registered');
                }
            }

            function readString(ptr, length) {
                if (!ptr || length === 0) {
                    return '';
                }
                const bytes = new Uint8Array(memory.buffer, ptr, length);
                return decoder.decode(bytes);
            }

            function mapOrDefault(map, key, fallback) {
                return map.get(key) ?? fallback;
            }

            function readBindGroupLayoutEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 56;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const visibility = dv.getUint32(base + 4, true);
                    const resourceType = dv.getUint32(base + 8, true);
                    const bufferType = dv.getUint32(base + 12, true);
                    const hasDynamicOffset = !!dv.getUint32(base + 16, true);
                    const minBindingSize = Number(dv.getBigUint64(base + 20, true));
                    const samplerType = dv.getUint32(base + 28, true);
                    const textureSampleType = dv.getUint32(base + 32, true);
                    const textureViewDim = dv.getUint32(base + 36, true);
                    const textureMultisampled = !!dv.getUint32(base + 40, true);
                    const storageAccess = dv.getUint32(base + 44, true);
                    const storageFormat = dv.getUint32(base + 48, true);
                    const storageViewDim = dv.getUint32(base + 52, true);

                    const entry = { binding, visibility };
                    if (resourceType === GMResource.BUFFER) {
                        entry.buffer = {
                            type: mapOrDefault(bufferBindingTypeMap, bufferType, 'uniform'),
                            hasDynamicOffset,
                            minBindingSize,
                        };
                    } else if (resourceType === GMResource.SAMPLER) {
                        entry.sampler = {
                            type: mapOrDefault(samplerTypeMap, samplerType, 'filtering'),
                        };
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        entry.texture = {
                            sampleType: mapOrDefault(textureSampleTypeMap, textureSampleType, 'float'),
                            viewDimension: mapOrDefault(textureViewDimensionMap, textureViewDim, '2d'),
                            multisampled: textureMultisampled,
                        };
                    } else if (resourceType === GMResource.STORAGE_TEXTURE) {
                        entry.storageTexture = {
                            access: storageAccess === 0x00000003 ? 'read-only' : 'write-only',
                            format: textureFormatFromEnum(storageFormat),
                            viewDimension: mapOrDefault(textureViewDimensionMap, storageViewDim, '2d'),
                        };
                    }
                    entries.push(entry);
                }
                return entries;
            }

            function readBindGroupEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 28;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const resourceType = dv.getUint32(base + 4, true);
                    const handle = dv.getUint32(base + 8, true);
                    const offset = Number(dv.getBigUint64(base + 12, true));
                    const rawSize = dv.getBigUint64(base + 20, true);
                    const size = rawSize === 0xFFFFFFFFFFFFFFFFn ? undefined : Number(rawSize);

                    if (resourceType === GMResource.BUFFER) {
                        const buffer = buffers.get(handle);
                        if (!buffer) {
                            throw new Error(`Unknown buffer handle ${handle}`);
                        }
                        const resource = { buffer, offset };
                        if (size !== undefined) {
                            resource.size = size;
                        }
                        entries.push({
                            binding,
                            resource,
                        });
                    } else if (resourceType === GMResource.SAMPLER) {
                        const sampler = samplers.get(handle);
                        if (!sampler) {
                            throw new Error(`Unknown sampler handle ${handle}`);
                        }
                        entries.push({ binding, resource: sampler });
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        const view = textureViews.get(handle);
                        if (!view) {
                            throw new Error(`Unknown texture view handle ${handle}`);
                        }
                        entries.push({ binding, resource: view });
                    } else {
                        throw new Error(`Unsupported bind group resource type ${resourceType}`);
                    }
                }
                return entries;
            }

            function readProgrammableStage(ptr) {
                if (!ptr) {
                    return null;
                }
                const dv = new DataView(memory.buffer);
                const moduleHandle = dv.getUint32(ptr, true);
                const entryPtr = dv.getUint32(ptr + 4, true);
                const entryLength = dv.getUint32(ptr + 8, true);
                const module = shaderModules.get(moduleHandle);
                if (!module) {
                    throw new Error(`Unknown shader module handle ${moduleHandle}`);
                }
                const entryPoint = readString(entryPtr, entryLength) || 'main';
                return { module, entryPoint };
            }

            function readVertexBuffers(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const buffersOut = [];
                const dv = new DataView(memory.buffer);
                const stride = 16;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const arrayStride = dv.getUint32(base, true);
                    const stepModeValue = dv.getUint32(base + 4, true);
                    const attributeCount = dv.getUint32(base + 8, true);
                    const attributesPtr = dv.getUint32(base + 12, true);
                    const attributes = [];
                    const attrStride = 12;
                    for (let j = 0; j < attributeCount; j++) {
                        const attrBase = attributesPtr + j * attrStride;
                        const shaderLocation = dv.getUint32(attrBase, true);
                        const offset = dv.getUint32(attrBase + 4, true);
                        const formatValue = dv.getUint32(attrBase + 8, true);
                        attributes.push({
                            shaderLocation,
                            offset,
                            format: mapOrDefault(vertexFormatMap, formatValue, 'float32'),
                        });
                    }
                    buffersOut.push({
                        arrayStride,
                        stepMode: mapOrDefault(vertexStepModeMap, stepModeValue, 'vertex'),
                        attributes,
                    });
                }
                return buffersOut;
            }

            function readVertexState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const bufferCount = dv.getUint32(ptr + 4, true);
                const buffersPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    buffers: readVertexBuffers(buffersPtr, bufferCount),
                };
            }

            function readColorTargets(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const targets = [];
                const dv = new DataView(memory.buffer);
                const stride = 36;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const format = textureFormatFromEnum(dv.getUint32(base, true));
                    const blendEnabled = !!dv.getUint32(base + 4, true);
                    const colorSrc = dv.getUint32(base + 8, true);
                    const colorDst = dv.getUint32(base + 12, true);
                    const colorOp = dv.getUint32(base + 16, true);
                    const alphaSrc = dv.getUint32(base + 20, true);
                    const alphaDst = dv.getUint32(base + 24, true);
                    const alphaOp = dv.getUint32(base + 28, true);
                    const writeMask = dv.getUint32(base + 32, true);
                    const target = { format, writeMask };
                    if (blendEnabled) {
                        target.blend = {
                            color: {
                                srcFactor: mapOrDefault(blendFactorMap, colorSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, colorDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, colorOp, 'add'),
                            },
                            alpha: {
                                srcFactor: mapOrDefault(blendFactorMap, alphaSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, alphaDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, alphaOp, 'add'),
                            },
                        };
                    }
                    targets.push(target);
                }
                return targets;
            }

            function readFragmentState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const targetCount = dv.getUint32(ptr + 4, true);
                const targetsPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    targets: readColorTargets(targetsPtr, targetCount),
                };
            }

            function readPrimitiveState(ptr) {
                const dv = new DataView(memory.buffer);
                const topology = mapOrDefault(primitiveTopologyMap, dv.getUint32(ptr, true), 'triangle-list');
                const cullMode = mapOrDefault(cullModeMap, dv.getUint32(ptr + 4, true), 'none');
                const frontFace = mapOrDefault(frontFaceMap, dv.getUint32(ptr + 8, true), 'ccw');
                const stripIndexFormat = dv.getUint32(ptr + 12, true);
                const primitive = { topology, cullMode, frontFace };
                if (stripIndexFormat === 0x00000001) {
                    primitive.stripIndexFormat = 'uint16';
                } else if (stripIndexFormat === 0x00000002) {
                    primitive.stripIndexFormat = 'uint32';
                }
                return primitive;
            }

            function readDepthStencilState(ptr) {
                const dv = new DataView(memory.buffer);
                const format = textureFormatFromEnum(dv.getUint32(ptr, true));
                const depthWriteEnabled = !!dv.getUint32(ptr + 4, true);
                const depthCompare = mapOrDefault(compareFunctionMap, dv.getUint32(ptr + 8, true), 'less');
                return { format, depthWriteEnabled, depthCompare };
            }

            const imports = {
                create_instance() {
                    return 1;
                },
                surface_get_preferred_format() {
                    const preferred = navigator.gpu.getPreferredCanvasFormat();
                    const value = enumFromTextureFormat(preferred);
                    console.log('[WebGPU] Preferred canvas format (JS):', preferred, '-> enum', value);
                    return value;
                },
                device_create_buffer(deviceHandleParam, sizeLow, sizeHigh, usage, mapped) {
                    const targetDevice = devices.get(deviceHandleParam);
                    const size = sizeLow + sizeHigh * 4294967296;
                    const buffer = targetDevice.createBuffer({
                        size,
                        usage,
                        mappedAtCreation: !!mapped,
                    });
                    const handle = nextHandle++;
                    buffers.set(handle, buffer);
                    return handle;
                },
                queue_write_buffer(queueHandleParam, bufferHandle, offsetLow, offsetHigh, dataPtr, size) {
                    requireMemory();
                    const queue = queues.get(queueHandleParam);
                    const buffer = buffers.get(bufferHandle);
                    const offset = offsetLow + offsetHigh * 4294967296;
                    const source = new Uint8Array(memory.buffer, dataPtr, size);
                    queue.writeBuffer(buffer, offset, source);
                },
                device_create_shader_module(deviceHandleParam, codePtr, codeLength) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const bytes = new Uint8Array(memory.buffer, codePtr, codeLength);
                    const code = decoder.decode(bytes);
                    const module = targetDevice.createShaderModule({ code });
                    const handle = nextHandle++;
                    shaderModules.set(handle, module);
                    return handle;
                },
                device_create_bind_group_layout(deviceHandleParam, entriesPtr, entryCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const entries = readBindGroupLayoutEntries(entriesPtr, entryCount);
                    const layout = targetDevice.createBindGroupLayout({ entries });
                    const handle = nextHandle++;
                    bindGroupLayouts.set(handle, layout);
                    return handle;
                },
                device_create_pipeline_layout(deviceHandleParam, layoutsPtr, layoutCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const handles = new Uint32Array(memory.buffer, layoutsPtr, layoutCount);
                    const layouts = [];
                    for (let i = 0; i < handles.length; i++) {
                        const layout = bindGroupLayouts.get(handles[i]);
                        if (!layout) {
                            throw new Error(`Unknown bind group layout handle ${handles[i]}`);
                        }
                        layouts.push(layout);
                    }
                    const pipelineLayout = targetDevice.createPipelineLayout({ bindGroupLayouts: layouts });
                    const handle = nextHandle++;
                    pipelineLayouts.set(handle, pipelineLayout);
                    return handle;
                },
                device_create_sampler(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const base = descriptorPtr;
                    const desc = {
                        magFilter: mapOrDefault(filterModeMap, dv.getUint32(base, true), 'nearest'),
                        minFilter: mapOrDefault(filterModeMap, dv.getUint32(base + 4, true), 'nearest'),
                        mipmapFilter: mapOrDefault(mipmapFilterModeMap, dv.getUint32(base + 8, true), 'nearest'),
                        addressModeU: mapOrDefault(addressModeMap, dv.getUint32(base + 12, true), 'clamp-to-edge'),
                        addressModeV: mapOrDefault(addressModeMap, dv.getUint32(base + 16, true), 'clamp-to-edge'),
                        addressModeW: mapOrDefault(addressModeMap, dv.getUint32(base + 20, true), 'clamp-to-edge'),
                        lodMinClamp: dv.getFloat32(base + 24, true),
                        lodMaxClamp: dv.getFloat32(base + 28, true),
                    };
                    const compareValue = dv.getUint32(base + 32, true);
                    if (compareValue !== 0) {
                        desc.compare = mapOrDefault(compareFunctionMap, compareValue, 'less');
                    }
                    const sampler = targetDevice.createSampler(desc);
                    const handle = nextHandle++;
                    samplers.set(handle, sampler);
                    return handle;
                },
                device_create_bind_group(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const entryCount = dv.getUint32(descriptorPtr + 4, true);
                    const entriesPtr = dv.getUint32(descriptorPtr + 8, true);
                    const layout = bindGroupLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown bind group layout handle ${layoutHandle}`);
                    }
                    const entries = readBindGroupEntries(entriesPtr, entryCount);
                    const bindGroup = targetDevice.createBindGroup({ layout, entries });
                    const handle = nextHandle++;
                    bindGroups.set(handle, bindGroup);
                    return handle;
                },
                device_create_render_pipeline(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const vertexStatePtr = dv.getUint32(descriptorPtr + 4, true);
                    const fragmentStatePtr = dv.getUint32(descriptorPtr + 8, true);
                    const primitiveStatePtr = dv.getUint32(descriptorPtr + 12, true);
                    const depthStatePtr = dv.getUint32(descriptorPtr + 16, true);
                    const sampleCount = dv.getUint32(descriptorPtr + 20, true);
                    const alphaToCoverage = !!dv.getUint32(descriptorPtr + 24, true);

                    const layout = pipelineLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown pipeline layout handle ${layoutHandle}`);
                    }

                    const descriptor = {
                        layout,
                        vertex: readVertexState(vertexStatePtr),
                        primitive: readPrimitiveState(primitiveStatePtr),
                        multisample: {
                            count: sampleCount || 1,
                            mask: 0xFFFFFFFF,
                            alphaToCoverageEnabled: alphaToCoverage,
                        },
                    };

                    if (fragmentStatePtr !== 0) {
                        descriptor.fragment = readFragmentState(fragmentStatePtr);
                    }
                    if (depthStatePtr !== 0) {
                        descriptor.depthStencil = readDepthStencilState(depthStatePtr);
                    }

                    const pipeline = targetDevice.createRenderPipeline(descriptor);
                    const handle = nextHandle++;
                    renderPipelines.set(handle, pipeline);
                    return handle;
                },
            };

            return {
                imports,
                setMemory(mem) {
                    memory = mem;
                },
                handles: {
                    device: deviceHandle,
                    queue: queueHandle,
                },
                getBuffer(handle) {
                    return buffers.get(handle);
                },
                getShaderModule(handle) {
                    return shaderModules.get(handle);
                },
                getBindGroup(handle) {
                    return bindGroups.get(handle);
                },
                getRenderPipeline(handle) {
                    return renderPipelines.get(handle);
                },
                registerTextureView(view) {
                    const handle = nextHandle++;
                    textureViews.set(handle, view);
                    return handle;
                },
            };
        }

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Add error handling
            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const context = canvas.getContext('webgpu');

            function createSolidTexture(device, rgba, label) {
                const texture = device.createTexture({
                    label,
                    size: [1, 1, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                });
                const data = new Uint8Array(rgba);
                device.queue.writeTexture({ texture }, data, { bytesPerRow: 4 }, [1, 1, 1]);
                return texture.createView();
            }

            async function createTextureFromUrl(device, url, label) {
                console.log(`[Texture] Starting to load ${label} from ${url}`);
                try {
                    const response = await fetch(url, { mode: 'cors' });
                    console.log(`[Texture] Fetched ${label}, status: ${response.status}`);
                    const blob = await response.blob();
                    console.log(`[Texture] Blob size for ${label}: ${blob.size} bytes`);
                    const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    console.log(`[Texture] ImageBitmap created for ${label}: ${imageBitmap.width}x${imageBitmap.height}`);
                    const texture = device.createTexture({
                        label,
                        size: [imageBitmap.width, imageBitmap.height, 1],
                        format: 'rgba8unorm',
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                    console.log(`[Texture] Texture created for ${label}`);
                    device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture },
                        [imageBitmap.width, imageBitmap.height]
                    );
                    console.log(`[Texture] Data copied to texture for ${label}`);
                    const view = texture.createView();
                    console.log(`[Texture] Successfully loaded ${label}`);
                    return view;
                } catch (err) {
                    console.warn(`[Texture] ERROR loading ${label}:`, err);
                    console.warn(`Falling back to solid texture for ${label}`);
                    return createSolidTexture(device, [255, 255, 255, 255], `${label}-fallback`);
                }
            }

            // Map definition (1 = wall, 2 = wall with north/south window, 3 = wall with east/west window, 0 = floor, 5-8 = starting position with direction)
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,7,0,0,0,0,0,0,0,1],
                [1,0,1,2,1,0,2,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,0,3,0,1,0,0,1],
                [1,0,3,0,1,1,0,0,1,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction using WASM
            let startX = 1.5, startZ = 1.5, startYaw = 0;

            // Load and use WASM module for finding start position
            const wasmResponse = await fetch('gm.wasm');
            const wasmBytes = await wasmResponse.arrayBuffer();

            const webgpuHost = createWasmWebGPUHost(adapter, device);

            // Platform API implementation
            const platformAPI = {
                get_canvas_size: (widthPtr, heightPtr) => {
                    const view = new Int32Array(memory.buffer);
                    view[widthPtr / 4] = canvas.width;
                    view[heightPtr / 4] = canvas.height;
                },
                get_time: () => performance.now(),
                request_animation_frame: () => {
                    requestAnimationFrame(() => {
                        wasmInstance.exports.gm_on_animation_frame();
                    });
                },
                render_frame: (uniformDataPtr, overlayUniformDataPtr, overlayTextDataPtr, overlayTextLength,
                              jsTimeOutPtr, gpuCopyTimeOutPtr, gpuRenderTimeOutPtr) => {
                    const frameStartTime = performance.now();

                    // Get data from WASM memory
                    const uniformData = new Float32Array(memory.buffer, uniformDataPtr, uniformFloatCount);
                    const overlayUniformData = new Float32Array(memory.buffer, overlayUniformDataPtr, overlayUniformFloatCount);
                    const overlayTextData = new Uint32Array(memory.buffer, overlayTextDataPtr, overlayTextLength);

                    // Upload uniform buffers
                    device.queue.writeBuffer(uniformBuffer, 0, uniformData);
                    device.queue.writeBuffer(overlayUniformBuffer, 0, overlayUniformData);
                    device.queue.writeBuffer(overlayTextBuffer, 0, overlayTextData);

                    const jsEndTime = performance.now();
                    const jsTime = jsEndTime - frameStartTime;

                    const gpuCopyEndTime = performance.now();
                    const gpuCopyTime = gpuCopyEndTime - jsEndTime;

                    // Encode GPU commands
                    const commandEncoder = device.createCommandEncoder();
                    const textureView = context.getCurrentTexture().createView();

                    const renderPass = commandEncoder.beginRenderPass({
                        colorAttachments: [{
                            view: textureView,
                            clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store',
                        }],
                        depthStencilAttachment: {
                            view: depthTexture.createView(),
                            depthClearValue: 1.0,
                            depthLoadOp: 'clear',
                            depthStoreOp: 'store'
                        }
                    });

                    // Main geometry pass
                    renderPass.setPipeline(pipeline);
                    renderPass.setBindGroup(0, bindGroup);
                    renderPass.setVertexBuffer(0, positionBuffer);
                    renderPass.setVertexBuffer(1, uvBuffer);
                    renderPass.setVertexBuffer(2, surfaceTypeBuffer);
                    renderPass.setVertexBuffer(3, triangleIDBuffer);
                    renderPass.setVertexBuffer(4, normalBuffer);
                    renderPass.setIndexBuffer(indexBuffer, 'uint16');
                    renderPass.drawIndexed(indices.length);

                    // Overlay pass
                    renderPass.setPipeline(overlayPipeline);
                    renderPass.setBindGroup(0, overlayBindGroup);
                    renderPass.setVertexBuffer(0, overlayVertexBuffer);
                    renderPass.draw(4);
                    renderPass.end();

                    device.queue.submit([commandEncoder.finish()]);

                    const gpuRenderEndTime = performance.now();
                    const gpuRenderTime = gpuRenderEndTime - gpuCopyEndTime;
                    const totalFrameTime = gpuRenderEndTime - frameStartTime;

                    // Write timing data back to WASM
                    const floatView = new Float64Array(memory.buffer);
                    floatView[jsTimeOutPtr / 8] = jsTime;
                    floatView[gpuCopyTimeOutPtr / 8] = gpuCopyTime;
                    floatView[gpuRenderTimeOutPtr / 8] = gpuRenderTime;

                    return totalFrameTime;
                },
            };

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                env: {
                    cosf: (x) => Math.cos(x),
                    sinf: (x) => Math.sin(x),
                },
                platform: platformAPI,
                wasi_snapshot_preview1: {
                // Not needed right now:
                /*
                    fd_write: () => 0,
                    proc_exit: () => {},
                    path_open: () => 0,
                    fd_close: () => 0,
                    fd_read: () => 0,
                    fd_seek: () => 0,
                    fd_tell: () => 0,
                    args_sizes_get: () => 0,
                    args_get: () => 0,
                */
                },
                webgpu: webgpuHost.imports,
            });

            const wasmInstance = wasmModule.instance;
            const memory = wasmInstance.exports.memory;
            webgpuHost.setMemory(memory);
            const find_start_position = wasmInstance.exports.find_start_position;
            const generate_mesh = wasmInstance.exports.generate_mesh;
            const gm_get_preferred_canvas_format = wasmInstance.exports.gm_get_preferred_canvas_format;
            const gm_register_webgpu_handles = wasmInstance.exports.gm_register_webgpu_handles;
            const gm_create_gpu_buffers = wasmInstance.exports.gm_create_gpu_buffers;
            const gm_get_gpu_buffer_count = wasmInstance.exports.gm_get_gpu_buffer_count;
            const gm_get_gpu_buffer_table = wasmInstance.exports.gm_get_gpu_buffer_table;
            const gm_create_shader_modules = wasmInstance.exports.gm_create_shader_modules;
            const gm_get_shader_module_count = wasmInstance.exports.gm_get_shader_module_count;
            const gm_get_shader_module_table = wasmInstance.exports.gm_get_shader_module_table;
            const gm_get_uniform_float_count = wasmInstance.exports.gm_get_uniform_float_count;
            const gm_register_texture_views = wasmInstance.exports.gm_register_texture_views;
            const gm_create_bind_group_layouts = wasmInstance.exports.gm_create_bind_group_layouts;
            const gm_create_pipeline_layouts = wasmInstance.exports.gm_create_pipeline_layouts;
            const gm_create_render_pipelines = wasmInstance.exports.gm_create_render_pipelines;
            const gm_create_bind_groups = wasmInstance.exports.gm_create_bind_groups;
            const gm_get_bind_group_table = wasmInstance.exports.gm_get_bind_group_table;
            const gm_get_bind_group_count = wasmInstance.exports.gm_get_bind_group_count;
            const gm_get_render_pipeline_table = wasmInstance.exports.gm_get_render_pipeline_table;
            const gm_get_render_pipeline_count = wasmInstance.exports.gm_get_render_pipeline_count;
            gm_register_webgpu_handles(webgpuHost.handles.device, webgpuHost.handles.queue);

            const preferredFormatEnum = gm_get_preferred_canvas_format();
            const format = textureFormatFromEnum(preferredFormatEnum);
            console.log(`[WebGPU] Preferred canvas format (via WASM): ${format} (enum 0x${preferredFormatEnum.toString(16)})`);
            context.configure({
                device,
                format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST
            });
            console.log('[WebGPU] Canvas configured');

            // Flatten the 2D map into 1D array
            const flatMap = new Int32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    flatMap[z * mapWidth + x] = map[z][x];
                }
            }

            // Allocate memory in WASM for map, startX, startZ, startYaw
            // Note: offset 1024 contains .rodata (PI constants), globals start around 1036
            // Globals take ~52KB (g_positions, g_uvs, etc.), so use offset 60000 to be safe
            const mapPtr = 60000;
            const startXPtr = mapPtr + flatMap.length * 4 + 4;
            const startZPtr = startXPtr + 4;
            const startYawPtr = startZPtr + 4;

            // Copy map to WASM memory
            new Int32Array(memory.buffer).set(flatMap, mapPtr / 4);

            // Call WASM function
            const found = find_start_position(mapPtr, mapWidth, mapHeight, startXPtr, startZPtr, startYawPtr);

            if (found) {
                // Read results from WASM memory (get fresh buffer reference after call)
                const floatView = new Float32Array(memory.buffer);
                startX = floatView[startXPtr / 4];
                startZ = floatView[startZPtr / 4];
                startYaw = floatView[startYawPtr / 4];

                // Update JavaScript map with cleared marker (get fresh buffer reference)
                const wasmMemory = new Int32Array(memory.buffer);
                for (let z = 0; z < mapHeight; z++) {
                    for (let x = 0; x < mapWidth; x++) {
                        map[z][x] = wasmMemory[mapPtr / 4 + z * mapWidth + x];
                    }
                }

                const dirName = startYaw < -1.0 ? 'North' : startYaw < 1.0 ? 'East' : startYaw < 2.0 ? 'South' : 'West';
                console.log(`Starting at (${startX}, ${startZ}) facing ${dirName} with yaw=${startYaw}`);
            } else {
                throw new Error('Starting position not found in map!');
            }

            const wallHeight = 2.0;
            const checkerSize = 4.0; // For 4x4 checker per unit

            // Generate meshes using WASM

            // Call WASM generate_mesh function
            const meshDataPtr = generate_mesh(mapPtr, mapWidth, mapHeight);

            // Read MeshData structure from WASM memory (get fresh buffer reference after call)
            const meshDataView = new Uint32Array(memory.buffer, meshDataPtr, 11); // 11 uint32 fields
            const positionsPtr = meshDataView[0];
            const uvsPtr = meshDataView[1];
            const normalsPtr = meshDataView[2];
            const surfaceTypesPtr = meshDataView[3];
            const triangleIDsPtr = meshDataView[4];
            const indicesPtr = meshDataView[5];
            const positionCount = meshDataView[6];
            const uvCount = meshDataView[7];
            const normalCount = meshDataView[8];
            const vertexCount = meshDataView[9];
            const indexCount = meshDataView[10];

            console.log(`Mesh: ${vertexCount} vertices, ${indexCount} indices, ${indexCount/3} triangles`);

            // Extract arrays from WASM memory
            const positions = new Float32Array(memory.buffer, positionsPtr, positionCount);
            const uvs = new Float32Array(memory.buffer, uvsPtr, uvCount);
            const normals = new Float32Array(memory.buffer, normalsPtr, normalCount);
            const surfaceTypes = new Float32Array(memory.buffer, surfaceTypesPtr, vertexCount);
            const triangleIDs = new Float32Array(memory.buffer, triangleIDsPtr, vertexCount);
            const indices = new Uint16Array(memory.buffer, indicesPtr, indexCount);

            // Create map data array for collision detection (still needed by JavaScript)
            const mapDataArray = new Uint32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    mapDataArray[z * mapWidth + x] = map[z][x];
                }
            }

            const bufferInitResult = gm_create_gpu_buffers();
            if (bufferInitResult !== 0) {
                throw new Error(`gm_create_gpu_buffers failed with code ${bufferInitResult}`);
            }

            const bufferHandleCount = gm_get_gpu_buffer_count();
            const bufferTablePtr = gm_get_gpu_buffer_table();
            const bufferHandleView = new Uint32Array(memory.buffer, bufferTablePtr, bufferHandleCount);
            const positionBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.POSITIONS]);
            const uvBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.UVS]);
            const surfaceTypeBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.SURFACE_TYPES]);
            const triangleIDBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.TRIANGLE_IDS]);
            const normalBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.NORMALS]);
            const indexBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.INDICES]);
            const uniformBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.UNIFORM]);
            const overlayUniformBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_UNIFORM]);
            const overlayTextBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_TEXT]);
            const overlayMapBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_MAP]);
            const overlayVertexBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_VERTEX]);
            const uniformFloatCount = gm_get_uniform_float_count();

            const shaderInitResult = gm_create_shader_modules();
            if (shaderInitResult !== 0) {
                throw new Error(`gm_create_shader_modules failed with code ${shaderInitResult}`);
            }

            const shaderHandleCount = gm_get_shader_module_count();
            const shaderTablePtr = gm_get_shader_module_table();
            const shaderHandleView = new Uint32Array(memory.buffer, shaderTablePtr, shaderHandleCount);
            const vsModule = webgpuHost.getShaderModule(shaderHandleView[0]);
            const fsModule = webgpuHost.getShaderModule(shaderHandleView[1]);
            const overlayVsModule = webgpuHost.getShaderModule(shaderHandleView[2]);
            const overlayFsModule = webgpuHost.getShaderModule(shaderHandleView[3]);

            // Check for shader compilation errors
            vsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Vertex shader compilation messages:', info.messages);
                }
            });
            fsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Fragment shader compilation messages:', info.messages);
                }
            });

            console.log('Shaders compiled successfully');

            console.log('[Texture] Starting to load all textures...');
            const [wallTextureView, floorTextureView, ceilingTextureView] = await Promise.all([
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/brick_diffuse.jpg', 'wall-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg', 'floor-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/lava/cloud.png', 'ceiling-texture')
            ]);
            console.log('[Texture] All textures loaded successfully');
            console.log('[Texture] Wall texture view:', wallTextureView);
            console.log('[Texture] Floor texture view:', floorTextureView);
            console.log('[Texture] Ceiling texture view:', ceilingTextureView);
            const wallHandle = webgpuHost.registerTextureView(wallTextureView);
            const floorHandle = webgpuHost.registerTextureView(floorTextureView);
            const ceilingHandle = webgpuHost.registerTextureView(ceilingTextureView);
            gm_register_texture_views(wallHandle, floorHandle, ceilingHandle);

            let pipelineInit = gm_create_bind_group_layouts();
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_bind_group_layouts failed with code ${pipelineInit}`);
            }
            pipelineInit = gm_create_pipeline_layouts();
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_pipeline_layouts failed with code ${pipelineInit}`);
            }
            pipelineInit = gm_create_render_pipelines(preferredFormatEnum);
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_render_pipelines failed with code ${pipelineInit}`);
            }
            pipelineInit = gm_create_bind_groups();
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_bind_groups failed with code ${pipelineInit}`);
            }

            const bindGroupHandleCount = gm_get_bind_group_count();
            const bindGroupTablePtr = gm_get_bind_group_table();
            const bindGroupHandleView = new Uint32Array(memory.buffer, bindGroupTablePtr, bindGroupHandleCount);
            const bindGroup = webgpuHost.getBindGroup(bindGroupHandleView[0]);
            const overlayBindGroup = webgpuHost.getBindGroup(bindGroupHandleView[1]);

            const pipelineHandleCount = gm_get_render_pipeline_count();
            const pipelineTablePtr = gm_get_render_pipeline_table();
            const pipelineHandleView = new Uint32Array(memory.buffer, pipelineTablePtr, pipelineHandleCount);
            const pipeline = webgpuHost.getRenderPipeline(pipelineHandleView[0]);
            const overlayPipeline = webgpuHost.getRenderPipeline(pipelineHandleView[1]);

            console.log('Pipelines and bind groups created successfully via WASM');

            const overlayUniformFloatCount = 24;
            const overlayTextCapacity = 256;
            device.queue.writeBuffer(overlayMapBuffer, 0, mapDataArray);

            // Depth texture
            let depthTexture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            console.log(`Mesh generated: ${positions.length/3} vertices, ${indices.length/3} triangles`);

            // Initialize game state in WASM
            // Allocate after the map and temp variables
            const gameStateSize = 512;
            const gameStatePtr = startYawPtr + 4 + 64; // After startYaw with padding
            const gm_init_game_state = wasmInstance.exports.gm_init_game_state;
            const gm_set_key_state = wasmInstance.exports.gm_set_key_state;
            const gm_add_mouse_delta = wasmInstance.exports.gm_add_mouse_delta;
            const gm_update_frame = wasmInstance.exports.gm_update_frame;
            const gm_get_uniform_data = wasmInstance.exports.gm_get_uniform_data;
            const gm_build_overlay_text = wasmInstance.exports.gm_build_overlay_text;
            const gm_get_overlay_uniform_data = wasmInstance.exports.gm_get_overlay_uniform_data;
            const gm_update_perf_metrics = wasmInstance.exports.gm_update_perf_metrics;

            gm_init_game_state(gameStatePtr, mapPtr, mapWidth, mapHeight, startX, startZ, startYaw);
            console.log('Game state initialized at', gameStatePtr);

            // Debug: read back camera position
            const debugView = new Float32Array(memory.buffer, gameStatePtr, 12);
            console.log(`[Debug] Initial camera: (${debugView[0]}, ${debugView[1]}, ${debugView[2]}), yaw=${debugView[3]}, pitch=${debugView[4]}`);

            // Helper to get GameState field offsets (calculated from struct definition)
            // float camera_x,y,z (0,4,8), yaw,pitch (12,16), target_yaw,pitch (20,24)
            // float person_height...collision_radius (28-52) = 7 floats
            // Then int flags starting at offset 56
            const GameStateOffsets = {
                map_visible: 56,           // offset to map_visible field
                map_relative_mode: 60,     // offset to map_relative_mode field
                hud_visible: 64,           // offset to hud_visible field
                textures_enabled: 68,      // offset to textures_enabled field
                triangle_mode: 72,         // offset to triangle_mode field
                debug_mode: 76,            // offset to debug_mode field
                horizontal_movement: 80,   // offset to horizontal_movement field
            };

            let lastLoggedTextureState = false;

            // Helper to toggle game state flags
            function toggleGameStateFlag(offset) {
                const view = new Int32Array(memory.buffer, gameStatePtr + offset, 1);
                view[0] = view[0] ? 0 : 1;
                return view[0];
            }

            // Map arrow keys to special characters for C code
            const keyMap = {
                'arrowleft': '<'.charCodeAt(0),
                'arrowright': '>'.charCodeAt(0),
                'arrowup': '^'.charCodeAt(0),
                'arrowdown': 'v'.charCodeAt(0),
            };

            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (!e.repeat) {
                    if (key === 'm') {
                        const val = toggleGameStateFlag(GameStateOffsets.map_visible);
                        console.log('[Map] Map visible:', val ? 'ON' : 'OFF');
                    } else if (key === 'r') {
                        const val = toggleGameStateFlag(GameStateOffsets.map_relative_mode);
                        console.log('[Map] Relative mode:', val ? 'ON' : 'OFF');
                    } else if (key === 't') {
                        const val = toggleGameStateFlag(GameStateOffsets.textures_enabled);
                        console.log('[Texture] Textures toggled:', val ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'v') {
                        const val = toggleGameStateFlag(GameStateOffsets.triangle_mode);
                        console.log('[Visualization] Triangle mode:', val ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'b') {
                        const val = toggleGameStateFlag(GameStateOffsets.debug_mode);
                        console.log('[Debug] Debug mode:', val ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'h') {
                        toggleGameStateFlag(GameStateOffsets.hud_visible);
                    } else if (key === 'f') {
                        const val = toggleGameStateFlag(GameStateOffsets.horizontal_movement);
                        console.log('[Movement] Mode:', val ? 'Person' : 'Flying');
                    }
                }
                // Send key code to WASM
                const keyCode = keyMap[key] || key.charCodeAt(0);
                if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                    console.log(`[Input] Key ${key} pressed, code=${keyCode}`);
                }
                gm_set_key_state(gameStatePtr, keyCode, 1);
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                const keyCode = keyMap[key] || key.charCodeAt(0);
                gm_set_key_state(gameStatePtr, keyCode, 0);
            });

            canvas.addEventListener('click', () => canvas.requestPointerLock());

            function onMouseMove(e) {
                gm_add_mouse_delta(gameStatePtr, e.movementX, e.movementY);
            }

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            // Start render loop - C will drive the loop via platform API
            const gm_set_active_game_state = wasmInstance.exports.gm_set_active_game_state;
            const gm_on_animation_frame = wasmInstance.exports.gm_on_animation_frame;

            gm_set_active_game_state(gameStatePtr);
            gm_on_animation_frame();  // Start the render loop

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Recreate depth texture
                depthTexture.destroy();
                depthTexture = device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
            });
        }

        init();
    </script>
</body>
</html>
