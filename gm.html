<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        const textureFormatStringToEnum = {
            'rgba8unorm': 0x00000016,
            'rgba8unorm-srgb': 0x00000017,
            'bgra8unorm': 0x0000001B,
            'bgra8unorm-srgb': 0x0000001C,
            'stencil8': 0x0000002C,
            'depth16unorm': 0x0000002D,
            'depth24plus': 0x0000002E,
            'depth24plus-stencil8': 0x0000002F,
            'depth32float': 0x00000030,
            'depth32float-stencil8': 0x00000031,
        };

        const textureFormatEnumToString = {};
        for (const [name, value] of Object.entries(textureFormatStringToEnum)) {
            textureFormatEnumToString[value] = name;
        }

        function enumFromTextureFormat(name) {
            const value = textureFormatStringToEnum[name];
            if (value === undefined) {
                console.warn(`[WebGPU] Unknown texture format: ${name}`);
                return textureFormatStringToEnum['bgra8unorm'];
            }
            return value;
        }

        function textureFormatFromEnum(value) {
            const format = textureFormatEnumToString[value];
            if (!format) {
                console.warn(`[WebGPU] Unknown texture format enum: 0x${value.toString(16)}`);
                return 'bgra8unorm';
            }
            return format;
        }

        const GMBufferSlot = Object.freeze({
            POSITIONS: 0,
            UVS: 1,
            SURFACE_TYPES: 2,
            TRIANGLE_IDS: 3,
            NORMALS: 4,
            INDICES: 5,
            UNIFORM: 6,
            OVERLAY_UNIFORM: 7,
            OVERLAY_TEXT: 8,
            OVERLAY_MAP: 9,
            OVERLAY_VERTEX: 10,
        });

        function createWasmWebGPUHost(adapter, device) {
            let memory = null;
            let nextHandle = 1;
            const decoder = new TextDecoder('utf-8');

            const buffers = new Map();
            const shaderModules = new Map();
            const devices = new Map();
            const queues = new Map();
            const bindGroupLayouts = new Map();
            const pipelineLayouts = new Map();
            const renderPipelines = new Map();
            const bindGroups = new Map();
            const samplers = new Map();
            const textureViews = new Map();

            const GMResource = {
                BUFFER: 0,
                SAMPLER: 1,
                TEXTURE_VIEW: 2,
                STORAGE_TEXTURE: 3,
            };

            const bufferBindingTypeMap = new Map([
                [0x00000002, 'uniform'],
                [0x00000003, 'storage'],
                [0x00000004, 'read-only-storage'],
            ]);

            const samplerTypeMap = new Map([
                [0x00000002, 'filtering'],
                [0x00000003, 'non-filtering'],
                [0x00000004, 'comparison'],
            ]);

            const textureSampleTypeMap = new Map([
                [0x00000002, 'float'],
                [0x00000003, 'unfilterable-float'],
                [0x00000004, 'depth'],
                [0x00000005, 'sint'],
                [0x00000006, 'uint'],
            ]);

            const textureViewDimensionMap = new Map([
                [0x00000001, '1d'],
                [0x00000002, '2d'],
                [0x00000003, '2d-array'],
                [0x00000004, 'cube'],
                [0x00000005, 'cube-array'],
                [0x00000006, '3d'],
            ]);

            const vertexFormatMap = new Map([
                [0x0000001C, 'float32'],
                [0x0000001D, 'float32x2'],
                [0x0000001E, 'float32x3'],
                [0x0000001F, 'float32x4'],
            ]);

            const vertexStepModeMap = new Map([
                [0x00000001, 'vertex'],
                [0x00000002, 'instance'],
            ]);

            const primitiveTopologyMap = new Map([
                [0x00000004, 'triangle-list'],
                [0x00000005, 'triangle-strip'],
                [0x00000001, 'point-list'],
                [0x00000002, 'line-list'],
                [0x00000003, 'line-strip'],
            ]);

            const cullModeMap = new Map([
                [0x00000001, 'none'],
                [0x00000002, 'front'],
                [0x00000003, 'back'],
            ]);

            const frontFaceMap = new Map([
                [0x00000001, 'ccw'],
                [0x00000002, 'cw'],
            ]);

            const compareFunctionMap = new Map([
                [0x00000002, 'less'],
                [0x00000008, 'always'],
                [0x00000004, 'less-equal'],
                [0x00000005, 'greater'],
            ]);

            const filterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const mipmapFilterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const addressModeMap = new Map([
                [0x00000001, 'clamp-to-edge'],
                [0x00000002, 'repeat'],
                [0x00000003, 'mirror-repeat'],
            ]);

            const blendFactorMap = new Map([
                [0x00000001, 'zero'],
                [0x00000002, 'one'],
                [0x00000005, 'src-alpha'],
                [0x00000006, 'one-minus-src-alpha'],
                [0x00000009, 'dst-alpha'],
                [0x0000000A, 'one-minus-dst-alpha'],
            ]);

            const blendOperationMap = new Map([
                [0x00000001, 'add'],
                [0x00000002, 'subtract'],
                [0x00000003, 'reverse-subtract'],
                [0x00000004, 'min'],
                [0x00000005, 'max'],
            ]);

            const deviceHandle = nextHandle++;
            devices.set(deviceHandle, device);
            const queueHandle = nextHandle++;
            queues.set(queueHandle, device.queue);

            function requireMemory() {
                if (!memory) {
                    throw new Error('WebGPU memory not registered');
                }
            }

            function readString(ptr, length) {
                if (!ptr || length === 0) {
                    return '';
                }
                const bytes = new Uint8Array(memory.buffer, ptr, length);
                return decoder.decode(bytes);
            }

            function mapOrDefault(map, key, fallback) {
                return map.get(key) ?? fallback;
            }

            function readBindGroupLayoutEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 56;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const visibility = dv.getUint32(base + 4, true);
                    const resourceType = dv.getUint32(base + 8, true);
                    const bufferType = dv.getUint32(base + 12, true);
                    const hasDynamicOffset = !!dv.getUint32(base + 16, true);
                    const minBindingSize = Number(dv.getBigUint64(base + 20, true));
                    const samplerType = dv.getUint32(base + 28, true);
                    const textureSampleType = dv.getUint32(base + 32, true);
                    const textureViewDim = dv.getUint32(base + 36, true);
                    const textureMultisampled = !!dv.getUint32(base + 40, true);
                    const storageAccess = dv.getUint32(base + 44, true);
                    const storageFormat = dv.getUint32(base + 48, true);
                    const storageViewDim = dv.getUint32(base + 52, true);

                    const entry = { binding, visibility };
                    if (resourceType === GMResource.BUFFER) {
                        entry.buffer = {
                            type: mapOrDefault(bufferBindingTypeMap, bufferType, 'uniform'),
                            hasDynamicOffset,
                            minBindingSize,
                        };
                    } else if (resourceType === GMResource.SAMPLER) {
                        entry.sampler = {
                            type: mapOrDefault(samplerTypeMap, samplerType, 'filtering'),
                        };
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        entry.texture = {
                            sampleType: mapOrDefault(textureSampleTypeMap, textureSampleType, 'float'),
                            viewDimension: mapOrDefault(textureViewDimensionMap, textureViewDim, '2d'),
                            multisampled: textureMultisampled,
                        };
                    } else if (resourceType === GMResource.STORAGE_TEXTURE) {
                        entry.storageTexture = {
                            access: storageAccess === 0x00000003 ? 'read-only' : 'write-only',
                            format: textureFormatFromEnum(storageFormat),
                            viewDimension: mapOrDefault(textureViewDimensionMap, storageViewDim, '2d'),
                        };
                    }
                    entries.push(entry);
                }
                return entries;
            }

            function readBindGroupEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 28;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const resourceType = dv.getUint32(base + 4, true);
                    const handle = dv.getUint32(base + 8, true);
                    const offset = Number(dv.getBigUint64(base + 12, true));
                    const rawSize = dv.getBigUint64(base + 20, true);
                    const size = rawSize === 0xFFFFFFFFFFFFFFFFn ? undefined : Number(rawSize);

                    if (resourceType === GMResource.BUFFER) {
                        const buffer = buffers.get(handle);
                        if (!buffer) {
                            throw new Error(`Unknown buffer handle ${handle}`);
                        }
                        const resource = { buffer, offset };
                        if (size !== undefined) {
                            resource.size = size;
                        }
                        entries.push({
                            binding,
                            resource,
                        });
                    } else if (resourceType === GMResource.SAMPLER) {
                        const sampler = samplers.get(handle);
                        if (!sampler) {
                            throw new Error(`Unknown sampler handle ${handle}`);
                        }
                        entries.push({ binding, resource: sampler });
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        const view = textureViews.get(handle);
                        if (!view) {
                            throw new Error(`Unknown texture view handle ${handle}`);
                        }
                        entries.push({ binding, resource: view });
                    } else {
                        throw new Error(`Unsupported bind group resource type ${resourceType}`);
                    }
                }
                return entries;
            }

            function readProgrammableStage(ptr) {
                if (!ptr) {
                    return null;
                }
                const dv = new DataView(memory.buffer);
                const moduleHandle = dv.getUint32(ptr, true);
                const entryPtr = dv.getUint32(ptr + 4, true);
                const entryLength = dv.getUint32(ptr + 8, true);
                const module = shaderModules.get(moduleHandle);
                if (!module) {
                    throw new Error(`Unknown shader module handle ${moduleHandle}`);
                }
                const entryPoint = readString(entryPtr, entryLength) || 'main';
                return { module, entryPoint };
            }

            function readVertexBuffers(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const buffersOut = [];
                const dv = new DataView(memory.buffer);
                const stride = 16;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const arrayStride = dv.getUint32(base, true);
                    const stepModeValue = dv.getUint32(base + 4, true);
                    const attributeCount = dv.getUint32(base + 8, true);
                    const attributesPtr = dv.getUint32(base + 12, true);
                    const attributes = [];
                    const attrStride = 12;
                    for (let j = 0; j < attributeCount; j++) {
                        const attrBase = attributesPtr + j * attrStride;
                        const shaderLocation = dv.getUint32(attrBase, true);
                        const offset = dv.getUint32(attrBase + 4, true);
                        const formatValue = dv.getUint32(attrBase + 8, true);
                        attributes.push({
                            shaderLocation,
                            offset,
                            format: mapOrDefault(vertexFormatMap, formatValue, 'float32'),
                        });
                    }
                    buffersOut.push({
                        arrayStride,
                        stepMode: mapOrDefault(vertexStepModeMap, stepModeValue, 'vertex'),
                        attributes,
                    });
                }
                return buffersOut;
            }

            function readVertexState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const bufferCount = dv.getUint32(ptr + 4, true);
                const buffersPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    buffers: readVertexBuffers(buffersPtr, bufferCount),
                };
            }

            function readColorTargets(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const targets = [];
                const dv = new DataView(memory.buffer);
                const stride = 36;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const format = textureFormatFromEnum(dv.getUint32(base, true));
                    const blendEnabled = !!dv.getUint32(base + 4, true);
                    const colorSrc = dv.getUint32(base + 8, true);
                    const colorDst = dv.getUint32(base + 12, true);
                    const colorOp = dv.getUint32(base + 16, true);
                    const alphaSrc = dv.getUint32(base + 20, true);
                    const alphaDst = dv.getUint32(base + 24, true);
                    const alphaOp = dv.getUint32(base + 28, true);
                    const writeMask = dv.getUint32(base + 32, true);
                    const target = { format, writeMask };
                    if (blendEnabled) {
                        target.blend = {
                            color: {
                                srcFactor: mapOrDefault(blendFactorMap, colorSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, colorDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, colorOp, 'add'),
                            },
                            alpha: {
                                srcFactor: mapOrDefault(blendFactorMap, alphaSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, alphaDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, alphaOp, 'add'),
                            },
                        };
                    }
                    targets.push(target);
                }
                return targets;
            }

            function readFragmentState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const targetCount = dv.getUint32(ptr + 4, true);
                const targetsPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    targets: readColorTargets(targetsPtr, targetCount),
                };
            }

            function readPrimitiveState(ptr) {
                const dv = new DataView(memory.buffer);
                const topology = mapOrDefault(primitiveTopologyMap, dv.getUint32(ptr, true), 'triangle-list');
                const cullMode = mapOrDefault(cullModeMap, dv.getUint32(ptr + 4, true), 'none');
                const frontFace = mapOrDefault(frontFaceMap, dv.getUint32(ptr + 8, true), 'ccw');
                const stripIndexFormat = dv.getUint32(ptr + 12, true);
                const primitive = { topology, cullMode, frontFace };
                if (stripIndexFormat === 0x00000001) {
                    primitive.stripIndexFormat = 'uint16';
                } else if (stripIndexFormat === 0x00000002) {
                    primitive.stripIndexFormat = 'uint32';
                }
                return primitive;
            }

            function readDepthStencilState(ptr) {
                const dv = new DataView(memory.buffer);
                const format = textureFormatFromEnum(dv.getUint32(ptr, true));
                const depthWriteEnabled = !!dv.getUint32(ptr + 4, true);
                const depthCompare = mapOrDefault(compareFunctionMap, dv.getUint32(ptr + 8, true), 'less');
                return { format, depthWriteEnabled, depthCompare };
            }

            const imports = {
                create_instance() {
                    return 1;
                },
                surface_get_preferred_format() {
                    const preferred = navigator.gpu.getPreferredCanvasFormat();
                    const value = enumFromTextureFormat(preferred);
                    console.log('[WebGPU] Preferred canvas format (JS):', preferred, '-> enum', value);
                    return value;
                },
                device_create_buffer(deviceHandleParam, sizeLow, sizeHigh, usage, mapped) {
                    const targetDevice = devices.get(deviceHandleParam);
                    const size = sizeLow + sizeHigh * 4294967296;
                    const buffer = targetDevice.createBuffer({
                        size,
                        usage,
                        mappedAtCreation: !!mapped,
                    });
                    const handle = nextHandle++;
                    buffers.set(handle, buffer);
                    return handle;
                },
                queue_write_buffer(queueHandleParam, bufferHandle, offsetLow, offsetHigh, dataPtr, size) {
                    requireMemory();
                    const queue = queues.get(queueHandleParam);
                    const buffer = buffers.get(bufferHandle);
                    const offset = offsetLow + offsetHigh * 4294967296;
                    const source = new Uint8Array(memory.buffer, dataPtr, size);
                    queue.writeBuffer(buffer, offset, source);
                },
                device_create_shader_module(deviceHandleParam, codePtr, codeLength) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const bytes = new Uint8Array(memory.buffer, codePtr, codeLength);
                    const code = decoder.decode(bytes);
                    const module = targetDevice.createShaderModule({ code });
                    const handle = nextHandle++;
                    shaderModules.set(handle, module);
                    return handle;
                },
                device_create_bind_group_layout(deviceHandleParam, entriesPtr, entryCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const entries = readBindGroupLayoutEntries(entriesPtr, entryCount);
                    const layout = targetDevice.createBindGroupLayout({ entries });
                    const handle = nextHandle++;
                    bindGroupLayouts.set(handle, layout);
                    return handle;
                },
                device_create_pipeline_layout(deviceHandleParam, layoutsPtr, layoutCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const handles = new Uint32Array(memory.buffer, layoutsPtr, layoutCount);
                    const layouts = [];
                    for (let i = 0; i < handles.length; i++) {
                        const layout = bindGroupLayouts.get(handles[i]);
                        if (!layout) {
                            throw new Error(`Unknown bind group layout handle ${handles[i]}`);
                        }
                        layouts.push(layout);
                    }
                    const pipelineLayout = targetDevice.createPipelineLayout({ bindGroupLayouts: layouts });
                    const handle = nextHandle++;
                    pipelineLayouts.set(handle, pipelineLayout);
                    return handle;
                },
                device_create_sampler(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const base = descriptorPtr;
                    const desc = {
                        magFilter: mapOrDefault(filterModeMap, dv.getUint32(base, true), 'nearest'),
                        minFilter: mapOrDefault(filterModeMap, dv.getUint32(base + 4, true), 'nearest'),
                        mipmapFilter: mapOrDefault(mipmapFilterModeMap, dv.getUint32(base + 8, true), 'nearest'),
                        addressModeU: mapOrDefault(addressModeMap, dv.getUint32(base + 12, true), 'clamp-to-edge'),
                        addressModeV: mapOrDefault(addressModeMap, dv.getUint32(base + 16, true), 'clamp-to-edge'),
                        addressModeW: mapOrDefault(addressModeMap, dv.getUint32(base + 20, true), 'clamp-to-edge'),
                        lodMinClamp: dv.getFloat32(base + 24, true),
                        lodMaxClamp: dv.getFloat32(base + 28, true),
                    };
                    const compareValue = dv.getUint32(base + 32, true);
                    if (compareValue !== 0) {
                        desc.compare = mapOrDefault(compareFunctionMap, compareValue, 'less');
                    }
                    const sampler = targetDevice.createSampler(desc);
                    const handle = nextHandle++;
                    samplers.set(handle, sampler);
                    return handle;
                },
                device_create_bind_group(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const entryCount = dv.getUint32(descriptorPtr + 4, true);
                    const entriesPtr = dv.getUint32(descriptorPtr + 8, true);
                    const layout = bindGroupLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown bind group layout handle ${layoutHandle}`);
                    }
                    const entries = readBindGroupEntries(entriesPtr, entryCount);
                    const bindGroup = targetDevice.createBindGroup({ layout, entries });
                    const handle = nextHandle++;
                    bindGroups.set(handle, bindGroup);
                    return handle;
                },
                device_create_render_pipeline(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const vertexStatePtr = dv.getUint32(descriptorPtr + 4, true);
                    const fragmentStatePtr = dv.getUint32(descriptorPtr + 8, true);
                    const primitiveStatePtr = dv.getUint32(descriptorPtr + 12, true);
                    const depthStatePtr = dv.getUint32(descriptorPtr + 16, true);
                    const sampleCount = dv.getUint32(descriptorPtr + 20, true);
                    const alphaToCoverage = !!dv.getUint32(descriptorPtr + 24, true);

                    const layout = pipelineLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown pipeline layout handle ${layoutHandle}`);
                    }

                    const descriptor = {
                        layout,
                        vertex: readVertexState(vertexStatePtr),
                        primitive: readPrimitiveState(primitiveStatePtr),
                        multisample: {
                            count: sampleCount || 1,
                            mask: 0xFFFFFFFF,
                            alphaToCoverageEnabled: alphaToCoverage,
                        },
                    };

                    if (fragmentStatePtr !== 0) {
                        descriptor.fragment = readFragmentState(fragmentStatePtr);
                    }
                    if (depthStatePtr !== 0) {
                        descriptor.depthStencil = readDepthStencilState(depthStatePtr);
                    }

                    const pipeline = targetDevice.createRenderPipeline(descriptor);
                    const handle = nextHandle++;
                    renderPipelines.set(handle, pipeline);
                    return handle;
                },
            };

            return {
                imports,
                setMemory(mem) {
                    memory = mem;
                },
                handles: {
                    device: deviceHandle,
                    queue: queueHandle,
                },
                getBuffer(handle) {
                    return buffers.get(handle);
                },
                getShaderModule(handle) {
                    return shaderModules.get(handle);
                },
                getBindGroup(handle) {
                    return bindGroups.get(handle);
                },
                getRenderPipeline(handle) {
                    return renderPipelines.get(handle);
                },
                registerTextureView(view) {
                    const handle = nextHandle++;
                    textureViews.set(handle, view);
                    return handle;
                },
            };
        }

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Add error handling
            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const context = canvas.getContext('webgpu');

            function createSolidTexture(device, rgba, label) {
                const texture = device.createTexture({
                    label,
                    size: [1, 1, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                });
                const data = new Uint8Array(rgba);
                device.queue.writeTexture({ texture }, data, { bytesPerRow: 4 }, [1, 1, 1]);
                return texture.createView();
            }

            async function createTextureFromUrl(device, url, label) {
                console.log(`[Texture] Starting to load ${label} from ${url}`);
                try {
                    const response = await fetch(url, { mode: 'cors' });
                    console.log(`[Texture] Fetched ${label}, status: ${response.status}`);
                    const blob = await response.blob();
                    console.log(`[Texture] Blob size for ${label}: ${blob.size} bytes`);
                    const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    console.log(`[Texture] ImageBitmap created for ${label}: ${imageBitmap.width}x${imageBitmap.height}`);
                    const texture = device.createTexture({
                        label,
                        size: [imageBitmap.width, imageBitmap.height, 1],
                        format: 'rgba8unorm',
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                    console.log(`[Texture] Texture created for ${label}`);
                    device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture },
                        [imageBitmap.width, imageBitmap.height]
                    );
                    console.log(`[Texture] Data copied to texture for ${label}`);
                    const view = texture.createView();
                    console.log(`[Texture] Successfully loaded ${label}`);
                    return view;
                } catch (err) {
                    console.warn(`[Texture] ERROR loading ${label}:`, err);
                    console.warn(`Falling back to solid texture for ${label}`);
                    return createSolidTexture(device, [255, 255, 255, 255], `${label}-fallback`);
                }
            }

            // Map definition (1 = wall, 2 = wall with north/south window, 3 = wall with east/west window, 0 = floor, 5-8 = starting position with direction)
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,7,0,0,0,0,0,0,0,1],
                [1,0,1,2,1,0,2,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,0,3,0,1,0,0,1],
                [1,0,3,0,1,1,0,0,1,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction using WASM
            let startX = 1.5, startZ = 1.5, startYaw = 0;

            // Load and use WASM module for finding start position
            const wasmResponse = await fetch('gm.wasm');
            const wasmBytes = await wasmResponse.arrayBuffer();

            const webgpuHost = createWasmWebGPUHost(adapter, device);

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                wasi_snapshot_preview1: {
                // Not needed right now:
                /*
                    fd_write: () => 0,
                    proc_exit: () => {},
                    path_open: () => 0,
                    fd_close: () => 0,
                    fd_read: () => 0,
                    fd_seek: () => 0,
                    fd_tell: () => 0,
                    args_sizes_get: () => 0,
                    args_get: () => 0,
                */
                },
                webgpu: webgpuHost.imports,
            });

            const wasmInstance = wasmModule.instance;
            const memory = wasmInstance.exports.memory;
            webgpuHost.setMemory(memory);
            const find_start_position = wasmInstance.exports.find_start_position;
            const generate_mesh = wasmInstance.exports.generate_mesh;
            const gm_get_preferred_canvas_format = wasmInstance.exports.gm_get_preferred_canvas_format;
            const gm_register_webgpu_handles = wasmInstance.exports.gm_register_webgpu_handles;
            const gm_create_gpu_buffers = wasmInstance.exports.gm_create_gpu_buffers;
            const gm_get_gpu_buffer_count = wasmInstance.exports.gm_get_gpu_buffer_count;
            const gm_get_gpu_buffer_table = wasmInstance.exports.gm_get_gpu_buffer_table;
            const gm_create_shader_modules = wasmInstance.exports.gm_create_shader_modules;
            const gm_get_shader_module_count = wasmInstance.exports.gm_get_shader_module_count;
            const gm_get_shader_module_table = wasmInstance.exports.gm_get_shader_module_table;
            const gm_get_uniform_float_count = wasmInstance.exports.gm_get_uniform_float_count;
            const gm_register_texture_views = wasmInstance.exports.gm_register_texture_views;
            const gm_create_bind_group_layouts = wasmInstance.exports.gm_create_bind_group_layouts;
            const gm_create_pipeline_layouts = wasmInstance.exports.gm_create_pipeline_layouts;
            const gm_create_render_pipelines = wasmInstance.exports.gm_create_render_pipelines;
            const gm_create_bind_groups = wasmInstance.exports.gm_create_bind_groups;
            const gm_get_bind_group_table = wasmInstance.exports.gm_get_bind_group_table;
            const gm_get_bind_group_count = wasmInstance.exports.gm_get_bind_group_count;
            const gm_get_render_pipeline_table = wasmInstance.exports.gm_get_render_pipeline_table;
            const gm_get_render_pipeline_count = wasmInstance.exports.gm_get_render_pipeline_count;
            gm_register_webgpu_handles(webgpuHost.handles.device, webgpuHost.handles.queue);

            const preferredFormatEnum = gm_get_preferred_canvas_format();
            const format = textureFormatFromEnum(preferredFormatEnum);
            console.log(`[WebGPU] Preferred canvas format (via WASM): ${format} (enum 0x${preferredFormatEnum.toString(16)})`);
            context.configure({
                device,
                format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST
            });
            console.log('[WebGPU] Canvas configured');

            // Flatten the 2D map into 1D array
            const flatMap = new Int32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    flatMap[z * mapWidth + x] = map[z][x];
                }
            }

            // Allocate memory in WASM for map, startX, startZ, startYaw
            // Note: offset 1024 contains .rodata (PI constants), globals start around 1036
            // Globals take ~52KB (g_positions, g_uvs, etc.), so use offset 60000 to be safe
            const mapPtr = 60000;
            const startXPtr = mapPtr + flatMap.length * 4 + 4;
            const startZPtr = startXPtr + 4;
            const startYawPtr = startZPtr + 4;

            // Copy map to WASM memory
            new Int32Array(memory.buffer).set(flatMap, mapPtr / 4);

            // Call WASM function
            const found = find_start_position(mapPtr, mapWidth, mapHeight, startXPtr, startZPtr, startYawPtr);

            if (found) {
                // Read results from WASM memory (get fresh buffer reference after call)
                const floatView = new Float32Array(memory.buffer);
                startX = floatView[startXPtr / 4];
                startZ = floatView[startZPtr / 4];
                startYaw = floatView[startYawPtr / 4];

                // Update JavaScript map with cleared marker (get fresh buffer reference)
                const wasmMemory = new Int32Array(memory.buffer);
                for (let z = 0; z < mapHeight; z++) {
                    for (let x = 0; x < mapWidth; x++) {
                        map[z][x] = wasmMemory[mapPtr / 4 + z * mapWidth + x];
                    }
                }

                const dirName = startYaw < -1.0 ? 'North' : startYaw < 1.0 ? 'East' : startYaw < 2.0 ? 'South' : 'West';
                console.log(`Starting at (${startX}, ${startZ}) facing ${dirName} with yaw=${startYaw}`);
            } else {
                throw new Error('Starting position not found in map!');
            }

            const wallHeight = 2.0;
            const checkerSize = 4.0; // For 4x4 checker per unit

            // Generate meshes using WASM

            // Call WASM generate_mesh function
            const meshDataPtr = generate_mesh(mapPtr, mapWidth, mapHeight);

            // Read MeshData structure from WASM memory (get fresh buffer reference after call)
            const meshDataView = new Uint32Array(memory.buffer, meshDataPtr, 11); // 11 uint32 fields
            const positionsPtr = meshDataView[0];
            const uvsPtr = meshDataView[1];
            const normalsPtr = meshDataView[2];
            const surfaceTypesPtr = meshDataView[3];
            const triangleIDsPtr = meshDataView[4];
            const indicesPtr = meshDataView[5];
            const positionCount = meshDataView[6];
            const uvCount = meshDataView[7];
            const normalCount = meshDataView[8];
            const vertexCount = meshDataView[9];
            const indexCount = meshDataView[10];

            console.log(`Mesh: ${vertexCount} vertices, ${indexCount} indices, ${indexCount/3} triangles`);

            // Extract arrays from WASM memory
            const positions = new Float32Array(memory.buffer, positionsPtr, positionCount);
            const uvs = new Float32Array(memory.buffer, uvsPtr, uvCount);
            const normals = new Float32Array(memory.buffer, normalsPtr, normalCount);
            const surfaceTypes = new Float32Array(memory.buffer, surfaceTypesPtr, vertexCount);
            const triangleIDs = new Float32Array(memory.buffer, triangleIDsPtr, vertexCount);
            const indices = new Uint16Array(memory.buffer, indicesPtr, indexCount);

            // Create map data array for collision detection (still needed by JavaScript)
            const mapDataArray = new Uint32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    mapDataArray[z * mapWidth + x] = map[z][x];
                }
            }

            const bufferInitResult = gm_create_gpu_buffers();
            if (bufferInitResult !== 0) {
                throw new Error(`gm_create_gpu_buffers failed with code ${bufferInitResult}`);
            }

            const bufferHandleCount = gm_get_gpu_buffer_count();
            const bufferTablePtr = gm_get_gpu_buffer_table();
            const bufferHandleView = new Uint32Array(memory.buffer, bufferTablePtr, bufferHandleCount);
            const positionBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.POSITIONS]);
            const uvBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.UVS]);
            const surfaceTypeBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.SURFACE_TYPES]);
            const triangleIDBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.TRIANGLE_IDS]);
            const normalBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.NORMALS]);
            const indexBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.INDICES]);
            const uniformBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.UNIFORM]);
            const overlayUniformBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_UNIFORM]);
            const overlayTextBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_TEXT]);
            const overlayMapBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_MAP]);
            const overlayVertexBuffer = webgpuHost.getBuffer(bufferHandleView[GMBufferSlot.OVERLAY_VERTEX]);
            const uniformFloatCount = gm_get_uniform_float_count();

            const shaderInitResult = gm_create_shader_modules();
            if (shaderInitResult !== 0) {
                throw new Error(`gm_create_shader_modules failed with code ${shaderInitResult}`);
            }

            const shaderHandleCount = gm_get_shader_module_count();
            const shaderTablePtr = gm_get_shader_module_table();
            const shaderHandleView = new Uint32Array(memory.buffer, shaderTablePtr, shaderHandleCount);
            const vsModule = webgpuHost.getShaderModule(shaderHandleView[0]);
            const fsModule = webgpuHost.getShaderModule(shaderHandleView[1]);
            const overlayVsModule = webgpuHost.getShaderModule(shaderHandleView[2]);
            const overlayFsModule = webgpuHost.getShaderModule(shaderHandleView[3]);

            // Check for shader compilation errors
            vsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Vertex shader compilation messages:', info.messages);
                }
            });
            fsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Fragment shader compilation messages:', info.messages);
                }
            });

            console.log('Shaders compiled successfully');

            console.log('[Texture] Starting to load all textures...');
            const [wallTextureView, floorTextureView, ceilingTextureView] = await Promise.all([
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/brick_diffuse.jpg', 'wall-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg', 'floor-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/lava/cloud.png', 'ceiling-texture')
            ]);
            console.log('[Texture] All textures loaded successfully');
            console.log('[Texture] Wall texture view:', wallTextureView);
            console.log('[Texture] Floor texture view:', floorTextureView);
            console.log('[Texture] Ceiling texture view:', ceilingTextureView);
            const wallHandle = webgpuHost.registerTextureView(wallTextureView);
            const floorHandle = webgpuHost.registerTextureView(floorTextureView);
            const ceilingHandle = webgpuHost.registerTextureView(ceilingTextureView);
            gm_register_texture_views(wallHandle, floorHandle, ceilingHandle);

            let pipelineInit = gm_create_bind_group_layouts();
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_bind_group_layouts failed with code ${pipelineInit}`);
            }
            pipelineInit = gm_create_pipeline_layouts();
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_pipeline_layouts failed with code ${pipelineInit}`);
            }
            pipelineInit = gm_create_render_pipelines(preferredFormatEnum);
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_render_pipelines failed with code ${pipelineInit}`);
            }
            pipelineInit = gm_create_bind_groups();
            if (pipelineInit !== 0) {
                throw new Error(`gm_create_bind_groups failed with code ${pipelineInit}`);
            }

            const bindGroupHandleCount = gm_get_bind_group_count();
            const bindGroupTablePtr = gm_get_bind_group_table();
            const bindGroupHandleView = new Uint32Array(memory.buffer, bindGroupTablePtr, bindGroupHandleCount);
            const bindGroup = webgpuHost.getBindGroup(bindGroupHandleView[0]);
            const overlayBindGroup = webgpuHost.getBindGroup(bindGroupHandleView[1]);

            const pipelineHandleCount = gm_get_render_pipeline_count();
            const pipelineTablePtr = gm_get_render_pipeline_table();
            const pipelineHandleView = new Uint32Array(memory.buffer, pipelineTablePtr, pipelineHandleCount);
            const pipeline = webgpuHost.getRenderPipeline(pipelineHandleView[0]);
            const overlayPipeline = webgpuHost.getRenderPipeline(pipelineHandleView[1]);

            console.log('Pipelines and bind groups created successfully via WASM');

            const overlayUniformFloatCount = 24;
            const overlayTextCapacity = 256;
            device.queue.writeBuffer(overlayMapBuffer, 0, mapDataArray);

            const overlayParams = new Float32Array(overlayUniformFloatCount);
            const overlayTextArray = new Uint32Array(overlayTextCapacity);

            const GLYPH_WIDTH = 8;
            const GLYPH_HEIGHT = 8;
            const GLYPH_SPACING = 0;
            const LINE_SPACING = 2;
            const TEXT_SCALE = 4.0;
            const PANEL_PADDING_X = 12.0;
            const PANEL_PADDING_Y = 12.0;
            const PANEL_MARGIN = 10.0;
            const MAP_SCALE = 12.0;
            const MAP_GAP = 12.0;
            const NEWLINE_CODE = 255;
            const SPACE_CODE = 32;

            function charToGlyphCode(ch) {
                const code = ch.charCodeAt(0);
                if (code >= 0 && code < 256) {
                    return code;
                }
                return SPACE_CODE;
            }

            function buildOverlayText(lines) {
                let index = 0;
                let maxLineLength = 0;
                overlayTextArray.fill(SPACE_CODE);
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    maxLineLength = Math.max(maxLineLength, line.length);
                    for (let j = 0; j < line.length && index < overlayTextCapacity; j++) {
                        overlayTextArray[index++] = charToGlyphCode(line[j]);
                    }
                    if (i < lines.length - 1 && index < overlayTextCapacity) {
                        overlayTextArray[index++] = NEWLINE_CODE;
                    }
                }
                return { length: index, maxLineLength };
            }

            // Depth texture
            let depthTexture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            console.log(`Mesh generated: ${positions.length/3} vertices, ${indices.length/3} triangles`);

            // Camera and controls
            const personHeight = 1.0;
            const turnSpeed = 0.03;
            const mouseSensitivity = 0.002;
            const orientationSmoothing = 0.35;
            let cameraPos = { x: startX, y: personHeight, z: startZ };
            let yaw = startYaw;
            let pitch = 0.0;
            let targetYaw = yaw;
            let targetPitch = pitch;
            const fov = Math.PI / 3;
            const moveSpeed = 0.1;
            const collisionRadius = 0.2;
            const keys = {};
            let mapArray = map;
            let mapVisible = false;
            let mapRelativeMode = false;
            let hudVisible = true;
            let texturesEnabled = false;
            let triangleMode = false;
            let debugMode = false;
            let horizontalMovement = true;
            let lastLoggedTextureState = false;

            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (!e.repeat) {
                    if (key === 'm') {
                        mapVisible = !mapVisible;
                    } else if (key === 'r') {
                        mapRelativeMode = !mapRelativeMode;
                    } else if (key === 't') {
                        texturesEnabled = !texturesEnabled;
                        console.log('[Texture] Textures toggled:', texturesEnabled ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'v') {
                        triangleMode = !triangleMode;
                        console.log('[Visualization] Triangle mode:', triangleMode ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'b') {
                        debugMode = !debugMode;
                        console.log('[Debug] Debug mode:', debugMode ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'h') {
                        hudVisible = !hudVisible;
                    } else if (key === 'f') {
                        horizontalMovement = !horizontalMovement;
                        if (horizontalMovement) {
                            cameraPos.y = personHeight;
                        }
                    }
                }
                keys[key] = true;
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function clampPitch(value) {
                return Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, value));
            }

            function onMouseMove(e) {
                targetYaw += e.movementX * mouseSensitivity;
                targetPitch = clampPitch(targetPitch - e.movementY * mouseSensitivity);
            }

            function isWalkable(x, z) {
                const minX = Math.floor(x - collisionRadius);
                const maxX = Math.floor(x + collisionRadius);
                const minZ = Math.floor(z - collisionRadius);
                const maxZ = Math.floor(z + collisionRadius);

                for (let tz = minZ; tz <= maxZ; tz++) {
                    if (tz < 0 || tz >= mapHeight) {
                        return false;
                    }
                    for (let tx = minX; tx <= maxX; tx++) {
                        if (tx < 0 || tx >= mapWidth || mapArray[tz][tx] !== 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function updateCamera() {
                const yawDeltaFromMouse = targetYaw - yaw;
                const pitchDeltaFromMouse = targetPitch - pitch;
                yaw += yawDeltaFromMouse * orientationSmoothing;
                pitch += pitchDeltaFromMouse * orientationSmoothing;

                let arrowUsed = false;
                let yawDelta = 0;
                if (keys['arrowleft']) {
                    yawDelta -= turnSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowright']) {
                    yawDelta += turnSpeed;
                    arrowUsed = true;
                }
                if (yawDelta !== 0) {
                    yaw += yawDelta;
                    targetYaw = yaw;
                }

                let arrowForward = 0;
                if (keys['arrowup']) {
                    arrowForward += moveSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowdown']) {
                    arrowForward -= moveSpeed;
                    arrowUsed = true;
                }

                if (arrowUsed) {
                    pitch = 0;
                    targetPitch = 0;
                }

                pitch = clampPitch(pitch);
                targetPitch = clampPitch(targetPitch);

                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);

                let dx = 0;
                let dy = 0;
                let dz = 0;

                let forwardX, forwardY, forwardZ;
                if (horizontalMovement) {
                    // Person movement: horizontal plane only
                    forwardX = cosYaw;
                    forwardY = 0;
                    forwardZ = sinYaw;
                } else {
                    // Flying mode: arbitrary direction
                    forwardX = cosPitch * cosYaw;
                    forwardY = sinPitch;
                    forwardZ = cosPitch * sinYaw;
                }
                if (keys['w']) {
                    dx += forwardX * moveSpeed;
                    dy += forwardY * moveSpeed;
                    dz += forwardZ * moveSpeed;
                }
                if (keys['s']) {
                    dx -= forwardX * moveSpeed;
                    dy -= forwardY * moveSpeed;
                    dz -= forwardZ * moveSpeed;
                }
                if (keys['a']) {
                    dx += sinYaw * moveSpeed;
                    dz -= cosYaw * moveSpeed;
                }
                if (keys['d']) {
                    dx -= sinYaw * moveSpeed;
                    dz += cosYaw * moveSpeed;
                }

                if (arrowForward !== 0) {
                    dx += cosYaw * arrowForward;
                    dz += sinYaw * arrowForward;
                }

                const baseY = arrowUsed ? personHeight : cameraPos.y;
                const newY = baseY + dy;
                const candidateX = cameraPos.x + dx;
                const candidateZ = cameraPos.z + dz;

                if (isWalkable(candidateX, cameraPos.z)) {
                    cameraPos.x = candidateX;
                }
                if (isWalkable(cameraPos.x, candidateZ)) {
                    cameraPos.z = candidateZ;
                }
                cameraPos.y = Math.min(Math.max(newY, 0.1), wallHeight - 0.1);
                if (arrowUsed) {
                    cameraPos.y = personHeight;
                }
            }

            // Render loop
            let frameCount = 0;
            let lastFrameTime = performance.now();
            let fps = 0;
            let fpsUpdateTime = performance.now();
            let fpsFrameCount = 0;

            // Performance timing
            let avgFrameTime = 0;
            let avgJsTime = 0;
            let avgGpuCopyTime = 0;
            let avgGpuRenderTime = 0;
            const PERF_SMOOTHING = 0.9; // Exponential moving average

            function render() {
                const frameStartTime = performance.now();

                updateCamera();

                // FPS calc
                const currentTime = performance.now();
                fpsFrameCount++;
                if (currentTime - fpsUpdateTime >= 500) {
                    fps = Math.round(fpsFrameCount * 1000 / (currentTime - fpsUpdateTime));
                    fpsFrameCount = 0;
                    fpsUpdateTime = currentTime;
                }

                // Update uniforms with individual floats
                const data = new Float32Array(uniformFloatCount);
                data[0] = cameraPos.x;       // cameraPosX
                data[1] = cameraPos.y;       // cameraPosY
                data[2] = cameraPos.z;       // cameraPosZ
                data[3] = yaw;
                data[4] = pitch;
                data[5] = fov;
                data[6] = canvas.width;      // viewWidth
                data[7] = canvas.height;     // viewHeight
                data[8] = texturesEnabled ? 1 : 0;
                data[9] = triangleMode ? 1 : 0; // showTriangles
                data[10] = debugMode ? 1 : 0; // debugMode
                data[11] = 0;

                if (texturesEnabled !== lastLoggedTextureState) {
                    console.log('[Texture] Uniform buffer useTextures value:', data[8]);
                    lastLoggedTextureState = texturesEnabled;
                }

                device.queue.writeBuffer(uniformBuffer, 0, data);

                const jsEndTime = performance.now();
                const jsTime = jsEndTime - frameStartTime;

                const directionNames = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
                const directionIndex = Math.round(((yaw / Math.PI * 4) + 8) % 8);
                const direction = directionNames[directionIndex];

                const lines = [
                    `FPS: ${fps}  Frame: ${avgFrameTime.toFixed(2)}ms`,
                    `JS: ${avgJsTime.toFixed(2)}ms  GPU Copy: ${avgGpuCopyTime.toFixed(2)}ms  GPU Render: ${avgGpuRenderTime.toFixed(2)}ms`,
                    `Pos: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})`,
                    `Dir: ${direction} (yaw: ${(yaw * 180 / Math.PI).toFixed(1)}, pitch: ${(pitch * 180 / Math.PI).toFixed(1)})`,
                    `Movement: ${horizontalMovement ? 'Person' : 'Flying'} (f)  HUD: ${hudVisible ? 'ON' : 'OFF'} (h)  Map: ${mapVisible ? 'ON' : 'OFF'} (m/r)`,
                    `Textures: ${texturesEnabled ? 'ON' : 'OFF'} (t)  Triangles: ${triangleMode ? 'ON' : 'OFF'} (v)  Debug: ${debugMode ? 'ON' : 'OFF'} (b)`
                ];

                const { length: textLength, maxLineLength } = buildOverlayText(lines);
                const lineCount = lines.length;
                const charAdvance = GLYPH_WIDTH * TEXT_SCALE;
                const textWidth = maxLineLength * charAdvance;
                const textHeight = lineCount * GLYPH_HEIGHT * TEXT_SCALE + Math.max(0, (lineCount - 1)) * LINE_SPACING * TEXT_SCALE;
                const panelOriginX = PANEL_MARGIN;
                const panelOriginY = PANEL_MARGIN;
                const mapWidthPixels = mapWidth * MAP_SCALE;
                const mapHeightPixels = mapHeight * MAP_SCALE;
                let panelWidth = PANEL_PADDING_X * 2 + textWidth;
                if (mapVisible) {
                    panelWidth = Math.max(panelWidth, PANEL_PADDING_X * 2 + mapWidthPixels);
                }
                let panelHeight = PANEL_PADDING_Y * 2 + textHeight;
                const mapOriginX = panelOriginX + PANEL_PADDING_X;
                const mapOriginY = panelOriginY + PANEL_PADDING_Y + textHeight + (mapVisible ? MAP_GAP : 0);
                if (mapVisible) {
                    panelHeight += MAP_GAP + mapHeightPixels;
                }

                overlayParams[0] = canvas.width;
                overlayParams[1] = canvas.height;
                overlayParams[2] = panelOriginX;
                overlayParams[3] = panelOriginY;
                overlayParams[4] = panelWidth;
                overlayParams[5] = panelHeight;
                overlayParams[6] = TEXT_SCALE;
                overlayParams[7] = GLYPH_SPACING;
                overlayParams[8] = LINE_SPACING;
                overlayParams[9] = textLength;
                overlayParams[10] = PANEL_PADDING_X;
                overlayParams[11] = PANEL_PADDING_Y;
                overlayParams[12] = mapOriginX;
                overlayParams[13] = mapOriginY;
                overlayParams[14] = MAP_SCALE;
                overlayParams[15] = mapVisible ? 1 : 0;
                overlayParams[16] = mapRelativeMode ? 1 : 0;
                overlayParams[17] = mapWidth;
                overlayParams[18] = mapHeight;
                overlayParams[19] = 0;
                overlayParams[20] = cameraPos.x;
                overlayParams[21] = cameraPos.z;
                overlayParams[22] = yaw;
                overlayParams[23] = hudVisible ? 1 : 0;

                device.queue.writeBuffer(overlayUniformBuffer, 0, overlayParams);
                device.queue.writeBuffer(overlayTextBuffer, 0, overlayTextArray);

                const gpuCopyEndTime = performance.now();
                const gpuCopyTime = gpuCopyEndTime - jsEndTime;

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 }, // Sky blue clear
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store'
                    }
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, positionBuffer);
                renderPass.setVertexBuffer(1, uvBuffer);
                renderPass.setVertexBuffer(2, surfaceTypeBuffer);
                renderPass.setVertexBuffer(3, triangleIDBuffer);
                renderPass.setVertexBuffer(4, normalBuffer);
                renderPass.setIndexBuffer(indexBuffer, 'uint16');
                renderPass.drawIndexed(indices.length);

                renderPass.setPipeline(overlayPipeline);
                renderPass.setBindGroup(0, overlayBindGroup);
                renderPass.setVertexBuffer(0, overlayVertexBuffer);
                renderPass.draw(4);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                const gpuRenderEndTime = performance.now();
                const gpuRenderTime = gpuRenderEndTime - gpuCopyEndTime;
                const totalFrameTime = gpuRenderEndTime - frameStartTime;

                // Update smoothed averages
                avgFrameTime = avgFrameTime * PERF_SMOOTHING + totalFrameTime * (1 - PERF_SMOOTHING);
                avgJsTime = avgJsTime * PERF_SMOOTHING + jsTime * (1 - PERF_SMOOTHING);
                avgGpuCopyTime = avgGpuCopyTime * PERF_SMOOTHING + gpuCopyTime * (1 - PERF_SMOOTHING);
                avgGpuRenderTime = avgGpuRenderTime * PERF_SMOOTHING + gpuRenderTime * (1 - PERF_SMOOTHING);

                requestAnimationFrame(render);
            }

            render();

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Recreate depth texture
                depthTexture.destroy();
                depthTexture = device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
            });
        }

        init();
    </script>
</body>
</html>
