<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            // Map definition (1 = wall, 0 = floor, 5-8 = starting position with direction)
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,7,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,0,1,0,1,0,0,1],
                [1,0,1,0,1,1,0,0,1,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction
            let startX = 1.5, startZ = 1.5, startYaw = 0;
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    const cell = map[z][x];
                    if (cell >= 5 && cell <= 8) {
                        startX = x + 0.5;
                        startZ = z + 0.5;
                        if (cell === 5) startYaw = -Math.PI / 2;    // North
                        else if (cell === 6) startYaw = 0;          // East
                        else if (cell === 7) startYaw = Math.PI / 2; // South
                        else if (cell === 8) startYaw = Math.PI;    // West
                        map[z][x] = 0; // Clear the marker
                        console.log(`Starting at (${startX}, ${startZ}) facing ${cell===5?'North':cell===6?'East':cell===7?'South':'West'} with yaw=${startYaw}`);
                    }
                }
            }

            const wallHeight = 2.0;
            const checkerSize = 4.0; // For 4x4 checker per unit

            // Generate meshes
            const positions = [];
            const uvs = [];
            const surfaceTypes = []; // 0=floor, 1=wall, 2=ceiling
            const indices = [];
            let indexOffset = 0;

            // Floor: one big quad (matching collision coordinate system)
            const floorPositions = [
                0, 0, 0,  mapWidth, 0, 0,
                0, 0, mapHeight,  mapWidth, 0, mapHeight
            ];
            const floorUVs = [
                0, 0,  mapWidth * checkerSize, 0,
                0, mapHeight * checkerSize,  mapWidth * checkerSize, mapHeight * checkerSize
            ];
            positions.push(...floorPositions);
            uvs.push(...floorUVs);
            surfaceTypes.push(0, 0, 0, 0); // floor
            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
            indexOffset += 4;

            // Ceiling: similar but at wallHeight (matching collision coordinate system)
            const ceilingPositions = [
                0, wallHeight, 0,  mapWidth, wallHeight, 0,
                0, wallHeight, mapHeight,  mapWidth, wallHeight, mapHeight
            ];
            const ceilingUVs = floorUVs; // Same tiling
            positions.push(...ceilingPositions);
            uvs.push(...ceilingUVs);
            surfaceTypes.push(2, 2, 2, 2); // ceiling
            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
            indexOffset += 4;

            // Walls: generate quads for each boundary
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (map[z][x] === 1) {
                        // Check four directions for exposed faces
                        // North face (negative Z) - matching collision coordinate system
                        if (z === 0 || map[z - 1][x] === 0) {
                            const wallPositions = [
                                x, 0, z,  x + 1, 0, z,
                                x, wallHeight, z,  x + 1, wallHeight, z
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                        // South face (positive Z) - matching collision coordinate system
                        if (z === mapHeight - 1 || map[z + 1][x] === 0) {
                            const wallPositions = [
                                x, 0, z + 1,  x + 1, 0, z + 1,
                                x, wallHeight, z + 1,  x + 1, wallHeight, z + 1
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                        // West face (negative X) - matching collision coordinate system
                        if (x === 0 || map[z][x - 1] === 0) {
                            const wallPositions = [
                                x, 0, z,  x, 0, z + 1,
                                x, wallHeight, z,  x, wallHeight, z + 1
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                        // East face (positive X) - matching collision coordinate system
                        if (x === mapWidth - 1 || map[z][x + 1] === 0) {
                            const wallPositions = [
                                x + 1, 0, z,  x + 1, 0, z + 1,
                                x + 1, wallHeight, z,  x + 1, wallHeight, z + 1
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                    }
                }
            }

            // Buffers
            const positionBuffer = device.createBuffer({
                size: positions.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(positionBuffer.getMappedRange()).set(positions);
            positionBuffer.unmap();

            const uvBuffer = device.createBuffer({
                size: uvs.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(uvBuffer.getMappedRange()).set(uvs);
            uvBuffer.unmap();

            const surfaceTypeBuffer = device.createBuffer({
                size: surfaceTypes.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(surfaceTypeBuffer.getMappedRange()).set(surfaceTypes);
            surfaceTypeBuffer.unmap();

            const indexBuffer = device.createBuffer({
                size: indices.length * 2,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true
            });
            new Uint16Array(indexBuffer.getMappedRange()).set(indices);
            indexBuffer.unmap();

            // Uniform buffer - use individual floats to avoid vec/matrix alignment issues
            // Layout: cameraPosX, cameraPosY, cameraPosZ, yaw, pitch, fov, viewWidth, viewHeight
            const uniformBuffer = device.createBuffer({
                size: 32, // 8 floats * 4 bytes
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Shaders
            const vsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                };

                @vertex fn vs_main(
                    @location(0) position: vec3<f32>,
                    @location(1) uv: vec2<f32>,
                    @location(2) surfaceType: f32
                ) -> VertexOutput {
                    var output: VertexOutput;

                    // Transform to camera space
                    let cy = cos(u.yaw);
                    let sy = sin(u.yaw);
                    let cp = cos(u.pitch);
                    let sp = sin(u.pitch);

                    // Position relative to camera
                    let dx = position.x - u.cameraPosX;
                    let dy = position.y - u.cameraPosY;
                    let dz = position.z - u.cameraPosZ;

                    // Transform to view space
                    // Forward direction is (cos(yaw), 0, sin(yaw)) in world space
                    // Right direction is (-sin(yaw), 0, cos(yaw)) in world space
                    let viewX = -dx * sy + dz * cy;
                    let viewZ_noPitch = dx * cy + dz * sy;

                    // Rotate by pitch (around X axis in view space)
                    let viewY = dy * cp - viewZ_noPitch * sp;
                    let viewZ = dy * sp + viewZ_noPitch * cp;

                    // Calculate distance from camera for fog
                    let viewDist = sqrt(viewX * viewX + viewY * viewY + viewZ * viewZ);

                    // Perspective projection
                    let aspect = u.viewWidth / u.viewHeight;
                    let f = tan(u.fov * 0.5);
                    let near = 0.01;
                    let far = 100.0;

                    // Output clip-space coordinates (before perspective divide)
                    // Let GPU handle perspective divide by setting w = viewZ
                    let clipX = viewX / (f * aspect);
                    let clipY = viewY / f;
                    let clipZ = ((far + near) * viewZ - 2.0 * far * near) / (far - near);
                    let clipW = viewZ;

                    output.clipPos = vec4<f32>(clipX, clipY, clipZ, clipW);
                    output.worldPos = position;
                    output.surfaceType = surfaceType;
                    output.viewDist = viewDist;
                    return output;
                }
            `;

            const fsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;
                @group(0) @binding(1) var s: sampler;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                };

                @fragment fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
                    // Calculate perspective-correct UVs from world position
                    var texU: f32;
                    var texV: f32;

                    if (in.surfaceType > 1.5) {
                        // Ceiling (surfaceType = 2)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    } else if (in.surfaceType > 0.5) {
                        // Wall (surfaceType = 1)
                        // Determine orientation by measuring which axis is closest to an integer grid line
                        let fx = fract(in.worldPos.x);
                        let fz = fract(in.worldPos.z);
                        let distX = min(fx, 1.0 - fx);
                        let distZ = min(fz, 1.0 - fz);
                        if (distX < distZ) {
                            // East or West wall (plane perpendicular to X axis)
                            texU = fz;
                        } else {
                            // North or South wall (plane perpendicular to Z axis)
                            texU = fx;
                        }
                        texV = in.worldPos.y / 2.0; // wallHeight = 2.0
                    } else {
                        // Floor (surfaceType = 0)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    }

                    // Checkerboard pattern (4x4 per unit)
                    let checkerU = floor(texU * 4.0);
                    let checkerV = floor(texV * 4.0);
                    let checker = (i32(checkerU) + i32(checkerV)) & 1;
                    let checkerFactor = select(0.7, 1.0, checker == 0);

                    // Different colors based on surface type (matching g.html)
                    var baseColor: vec4<f32>;
                    if (in.surfaceType > 1.5) {
                        // Ceiling
                        baseColor = vec4<f32>(1.0, 1.0, 0.0, 1.0); // Yellow ceiling
                    } else if (in.surfaceType > 0.5) {
                        // Wall
                        baseColor = vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red walls
                    } else {
                        // Floor
                        baseColor = vec4<f32>(0.0, 0.0, 1.0, 1.0); // Blue floor
                    }

                    var color = baseColor * checkerFactor;

                    // Distance fog (exp2 like g.html)
                    let factor = exp2(-in.viewDist * 0.05);
                    color.r *= factor;
                    color.g *= factor;
                    color.b *= factor;

                    return color;
                }
            `;

            const overlayVsSource = `
                struct VertexInput {
                    @location(0) position: vec2<f32>,
                };

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) frag_position: vec2<f32>,
                };

                @vertex
                fn vertex_main(input: VertexInput) -> VertexOutput {
                    var output: VertexOutput;
                    output.position = vec4<f32>(input.position, 0.0, 1.0);
                    output.frag_position = input.position * 0.5 + vec2<f32>(0.5, 0.5);
                    return output;
                }
            `;

            const overlayFsSource = `
                struct Params {
                    viewportAndOrigin: vec4<f32>,
                    sizeAndMetrics: vec4<f32>,
                    spacingAndPadding: vec4<f32>,
                };

                @group(0) @binding(0)
                var<uniform> params: Params;

                @group(0) @binding(1)
                var<storage, read> textData: array<u32>;

                const font = array<array<u32, 7>, 5>(
                    array<u32, 7>(0xebfbe7fcu, 0x7dffddfcu, 0xb2d7dffcu, 0xb6dbc404u, 0x04446200u, 0x00008000u, 0x01200000u),
                    array<u32, 7>(0xa89b21b4u, 0xba592544u, 0xb3fb6d28u, 0xb6a45c84u, 0x9ec02ab4u, 0x70c7c000u, 0x1e100000u),
                    array<u32, 7>(0xa93fb9fcu, 0xfe5da744u, 0xd2fbae68u, 0xb6a48f9cu, 0xd0f472f4u, 0xbee8adb4u, 0xa6108000u),
                    array<u32, 7>(0xaa1269a4u, 0xb6592d54u, 0xb2db2d88u, 0xaba53d94u, 0x93d56ab4u, 0xb7c2aae8u, 0x2a154000u),
                    array<u32, 7>(0xebf3f9e4u, 0xbdff1decu, 0xbed735e8u, 0xead5ef6cu, 0x70d4efb4u, 0x78ccbab4u, 0xf9288000u),
                );

                const GLYPH_WIDTH: u32 = 3u;
                const GLYPH_HEIGHT: u32 = 5u;
                const COLON_CODE: u32 = 66u;
                const PERIOD_CODE: u32 = 67u;
                const MINUS_CODE: u32 = 68u;
                const SPACE_CODE: u32 = 69u;
                const NEWLINE_CODE: u32 = 255u;

                fn sample_font(char_idx: u32, column: u32, row: u32) -> bool {
                    let total_offset = char_idx * 3u;
                    let word_idx = total_offset / 30u;
                    let local_offset = total_offset % 30u;
                    let bits = (font[row][word_idx] >> (29u - local_offset)) & 0x07u;
                    return ((bits >> (2u - column)) & 1u) == 1u;
                }

                fn sample_custom(char_idx: u32, column: u32, row: u32) -> bool {
                    if (char_idx == COLON_CODE) {
                        return column == 1u && (row == 1u || row == 3u);
                    }
                    if (char_idx == PERIOD_CODE) {
                        return column == 1u && row == 4u;
                    }
                    if (char_idx == MINUS_CODE) {
                        return row == 2u;
                    }
                    return false;
                }

                fn glyph_on(char_idx: u32, column: u32, row: u32) -> bool {
                    if (char_idx <= 65u) {
                        return sample_font(char_idx, column, row);
                    }
                    if (char_idx == SPACE_CODE) {
                        return false;
                    }
                    return sample_custom(char_idx, column, row);
                }

                struct FragIn {
                    @location(0) frag_position: vec2<f32>,
                };

                @fragment
                fn fragment_main(fragData: FragIn) -> @location(0) vec4<f32> {
                    let panelOrigin = vec2<f32>(params.viewportAndOrigin.z, params.viewportAndOrigin.w);
                    let panelSize = vec2<f32>(params.sizeAndMetrics.x, params.sizeAndMetrics.y);
                    let scale = params.sizeAndMetrics.z;
                    let glyphSpacing = u32(params.sizeAndMetrics.w + 0.5);
                    let lineSpacing = u32(params.spacingAndPadding.x + 0.5);
                    let textLength = u32(params.spacingAndPadding.y + 0.5);
                    let padding = vec2<f32>(params.spacingAndPadding.z, params.spacingAndPadding.w);

                    let screen = vec2<f32>(
                        fragData.frag_position.x * params.viewportAndOrigin.x,
                        (1.0 - fragData.frag_position.y) * params.viewportAndOrigin.y
                    );

                    let center = vec2<f32>(
                        params.viewportAndOrigin.x * 0.5,
                        params.viewportAndOrigin.y * 0.5
                    );
                    let crosshairSize = 10.0;
                    let crosshairThickness = 2.0;
                    let innerThickness = 1.0;
                    let dx = abs(screen.x - center.x);
                    let dy = abs(screen.y - center.y);
                    if ((dx < crosshairThickness && dy < crosshairSize) ||
                        (dy < crosshairThickness && dx < crosshairSize)) {
                        if (dx < innerThickness || dy < innerThickness) {
                            return vec4<f32>(1.0, 1.0, 1.0, 1.0);
                        }
                        return vec4<f32>(0.0, 0.0, 0.0, 1.0);
                    }

                    let panelMax = panelOrigin + panelSize;
                    if (screen.x < panelOrigin.x || screen.x > panelMax.x || screen.y < panelOrigin.y || screen.y > panelMax.y) {
                        return vec4<f32>(0.0, 0.0, 0.0, 0.0);
                    }

                    var color = vec4<f32>(0.0, 1.0, 0.0, 0.3);

                    let textLocal = screen - (panelOrigin + padding);
                    if (textLocal.x < 0.0 || textLocal.y < 0.0) {
                        return color;
                    }

                    var cursorX: u32 = 0u;
                    var cursorY: u32 = 0u;
                    var idx: u32 = 0u;
                    loop {
                        if (idx >= textLength) { break; }
                        let code = textData[idx];
                        if (code == NEWLINE_CODE) {
                            cursorX = 0u;
                            cursorY = cursorY + GLYPH_HEIGHT + lineSpacing;
                            idx = idx + 1u;
                            continue;
                        }

                        let glyphOrigin = vec2<f32>(
                            f32(cursorX) * scale,
                            f32(cursorY) * scale
                        );
                        let glyphLocal = textLocal - glyphOrigin;
                        if (glyphLocal.x >= 0.0 && glyphLocal.y >= 0.0 &&
                            glyphLocal.x < scale * f32(GLYPH_WIDTH) &&
                            glyphLocal.y < scale * f32(GLYPH_HEIGHT)) {
                            let column = u32(floor(glyphLocal.x / scale));
                            let row = u32(floor(glyphLocal.y / scale));
                            if (column < GLYPH_WIDTH && row < GLYPH_HEIGHT) {
                                if (glyph_on(code, column, row)) {
                                    return vec4<f32>(1.0, 0.0, 0.0, 1.0);
                                }
                            }
                        }

                        cursorX = cursorX + GLYPH_WIDTH + glyphSpacing;
                        idx = idx + 1u;
                    }

                    return color;
                }
            `;

            const vsModule = device.createShaderModule({ code: vsSource });
            const fsModule = device.createShaderModule({ code: fsSource });
            console.log('Shaders compiled successfully');

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
                ]
            });

            const overlayBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: {
                    module: vsModule,
                    entryPoint: 'vs_main',
                    buffers: [
                        {
                            arrayStride: 12, // vec3<f32>
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
                        },
                        {
                            arrayStride: 8, // vec2<f32>
                            attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }]
                        },
                        {
                            arrayStride: 4, // f32 surfaceType
                            attributes: [{ shaderLocation: 2, offset: 0, format: 'float32' }]
                        }
                    ]
                },
                fragment: {
                    module: fsModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: {
                    topology: 'triangle-list',
                    cullMode: 'none'  // No backface culling
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth24plus'
                }
            });

            const overlayVsModule = device.createShaderModule({ code: overlayVsSource });
            const overlayFsModule = device.createShaderModule({ code: overlayFsSource });

            const overlayPipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [overlayBindGroupLayout] }),
                vertex: {
                    module: overlayVsModule,
                    entryPoint: 'vertex_main',
                    buffers: [
                        {
                            arrayStride: 8,
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }]
                        }
                    ]
                },
                fragment: {
                    module: overlayFsModule,
                    entryPoint: 'fragment_main',
                    targets: [{
                        format,
                        blend: {
                            color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                            alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                        }
                    }]
                },
                primitive: {
                    topology: 'triangle-strip'
                },
                depthStencil: {
                    depthWriteEnabled: false,
                    depthCompare: 'always',
                    format: 'depth24plus'
                }
            });

            const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: sampler }
                ]
            });
            console.log('Pipeline and bind group created successfully');

            const overlayUniformBuffer = device.createBuffer({
                size: 64,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const overlayTextCapacity = 256;
            const overlayTextBuffer = device.createBuffer({
                size: overlayTextCapacity * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });

            const overlayBindGroup = device.createBindGroup({
                layout: overlayBindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: overlayUniformBuffer } },
                    { binding: 1, resource: { buffer: overlayTextBuffer } }
                ]
            });

            const overlayVertexData = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                 1,  1,
            ]);

            const overlayVertexBuffer = device.createBuffer({
                size: overlayVertexData.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(overlayVertexBuffer.getMappedRange()).set(overlayVertexData);
            overlayVertexBuffer.unmap();

            const overlayParams = new Float32Array(16);
            const overlayTextArray = new Uint32Array(overlayTextCapacity);

            const GLYPH_WIDTH = 3;
            const GLYPH_HEIGHT = 5;
            const GLYPH_SPACING = 1;
            const LINE_SPACING = 2;
            const TEXT_SCALE = 6.0;
            const PANEL_PADDING_X = 12.0;
            const PANEL_PADDING_Y = 12.0;
            const PANEL_MARGIN = 10.0;
            const NEWLINE_CODE = 255;
            const COLON_CODE = 66;
            const PERIOD_CODE = 67;
            const MINUS_CODE = 68;
            const SPACE_CODE = 69;

            function charToGlyphCode(ch) {
                if (ch >= '0' && ch <= '9') return ch.charCodeAt(0) - 48;
                if (ch >= 'A' && ch <= 'Z') return 10 + (ch.charCodeAt(0) - 65);
                if (ch >= 'a' && ch <= 'z') return 36 + (ch.charCodeAt(0) - 97);
                switch (ch) {
                    case ' ': return SPACE_CODE;
                    case ':': return COLON_CODE;
                    case '.': return PERIOD_CODE;
                    case '-': return MINUS_CODE;
                    case '(': return 62;
                    case ')': return 63;
                    case ',': return 64;
                    case '°': return 65;
                    default: return SPACE_CODE;
                }
            }

            function buildOverlayText(lines) {
                let index = 0;
                let maxLineLength = 0;
                overlayTextArray.fill(SPACE_CODE);
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    maxLineLength = Math.max(maxLineLength, line.length);
                    for (let j = 0; j < line.length && index < overlayTextCapacity; j++) {
                        overlayTextArray[index++] = charToGlyphCode(line[j]);
                    }
                    if (i < lines.length - 1 && index < overlayTextCapacity) {
                        overlayTextArray[index++] = NEWLINE_CODE;
                    }
                }
                return { length: index, maxLineLength };
            }

            // Depth texture
            let depthTexture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            console.log(`Mesh generated: ${positions.length/3} vertices, ${indices.length/3} triangles`);

            // Camera and controls
            const personHeight = 1.0;
            const turnSpeed = 0.03;
            const mouseSensitivity = 0.002;
            const orientationSmoothing = 0.35;
            let cameraPos = { x: startX, y: personHeight, z: startZ };
            let yaw = startYaw;
            let pitch = 0.0;
            let targetYaw = yaw;
            let targetPitch = pitch;
            const fov = Math.PI / 3;
            const moveSpeed = 0.1;
            const collisionRadius = 0.2;
            const keys = {};
            let mapArray = map;

            document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function clampPitch(value) {
                return Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, value));
            }

            function onMouseMove(e) {
                targetYaw += e.movementX * mouseSensitivity;
                targetPitch = clampPitch(targetPitch - e.movementY * mouseSensitivity);
            }

            function isWalkable(x, z) {
                const minX = Math.floor(x - collisionRadius);
                const maxX = Math.floor(x + collisionRadius);
                const minZ = Math.floor(z - collisionRadius);
                const maxZ = Math.floor(z + collisionRadius);

                for (let tz = minZ; tz <= maxZ; tz++) {
                    if (tz < 0 || tz >= mapHeight) {
                        return false;
                    }
                    for (let tx = minX; tx <= maxX; tx++) {
                        if (tx < 0 || tx >= mapWidth || mapArray[tz][tx] !== 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function updateCamera() {
                const yawDeltaFromMouse = targetYaw - yaw;
                const pitchDeltaFromMouse = targetPitch - pitch;
                yaw += yawDeltaFromMouse * orientationSmoothing;
                pitch += pitchDeltaFromMouse * orientationSmoothing;

                let arrowUsed = false;
                let yawDelta = 0;
                if (keys['arrowleft']) {
                    yawDelta -= turnSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowright']) {
                    yawDelta += turnSpeed;
                    arrowUsed = true;
                }
                if (yawDelta !== 0) {
                    yaw += yawDelta;
                    targetYaw = yaw;
                }

                let arrowForward = 0;
                if (keys['arrowup']) {
                    arrowForward += moveSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowdown']) {
                    arrowForward -= moveSpeed;
                    arrowUsed = true;
                }

                if (arrowUsed) {
                    pitch = 0;
                    targetPitch = 0;
                }

                pitch = clampPitch(pitch);
                targetPitch = clampPitch(targetPitch);

                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);

                let dx = 0;
                let dy = 0;
                let dz = 0;

                const forwardX = cosPitch * cosYaw;
                const forwardY = sinPitch;
                const forwardZ = cosPitch * sinYaw;
                if (keys['w']) {
                    dx += forwardX * moveSpeed;
                    dy += forwardY * moveSpeed;
                    dz += forwardZ * moveSpeed;
                }
                if (keys['s']) {
                    dx -= forwardX * moveSpeed;
                    dy -= forwardY * moveSpeed;
                    dz -= forwardZ * moveSpeed;
                }
                if (keys['a']) {
                    dx += sinYaw * moveSpeed;
                    dz -= cosYaw * moveSpeed;
                }
                if (keys['d']) {
                    dx -= sinYaw * moveSpeed;
                    dz += cosYaw * moveSpeed;
                }

                if (arrowForward !== 0) {
                    dx += cosYaw * arrowForward;
                    dz += sinYaw * arrowForward;
                }

                const baseY = arrowUsed ? personHeight : cameraPos.y;
                const newY = baseY + dy;
                const candidateX = cameraPos.x + dx;
                const candidateZ = cameraPos.z + dz;

                if (isWalkable(candidateX, cameraPos.z)) {
                    cameraPos.x = candidateX;
                }
                if (isWalkable(cameraPos.x, candidateZ)) {
                    cameraPos.z = candidateZ;
                }
                cameraPos.y = Math.min(Math.max(newY, 0.1), wallHeight - 0.1);
                if (arrowUsed) {
                    cameraPos.y = personHeight;
                }
            }

            // Render loop
            let frameCount = 0;
            let lastFrameTime = performance.now();
            let fps = 0;
            let fpsUpdateTime = performance.now();
            let fpsFrameCount = 0;

            function render() {
                updateCamera();

                // FPS calc
                const currentTime = performance.now();
                fpsFrameCount++;
                if (currentTime - fpsUpdateTime >= 500) {
                    fps = Math.round(fpsFrameCount * 1000 / (currentTime - fpsUpdateTime));
                    fpsFrameCount = 0;
                    fpsUpdateTime = currentTime;
                }

                // Update uniforms with individual floats
                const data = new Float32Array(8);
                data[0] = cameraPos.x;       // cameraPosX
                data[1] = cameraPos.y;       // cameraPosY
                data[2] = cameraPos.z;       // cameraPosZ
                data[3] = yaw;
                data[4] = pitch;
                data[5] = fov;
                data[6] = canvas.width;      // viewWidth
                data[7] = canvas.height;     // viewHeight

                device.queue.writeBuffer(uniformBuffer, 0, data);

                const directionNames = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
                const directionIndex = Math.round(((yaw / Math.PI * 4) + 8) % 8);
                const direction = directionNames[directionIndex];

                const lines = [
                    `FPS: ${fps}`,
                    `Pos: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})`,
                    `Dir: ${direction} (yaw: ${(yaw * 180 / Math.PI).toFixed(1)}°, pitch: ${(pitch * 180 / Math.PI).toFixed(1)}°)`
                ];

                const { length: textLength, maxLineLength } = buildOverlayText(lines);
                const lineCount = lines.length;
                const charAdvance = (GLYPH_WIDTH + GLYPH_SPACING) * TEXT_SCALE;
                const panelWidth = PANEL_PADDING_X * 2 + maxLineLength * charAdvance;
                const panelHeight = PANEL_PADDING_Y * 2 + lineCount * GLYPH_HEIGHT * TEXT_SCALE + Math.max(0, (lineCount - 1)) * LINE_SPACING * TEXT_SCALE;
                const panelOriginX = PANEL_MARGIN;
                const panelOriginY = PANEL_MARGIN;

                overlayParams[0] = canvas.width;
                overlayParams[1] = canvas.height;
                overlayParams[2] = panelOriginX;
                overlayParams[3] = panelOriginY;
                overlayParams[4] = panelWidth;
                overlayParams[5] = panelHeight;
                overlayParams[6] = TEXT_SCALE;
                overlayParams[7] = GLYPH_SPACING;
                overlayParams[8] = LINE_SPACING;
                overlayParams[9] = textLength;
                overlayParams[10] = PANEL_PADDING_X;
                overlayParams[11] = PANEL_PADDING_Y;
                overlayParams[12] = 0;
                overlayParams[13] = 0;
                overlayParams[14] = 0;
                overlayParams[15] = 0;

                device.queue.writeBuffer(overlayUniformBuffer, 0, overlayParams);
                device.queue.writeBuffer(overlayTextBuffer, 0, overlayTextArray);

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 }, // Sky blue clear
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store'
                    }
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, positionBuffer);
                renderPass.setVertexBuffer(1, uvBuffer);
                renderPass.setVertexBuffer(2, surfaceTypeBuffer);
                renderPass.setIndexBuffer(indexBuffer, 'uint16');
                renderPass.drawIndexed(indices.length);

                renderPass.setPipeline(overlayPipeline);
                renderPass.setBindGroup(0, overlayBindGroup);
                renderPass.setVertexBuffer(0, overlayVertexBuffer);
                renderPass.draw(4);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                requestAnimationFrame(render);
            }

            render();

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Recreate depth texture
                depthTexture.destroy();
                depthTexture = device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
            });
        }

        init();
    </script>
</body>
</html>
