<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        const textureFormatStringToEnum = {
            'rgba8unorm': 0x00000016,
            'rgba8unorm-srgb': 0x00000017,
            'bgra8unorm': 0x0000001B,
            'bgra8unorm-srgb': 0x0000001C,
        };

        const textureFormatEnumToString = {};
        for (const [name, value] of Object.entries(textureFormatStringToEnum)) {
            textureFormatEnumToString[value] = name;
        }

        function enumFromTextureFormat(name) {
            const value = textureFormatStringToEnum[name];
            if (value === undefined) {
                console.warn(`[WebGPU] Unknown texture format: ${name}`);
                return textureFormatStringToEnum['bgra8unorm'];
            }
            return value;
        }

        function textureFormatFromEnum(value) {
            const format = textureFormatEnumToString[value];
            if (!format) {
                console.warn(`[WebGPU] Unknown texture format enum: 0x${value.toString(16)}`);
                return 'bgra8unorm';
            }
            return format;
        }

        function createWasmWebGPUHost(adapter, device) {
            let memory = null;
            let nextHandle = 1;
            const buffers = new Map();
            const shaderModules = new Map();
            const devices = new Map();
            const queues = new Map();
            const decoder = new TextDecoder('utf-8');

            const deviceHandle = nextHandle++;
            devices.set(deviceHandle, device);
            const queueHandle = nextHandle++;
            queues.set(queueHandle, device.queue);

            const imports = {
                create_instance() {
                    return 1;
                },
                surface_get_preferred_format() {
                    const preferred = navigator.gpu.getPreferredCanvasFormat();
                    const value = enumFromTextureFormat(preferred);
                    console.log('[WebGPU] Preferred canvas format (JS):', preferred, '-> enum', value);
                    return value;
                },
                device_create_buffer(deviceHandleParam, sizeLow, sizeHigh, usage, mapped) {
                    const targetDevice = devices.get(deviceHandleParam);
                    const size = sizeLow + sizeHigh * 4294967296;
                    const buffer = targetDevice.createBuffer({
                        size,
                        usage,
                        mappedAtCreation: !!mapped,
                    });
                    const handle = nextHandle++;
                    buffers.set(handle, buffer);
                    return handle;
                },
                queue_write_buffer(queueHandleParam, bufferHandle, offsetLow, offsetHigh, dataPtr, size) {
                    if (!memory) {
                        throw new Error('WebGPU memory not registered');
                    }
                    const queue = queues.get(queueHandleParam);
                    const buffer = buffers.get(bufferHandle);
                    const offset = offsetLow + offsetHigh * 4294967296;
                    const source = new Uint8Array(memory.buffer, dataPtr, size);
                    queue.writeBuffer(buffer, offset, source);
                },
                device_create_shader_module(deviceHandleParam, codePtr, codeLength) {
                    if (!memory) {
                        throw new Error('WebGPU memory not registered');
                    }
                    const targetDevice = devices.get(deviceHandleParam);
                    const bytes = new Uint8Array(memory.buffer, codePtr, codeLength);
                    const code = decoder.decode(bytes);
                    const module = targetDevice.createShaderModule({ code });
                    const handle = nextHandle++;
                    shaderModules.set(handle, module);
                    return handle;
                },
            };

            return {
                imports,
                setMemory(mem) {
                    memory = mem;
                },
                handles: {
                    device: deviceHandle,
                    queue: queueHandle,
                },
                getBuffer(handle) {
                    return buffers.get(handle);
                },
                getShaderModule(handle) {
                    return shaderModules.get(handle);
                },
            };
        }

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Add error handling
            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const context = canvas.getContext('webgpu');

            function createSolidTexture(device, rgba, label) {
                const texture = device.createTexture({
                    label,
                    size: [1, 1, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                });
                const data = new Uint8Array(rgba);
                device.queue.writeTexture({ texture }, data, { bytesPerRow: 4 }, [1, 1, 1]);
                return texture.createView();
            }

            async function createTextureFromUrl(device, url, label) {
                console.log(`[Texture] Starting to load ${label} from ${url}`);
                try {
                    const response = await fetch(url, { mode: 'cors' });
                    console.log(`[Texture] Fetched ${label}, status: ${response.status}`);
                    const blob = await response.blob();
                    console.log(`[Texture] Blob size for ${label}: ${blob.size} bytes`);
                    const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    console.log(`[Texture] ImageBitmap created for ${label}: ${imageBitmap.width}x${imageBitmap.height}`);
                    const texture = device.createTexture({
                        label,
                        size: [imageBitmap.width, imageBitmap.height, 1],
                        format: 'rgba8unorm',
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                    console.log(`[Texture] Texture created for ${label}`);
                    device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture },
                        [imageBitmap.width, imageBitmap.height]
                    );
                    console.log(`[Texture] Data copied to texture for ${label}`);
                    const view = texture.createView();
                    console.log(`[Texture] Successfully loaded ${label}`);
                    return view;
                } catch (err) {
                    console.warn(`[Texture] ERROR loading ${label}:`, err);
                    console.warn(`Falling back to solid texture for ${label}`);
                    return createSolidTexture(device, [255, 255, 255, 255], `${label}-fallback`);
                }
            }

            // Map definition (1 = wall, 2 = wall with north/south window, 3 = wall with east/west window, 0 = floor, 5-8 = starting position with direction)
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,7,0,0,0,0,0,0,0,1],
                [1,0,1,2,1,0,2,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,0,3,0,1,0,0,1],
                [1,0,3,0,1,1,0,0,1,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction using WASM
            let startX = 1.5, startZ = 1.5, startYaw = 0;

            // Load and use WASM module for finding start position
            const wasmResponse = await fetch('gm.wasm');
            const wasmBytes = await wasmResponse.arrayBuffer();

            const webgpuHost = createWasmWebGPUHost(adapter, device);

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                wasi_snapshot_preview1: {
                // Not needed right now:
                /*
                    fd_write: () => 0,
                    proc_exit: () => {},
                    path_open: () => 0,
                    fd_close: () => 0,
                    fd_read: () => 0,
                    fd_seek: () => 0,
                    fd_tell: () => 0,
                    args_sizes_get: () => 0,
                    args_get: () => 0,
                */
                },
                webgpu: webgpuHost.imports,
            });

            const wasmInstance = wasmModule.instance;
            const memory = wasmInstance.exports.memory;
            webgpuHost.setMemory(memory);
            const find_start_position = wasmInstance.exports.find_start_position;
            const generate_mesh = wasmInstance.exports.generate_mesh;
            const gm_get_preferred_canvas_format = wasmInstance.exports.gm_get_preferred_canvas_format;
            const gm_register_webgpu_handles = wasmInstance.exports.gm_register_webgpu_handles;
            const gm_create_gpu_buffers = wasmInstance.exports.gm_create_gpu_buffers;
            const gm_get_gpu_buffer_count = wasmInstance.exports.gm_get_gpu_buffer_count;
            const gm_get_gpu_buffer_table = wasmInstance.exports.gm_get_gpu_buffer_table;
            const gm_create_shader_modules = wasmInstance.exports.gm_create_shader_modules;
            const gm_get_shader_module_count = wasmInstance.exports.gm_get_shader_module_count;
            const gm_get_shader_module_table = wasmInstance.exports.gm_get_shader_module_table;
            const gm_get_uniform_float_count = wasmInstance.exports.gm_get_uniform_float_count;
            gm_register_webgpu_handles(webgpuHost.handles.device, webgpuHost.handles.queue);

            const preferredFormatEnum = gm_get_preferred_canvas_format();
            const format = textureFormatFromEnum(preferredFormatEnum);
            console.log(`[WebGPU] Preferred canvas format (via WASM): ${format} (enum 0x${preferredFormatEnum.toString(16)})`);
            context.configure({
                device,
                format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST
            });
            console.log('[WebGPU] Canvas configured');

            // Flatten the 2D map into 1D array
            const flatMap = new Int32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    flatMap[z * mapWidth + x] = map[z][x];
                }
            }

            // Allocate memory in WASM for map, startX, startZ, startYaw
            // Note: offset 1024 contains .rodata (PI constants), globals start around 1036
            // Globals take ~52KB (g_positions, g_uvs, etc.), so use offset 60000 to be safe
            const mapPtr = 60000;
            const startXPtr = mapPtr + flatMap.length * 4 + 4;
            const startZPtr = startXPtr + 4;
            const startYawPtr = startZPtr + 4;

            // Copy map to WASM memory
            new Int32Array(memory.buffer).set(flatMap, mapPtr / 4);

            // Call WASM function
            const found = find_start_position(mapPtr, mapWidth, mapHeight, startXPtr, startZPtr, startYawPtr);

            if (found) {
                // Read results from WASM memory (get fresh buffer reference after call)
                const floatView = new Float32Array(memory.buffer);
                startX = floatView[startXPtr / 4];
                startZ = floatView[startZPtr / 4];
                startYaw = floatView[startYawPtr / 4];

                // Update JavaScript map with cleared marker (get fresh buffer reference)
                const wasmMemory = new Int32Array(memory.buffer);
                for (let z = 0; z < mapHeight; z++) {
                    for (let x = 0; x < mapWidth; x++) {
                        map[z][x] = wasmMemory[mapPtr / 4 + z * mapWidth + x];
                    }
                }

                const dirName = startYaw < -1.0 ? 'North' : startYaw < 1.0 ? 'East' : startYaw < 2.0 ? 'South' : 'West';
                console.log(`Starting at (${startX}, ${startZ}) facing ${dirName} with yaw=${startYaw}`);
            } else {
                throw new Error('Starting position not found in map!');
            }

            const wallHeight = 2.0;
            const checkerSize = 4.0; // For 4x4 checker per unit

            // Generate meshes using WASM

            // Call WASM generate_mesh function
            const meshDataPtr = generate_mesh(mapPtr, mapWidth, mapHeight);

            // Read MeshData structure from WASM memory (get fresh buffer reference after call)
            const meshDataView = new Uint32Array(memory.buffer, meshDataPtr, 11); // 11 uint32 fields
            const positionsPtr = meshDataView[0];
            const uvsPtr = meshDataView[1];
            const normalsPtr = meshDataView[2];
            const surfaceTypesPtr = meshDataView[3];
            const triangleIDsPtr = meshDataView[4];
            const indicesPtr = meshDataView[5];
            const positionCount = meshDataView[6];
            const uvCount = meshDataView[7];
            const normalCount = meshDataView[8];
            const vertexCount = meshDataView[9];
            const indexCount = meshDataView[10];

            console.log(`Mesh: ${vertexCount} vertices, ${indexCount} indices, ${indexCount/3} triangles`);

            // Extract arrays from WASM memory
            const positions = new Float32Array(memory.buffer, positionsPtr, positionCount);
            const uvs = new Float32Array(memory.buffer, uvsPtr, uvCount);
            const normals = new Float32Array(memory.buffer, normalsPtr, normalCount);
            const surfaceTypes = new Float32Array(memory.buffer, surfaceTypesPtr, vertexCount);
            const triangleIDs = new Float32Array(memory.buffer, triangleIDsPtr, vertexCount);
            const indices = new Uint16Array(memory.buffer, indicesPtr, indexCount);

            // Create map data array for collision detection (still needed by JavaScript)
            const mapDataArray = new Uint32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    mapDataArray[z * mapWidth + x] = map[z][x];
                }
            }

            const bufferInitResult = gm_create_gpu_buffers();
            if (bufferInitResult !== 0) {
                throw new Error(`gm_create_gpu_buffers failed with code ${bufferInitResult}`);
            }

            const bufferHandleCount = gm_get_gpu_buffer_count();
            const bufferTablePtr = gm_get_gpu_buffer_table();
            const bufferHandleView = new Uint32Array(memory.buffer, bufferTablePtr, bufferHandleCount);
            const positionBuffer = webgpuHost.getBuffer(bufferHandleView[0]);
            const uvBuffer = webgpuHost.getBuffer(bufferHandleView[1]);
            const surfaceTypeBuffer = webgpuHost.getBuffer(bufferHandleView[2]);
            const triangleIDBuffer = webgpuHost.getBuffer(bufferHandleView[3]);
            const normalBuffer = webgpuHost.getBuffer(bufferHandleView[4]);
            const indexBuffer = webgpuHost.getBuffer(bufferHandleView[5]);
            const uniformBuffer = webgpuHost.getBuffer(bufferHandleView[6]);
            const uniformFloatCount = gm_get_uniform_float_count();

            const shaderInitResult = gm_create_shader_modules();
            if (shaderInitResult !== 0) {
                throw new Error(`gm_create_shader_modules failed with code ${shaderInitResult}`);
            }

            const shaderHandleCount = gm_get_shader_module_count();
            const shaderTablePtr = gm_get_shader_module_table();
            const shaderHandleView = new Uint32Array(memory.buffer, shaderTablePtr, shaderHandleCount);
            const vsModule = webgpuHost.getShaderModule(shaderHandleView[0]);
            const fsModule = webgpuHost.getShaderModule(shaderHandleView[1]);
            const overlayVsModule = webgpuHost.getShaderModule(shaderHandleView[2]);
            const overlayFsModule = webgpuHost.getShaderModule(shaderHandleView[3]);

            // Check for shader compilation errors
            vsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Vertex shader compilation messages:', info.messages);
                }
            });
            fsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Fragment shader compilation messages:', info.messages);
                }
            });

            console.log('Shaders compiled successfully');

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                    { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                    { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                ]
            });

            const overlayBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: {
                    module: vsModule,
                    entryPoint: 'vs_main',
                    buffers: [
                        {
                            arrayStride: 12, // vec3<f32>
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
                        },
                        {
                            arrayStride: 8, // vec2<f32>
                            attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }]
                        },
                        {
                            arrayStride: 4, // f32 surfaceType
                            attributes: [{ shaderLocation: 2, offset: 0, format: 'float32' }]
                        },
                        {
                            arrayStride: 4, // f32 triangleID
                            attributes: [{ shaderLocation: 3, offset: 0, format: 'float32' }]
                        },
                        {
                            arrayStride: 12, // vec3<f32> normal
                            attributes: [{ shaderLocation: 4, offset: 0, format: 'float32x3' }]
                        }
                    ]
                },
                fragment: {
                    module: fsModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: {
                    topology: 'triangle-list',
                    cullMode: 'none'  // No backface culling
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth24plus'
                }
            });

            const overlayPipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [overlayBindGroupLayout] }),
                vertex: {
                    module: overlayVsModule,
                    entryPoint: 'vertex_main',
                    buffers: [
                        {
                            arrayStride: 8,
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }]
                        }
                    ]
                },
                fragment: {
                    module: overlayFsModule,
                    entryPoint: 'fragment_main',
                    targets: [{
                        format,
                        blend: {
                            color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                            alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                        }
                    }]
                },
                primitive: {
                    topology: 'triangle-strip'
                },
                depthStencil: {
                    depthWriteEnabled: false,
                    depthCompare: 'always',
                    format: 'depth24plus'
                }
            });

            console.log('[Texture] Starting to load all textures...');
            const [wallTextureView, floorTextureView, ceilingTextureView] = await Promise.all([
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/brick_diffuse.jpg', 'wall-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg', 'floor-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/lava/cloud.png', 'ceiling-texture')
            ]);
            console.log('[Texture] All textures loaded successfully');
            console.log('[Texture] Wall texture view:', wallTextureView);
            console.log('[Texture] Floor texture view:', floorTextureView);
            console.log('[Texture] Ceiling texture view:', ceilingTextureView);

            const sampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                addressModeU: 'repeat',
                addressModeV: 'repeat'
            });
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: sampler },
                    { binding: 2, resource: wallTextureView },
                    { binding: 3, resource: floorTextureView },
                    { binding: 4, resource: ceilingTextureView }
                ]
            });
            console.log('Pipeline and bind group created successfully');

            const overlayUniformFloatCount = 24;
            const overlayUniformBuffer = device.createBuffer({
                size: overlayUniformFloatCount * 4,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const overlayTextCapacity = 256;
            const overlayTextBuffer = device.createBuffer({
                size: overlayTextCapacity * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });

            const overlayMapBuffer = device.createBuffer({
                size: mapDataArray.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(overlayMapBuffer, 0, mapDataArray);

            const overlayBindGroup = device.createBindGroup({
                layout: overlayBindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: overlayUniformBuffer } },
                    { binding: 1, resource: { buffer: overlayTextBuffer } },
                    { binding: 2, resource: { buffer: overlayMapBuffer } }
                ]
            });

            const overlayVertexData = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                 1,  1,
            ]);

            const overlayVertexBuffer = device.createBuffer({
                size: overlayVertexData.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(overlayVertexBuffer.getMappedRange()).set(overlayVertexData);
            overlayVertexBuffer.unmap();

            const overlayParams = new Float32Array(overlayUniformFloatCount);
            const overlayTextArray = new Uint32Array(overlayTextCapacity);

            const GLYPH_WIDTH = 8;
            const GLYPH_HEIGHT = 8;
            const GLYPH_SPACING = 0;
            const LINE_SPACING = 2;
            const TEXT_SCALE = 4.0;
            const PANEL_PADDING_X = 12.0;
            const PANEL_PADDING_Y = 12.0;
            const PANEL_MARGIN = 10.0;
            const MAP_SCALE = 12.0;
            const MAP_GAP = 12.0;
            const NEWLINE_CODE = 255;
            const SPACE_CODE = 32;

            function charToGlyphCode(ch) {
                const code = ch.charCodeAt(0);
                if (code >= 0 && code < 256) {
                    return code;
                }
                return SPACE_CODE;
            }

            function buildOverlayText(lines) {
                let index = 0;
                let maxLineLength = 0;
                overlayTextArray.fill(SPACE_CODE);
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    maxLineLength = Math.max(maxLineLength, line.length);
                    for (let j = 0; j < line.length && index < overlayTextCapacity; j++) {
                        overlayTextArray[index++] = charToGlyphCode(line[j]);
                    }
                    if (i < lines.length - 1 && index < overlayTextCapacity) {
                        overlayTextArray[index++] = NEWLINE_CODE;
                    }
                }
                return { length: index, maxLineLength };
            }

            // Depth texture
            let depthTexture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            console.log(`Mesh generated: ${positions.length/3} vertices, ${indices.length/3} triangles`);

            // Camera and controls
            const personHeight = 1.0;
            const turnSpeed = 0.03;
            const mouseSensitivity = 0.002;
            const orientationSmoothing = 0.35;
            let cameraPos = { x: startX, y: personHeight, z: startZ };
            let yaw = startYaw;
            let pitch = 0.0;
            let targetYaw = yaw;
            let targetPitch = pitch;
            const fov = Math.PI / 3;
            const moveSpeed = 0.1;
            const collisionRadius = 0.2;
            const keys = {};
            let mapArray = map;
            let mapVisible = false;
            let mapRelativeMode = false;
            let hudVisible = true;
            let texturesEnabled = false;
            let triangleMode = false;
            let debugMode = false;
            let horizontalMovement = true;
            let lastLoggedTextureState = false;

            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (!e.repeat) {
                    if (key === 'm') {
                        mapVisible = !mapVisible;
                    } else if (key === 'r') {
                        mapRelativeMode = !mapRelativeMode;
                    } else if (key === 't') {
                        texturesEnabled = !texturesEnabled;
                        console.log('[Texture] Textures toggled:', texturesEnabled ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'v') {
                        triangleMode = !triangleMode;
                        console.log('[Visualization] Triangle mode:', triangleMode ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'b') {
                        debugMode = !debugMode;
                        console.log('[Debug] Debug mode:', debugMode ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'h') {
                        hudVisible = !hudVisible;
                    } else if (key === 'f') {
                        horizontalMovement = !horizontalMovement;
                        if (horizontalMovement) {
                            cameraPos.y = personHeight;
                        }
                    }
                }
                keys[key] = true;
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function clampPitch(value) {
                return Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, value));
            }

            function onMouseMove(e) {
                targetYaw += e.movementX * mouseSensitivity;
                targetPitch = clampPitch(targetPitch - e.movementY * mouseSensitivity);
            }

            function isWalkable(x, z) {
                const minX = Math.floor(x - collisionRadius);
                const maxX = Math.floor(x + collisionRadius);
                const minZ = Math.floor(z - collisionRadius);
                const maxZ = Math.floor(z + collisionRadius);

                for (let tz = minZ; tz <= maxZ; tz++) {
                    if (tz < 0 || tz >= mapHeight) {
                        return false;
                    }
                    for (let tx = minX; tx <= maxX; tx++) {
                        if (tx < 0 || tx >= mapWidth || mapArray[tz][tx] !== 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function updateCamera() {
                const yawDeltaFromMouse = targetYaw - yaw;
                const pitchDeltaFromMouse = targetPitch - pitch;
                yaw += yawDeltaFromMouse * orientationSmoothing;
                pitch += pitchDeltaFromMouse * orientationSmoothing;

                let arrowUsed = false;
                let yawDelta = 0;
                if (keys['arrowleft']) {
                    yawDelta -= turnSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowright']) {
                    yawDelta += turnSpeed;
                    arrowUsed = true;
                }
                if (yawDelta !== 0) {
                    yaw += yawDelta;
                    targetYaw = yaw;
                }

                let arrowForward = 0;
                if (keys['arrowup']) {
                    arrowForward += moveSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowdown']) {
                    arrowForward -= moveSpeed;
                    arrowUsed = true;
                }

                if (arrowUsed) {
                    pitch = 0;
                    targetPitch = 0;
                }

                pitch = clampPitch(pitch);
                targetPitch = clampPitch(targetPitch);

                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);

                let dx = 0;
                let dy = 0;
                let dz = 0;

                let forwardX, forwardY, forwardZ;
                if (horizontalMovement) {
                    // Person movement: horizontal plane only
                    forwardX = cosYaw;
                    forwardY = 0;
                    forwardZ = sinYaw;
                } else {
                    // Flying mode: arbitrary direction
                    forwardX = cosPitch * cosYaw;
                    forwardY = sinPitch;
                    forwardZ = cosPitch * sinYaw;
                }
                if (keys['w']) {
                    dx += forwardX * moveSpeed;
                    dy += forwardY * moveSpeed;
                    dz += forwardZ * moveSpeed;
                }
                if (keys['s']) {
                    dx -= forwardX * moveSpeed;
                    dy -= forwardY * moveSpeed;
                    dz -= forwardZ * moveSpeed;
                }
                if (keys['a']) {
                    dx += sinYaw * moveSpeed;
                    dz -= cosYaw * moveSpeed;
                }
                if (keys['d']) {
                    dx -= sinYaw * moveSpeed;
                    dz += cosYaw * moveSpeed;
                }

                if (arrowForward !== 0) {
                    dx += cosYaw * arrowForward;
                    dz += sinYaw * arrowForward;
                }

                const baseY = arrowUsed ? personHeight : cameraPos.y;
                const newY = baseY + dy;
                const candidateX = cameraPos.x + dx;
                const candidateZ = cameraPos.z + dz;

                if (isWalkable(candidateX, cameraPos.z)) {
                    cameraPos.x = candidateX;
                }
                if (isWalkable(cameraPos.x, candidateZ)) {
                    cameraPos.z = candidateZ;
                }
                cameraPos.y = Math.min(Math.max(newY, 0.1), wallHeight - 0.1);
                if (arrowUsed) {
                    cameraPos.y = personHeight;
                }
            }

            // Render loop
            let frameCount = 0;
            let lastFrameTime = performance.now();
            let fps = 0;
            let fpsUpdateTime = performance.now();
            let fpsFrameCount = 0;

            // Performance timing
            let avgFrameTime = 0;
            let avgJsTime = 0;
            let avgGpuCopyTime = 0;
            let avgGpuRenderTime = 0;
            const PERF_SMOOTHING = 0.9; // Exponential moving average

            function render() {
                const frameStartTime = performance.now();

                updateCamera();

                // FPS calc
                const currentTime = performance.now();
                fpsFrameCount++;
                if (currentTime - fpsUpdateTime >= 500) {
                    fps = Math.round(fpsFrameCount * 1000 / (currentTime - fpsUpdateTime));
                    fpsFrameCount = 0;
                    fpsUpdateTime = currentTime;
                }

                // Update uniforms with individual floats
                const data = new Float32Array(uniformFloatCount);
                data[0] = cameraPos.x;       // cameraPosX
                data[1] = cameraPos.y;       // cameraPosY
                data[2] = cameraPos.z;       // cameraPosZ
                data[3] = yaw;
                data[4] = pitch;
                data[5] = fov;
                data[6] = canvas.width;      // viewWidth
                data[7] = canvas.height;     // viewHeight
                data[8] = texturesEnabled ? 1 : 0;
                data[9] = triangleMode ? 1 : 0; // showTriangles
                data[10] = debugMode ? 1 : 0; // debugMode
                data[11] = 0;

                if (texturesEnabled !== lastLoggedTextureState) {
                    console.log('[Texture] Uniform buffer useTextures value:', data[8]);
                    lastLoggedTextureState = texturesEnabled;
                }

                device.queue.writeBuffer(uniformBuffer, 0, data);

                const jsEndTime = performance.now();
                const jsTime = jsEndTime - frameStartTime;

                const directionNames = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
                const directionIndex = Math.round(((yaw / Math.PI * 4) + 8) % 8);
                const direction = directionNames[directionIndex];

                const lines = [
                    `FPS: ${fps}  Frame: ${avgFrameTime.toFixed(2)}ms`,
                    `JS: ${avgJsTime.toFixed(2)}ms  GPU Copy: ${avgGpuCopyTime.toFixed(2)}ms  GPU Render: ${avgGpuRenderTime.toFixed(2)}ms`,
                    `Pos: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})`,
                    `Dir: ${direction} (yaw: ${(yaw * 180 / Math.PI).toFixed(1)}°, pitch: ${(pitch * 180 / Math.PI).toFixed(1)}°)`,
                    `Movement: ${horizontalMovement ? 'Person' : 'Flying'} (f)  HUD: ${hudVisible ? 'ON' : 'OFF'} (h)  Map: ${mapVisible ? 'ON' : 'OFF'} (m/r)`,
                    `Textures: ${texturesEnabled ? 'ON' : 'OFF'} (t)  Triangles: ${triangleMode ? 'ON' : 'OFF'} (v)  Debug: ${debugMode ? 'ON' : 'OFF'} (b)`
                ];

                const { length: textLength, maxLineLength } = buildOverlayText(lines);
                const lineCount = lines.length;
                const charAdvance = GLYPH_WIDTH * TEXT_SCALE;
                const textWidth = maxLineLength * charAdvance;
                const textHeight = lineCount * GLYPH_HEIGHT * TEXT_SCALE + Math.max(0, (lineCount - 1)) * LINE_SPACING * TEXT_SCALE;
                const panelOriginX = PANEL_MARGIN;
                const panelOriginY = PANEL_MARGIN;
                const mapWidthPixels = mapWidth * MAP_SCALE;
                const mapHeightPixels = mapHeight * MAP_SCALE;
                let panelWidth = PANEL_PADDING_X * 2 + textWidth;
                if (mapVisible) {
                    panelWidth = Math.max(panelWidth, PANEL_PADDING_X * 2 + mapWidthPixels);
                }
                let panelHeight = PANEL_PADDING_Y * 2 + textHeight;
                const mapOriginX = panelOriginX + PANEL_PADDING_X;
                const mapOriginY = panelOriginY + PANEL_PADDING_Y + textHeight + (mapVisible ? MAP_GAP : 0);
                if (mapVisible) {
                    panelHeight += MAP_GAP + mapHeightPixels;
                }

                overlayParams[0] = canvas.width;
                overlayParams[1] = canvas.height;
                overlayParams[2] = panelOriginX;
                overlayParams[3] = panelOriginY;
                overlayParams[4] = panelWidth;
                overlayParams[5] = panelHeight;
                overlayParams[6] = TEXT_SCALE;
                overlayParams[7] = GLYPH_SPACING;
                overlayParams[8] = LINE_SPACING;
                overlayParams[9] = textLength;
                overlayParams[10] = PANEL_PADDING_X;
                overlayParams[11] = PANEL_PADDING_Y;
                overlayParams[12] = mapOriginX;
                overlayParams[13] = mapOriginY;
                overlayParams[14] = MAP_SCALE;
                overlayParams[15] = mapVisible ? 1 : 0;
                overlayParams[16] = mapRelativeMode ? 1 : 0;
                overlayParams[17] = mapWidth;
                overlayParams[18] = mapHeight;
                overlayParams[19] = 0;
                overlayParams[20] = cameraPos.x;
                overlayParams[21] = cameraPos.z;
                overlayParams[22] = yaw;
                overlayParams[23] = hudVisible ? 1 : 0;

                device.queue.writeBuffer(overlayUniformBuffer, 0, overlayParams);
                device.queue.writeBuffer(overlayTextBuffer, 0, overlayTextArray);

                const gpuCopyEndTime = performance.now();
                const gpuCopyTime = gpuCopyEndTime - jsEndTime;

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 }, // Sky blue clear
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store'
                    }
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, positionBuffer);
                renderPass.setVertexBuffer(1, uvBuffer);
                renderPass.setVertexBuffer(2, surfaceTypeBuffer);
                renderPass.setVertexBuffer(3, triangleIDBuffer);
                renderPass.setVertexBuffer(4, normalBuffer);
                renderPass.setIndexBuffer(indexBuffer, 'uint16');
                renderPass.drawIndexed(indices.length);

                renderPass.setPipeline(overlayPipeline);
                renderPass.setBindGroup(0, overlayBindGroup);
                renderPass.setVertexBuffer(0, overlayVertexBuffer);
                renderPass.draw(4);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                const gpuRenderEndTime = performance.now();
                const gpuRenderTime = gpuRenderEndTime - gpuCopyEndTime;
                const totalFrameTime = gpuRenderEndTime - frameStartTime;

                // Update smoothed averages
                avgFrameTime = avgFrameTime * PERF_SMOOTHING + totalFrameTime * (1 - PERF_SMOOTHING);
                avgJsTime = avgJsTime * PERF_SMOOTHING + jsTime * (1 - PERF_SMOOTHING);
                avgGpuCopyTime = avgGpuCopyTime * PERF_SMOOTHING + gpuCopyTime * (1 - PERF_SMOOTHING);
                avgGpuRenderTime = avgGpuRenderTime * PERF_SMOOTHING + gpuRenderTime * (1 - PERF_SMOOTHING);

                requestAnimationFrame(render);
            }

            render();

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Recreate depth texture
                depthTexture.destroy();
                depthTexture = device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
            });
        }

        init();
    </script>
</body>
</html>
