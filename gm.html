<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
        #textCanvas { pointer-events: none; z-index: 1; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="textCanvas"></canvas>
    <script type="module">
        async function init() {
            const canvas = document.getElementById('canvas');
            const textCanvas = document.getElementById('textCanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            textCanvas.width = window.innerWidth;
            textCanvas.height = window.innerHeight;

            const textCtx = textCanvas.getContext('2d');

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            // Map definition (1 = wall, 0 = floor, 5-8 = starting position with direction)
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,7,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,0,1,0,1,0,0,1],
                [1,0,1,0,1,1,0,0,1,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction
            let startX = 1.5, startZ = 1.5, startYaw = 0;
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    const cell = map[z][x];
                    if (cell >= 5 && cell <= 8) {
                        startX = x + 0.5;
                        startZ = z + 0.5;
                        if (cell === 5) startYaw = -Math.PI / 2;    // North
                        else if (cell === 6) startYaw = 0;          // East
                        else if (cell === 7) startYaw = Math.PI / 2; // South
                        else if (cell === 8) startYaw = Math.PI;    // West
                        map[z][x] = 0; // Clear the marker
                        console.log(`Starting at (${startX}, ${startZ}) facing ${cell===5?'North':cell===6?'East':cell===7?'South':'West'} with yaw=${startYaw}`);
                    }
                }
            }

            const wallHeight = 2.0;
            const checkerSize = 4.0; // For 4x4 checker per unit

            // Generate meshes
            const positions = [];
            const uvs = [];
            const surfaceTypes = []; // 0=floor, 1=wall, 2=ceiling
            const indices = [];
            let indexOffset = 0;

            // Floor: one big quad (matching collision coordinate system)
            const floorPositions = [
                0, 0, 0,  mapWidth, 0, 0,
                0, 0, mapHeight,  mapWidth, 0, mapHeight
            ];
            const floorUVs = [
                0, 0,  mapWidth * checkerSize, 0,
                0, mapHeight * checkerSize,  mapWidth * checkerSize, mapHeight * checkerSize
            ];
            positions.push(...floorPositions);
            uvs.push(...floorUVs);
            surfaceTypes.push(0, 0, 0, 0); // floor
            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
            indexOffset += 4;

            // Ceiling: similar but at wallHeight (matching collision coordinate system)
            const ceilingPositions = [
                0, wallHeight, 0,  mapWidth, wallHeight, 0,
                0, wallHeight, mapHeight,  mapWidth, wallHeight, mapHeight
            ];
            const ceilingUVs = floorUVs; // Same tiling
            positions.push(...ceilingPositions);
            uvs.push(...ceilingUVs);
            surfaceTypes.push(2, 2, 2, 2); // ceiling
            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
            indexOffset += 4;

            // Walls: generate quads for each boundary
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (map[z][x] === 1) {
                        // Check four directions for exposed faces
                        // North face (negative Z) - matching collision coordinate system
                        if (z === 0 || map[z - 1][x] === 0) {
                            const wallPositions = [
                                x, 0, z,  x + 1, 0, z,
                                x, wallHeight, z,  x + 1, wallHeight, z
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                        // South face (positive Z) - matching collision coordinate system
                        if (z === mapHeight - 1 || map[z + 1][x] === 0) {
                            const wallPositions = [
                                x, 0, z + 1,  x + 1, 0, z + 1,
                                x, wallHeight, z + 1,  x + 1, wallHeight, z + 1
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                        // West face (negative X) - matching collision coordinate system
                        if (x === 0 || map[z][x - 1] === 0) {
                            const wallPositions = [
                                x, 0, z,  x, 0, z + 1,
                                x, wallHeight, z,  x, wallHeight, z + 1
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                        // East face (positive X) - matching collision coordinate system
                        if (x === mapWidth - 1 || map[z][x + 1] === 0) {
                            const wallPositions = [
                                x + 1, 0, z,  x + 1, 0, z + 1,
                                x + 1, wallHeight, z,  x + 1, wallHeight, z + 1
                            ];
                            const wallUVs = [
                                0, 0,  1, 0,
                                0, wallHeight * checkerSize,  1, wallHeight * checkerSize
                            ];
                            positions.push(...wallPositions);
                            uvs.push(...wallUVs);
                            surfaceTypes.push(1, 1, 1, 1); // wall
                            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                            indexOffset += 4;
                        }
                    }
                }
            }

            // Buffers
            const positionBuffer = device.createBuffer({
                size: positions.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(positionBuffer.getMappedRange()).set(positions);
            positionBuffer.unmap();

            const uvBuffer = device.createBuffer({
                size: uvs.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(uvBuffer.getMappedRange()).set(uvs);
            uvBuffer.unmap();

            const surfaceTypeBuffer = device.createBuffer({
                size: surfaceTypes.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(surfaceTypeBuffer.getMappedRange()).set(surfaceTypes);
            surfaceTypeBuffer.unmap();

            const indexBuffer = device.createBuffer({
                size: indices.length * 2,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true
            });
            new Uint16Array(indexBuffer.getMappedRange()).set(indices);
            indexBuffer.unmap();

            // Uniform buffer - use individual floats to avoid vec/matrix alignment issues
            // Layout: cameraPosX, cameraPosY, cameraPosZ, yaw, pitch, fov, viewWidth, viewHeight
            const uniformBuffer = device.createBuffer({
                size: 32, // 8 floats * 4 bytes
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Shaders
            const vsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                };

                @vertex fn vs_main(
                    @location(0) position: vec3<f32>,
                    @location(1) uv: vec2<f32>,
                    @location(2) surfaceType: f32
                ) -> VertexOutput {
                    var output: VertexOutput;

                    // Transform to camera space
                    let cy = cos(u.yaw);
                    let sy = sin(u.yaw);
                    let cp = cos(u.pitch);
                    let sp = sin(u.pitch);

                    // Position relative to camera
                    let dx = position.x - u.cameraPosX;
                    let dy = position.y - u.cameraPosY;
                    let dz = position.z - u.cameraPosZ;

                    // Transform to view space
                    // Forward direction is (cos(yaw), 0, sin(yaw)) in world space
                    // Right direction is (-sin(yaw), 0, cos(yaw)) in world space
                    let viewX = -dx * sy + dz * cy;
                    let viewZ_noPitch = dx * cy + dz * sy;

                    // Rotate by pitch (around X axis in view space)
                    let viewY = dy * cp - viewZ_noPitch * sp;
                    let viewZ = dy * sp + viewZ_noPitch * cp;

                    // Calculate distance from camera for fog
                    let viewDist = sqrt(viewX * viewX + viewY * viewY + viewZ * viewZ);

                    // Perspective projection
                    let aspect = u.viewWidth / u.viewHeight;
                    let f = tan(u.fov * 0.5);
                    let near = 0.01;
                    let far = 100.0;

                    // Output clip-space coordinates (before perspective divide)
                    // Let GPU handle perspective divide by setting w = viewZ
                    let clipX = viewX / (f * aspect);
                    let clipY = viewY / f;
                    let clipZ = ((far + near) * viewZ - 2.0 * far * near) / (far - near);
                    let clipW = viewZ;

                    output.clipPos = vec4<f32>(clipX, clipY, clipZ, clipW);
                    output.worldPos = position;
                    output.surfaceType = surfaceType;
                    output.viewDist = viewDist;
                    return output;
                }
            `;

            const fsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;
                @group(0) @binding(1) var s: sampler;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                };

                @fragment fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
                    // Calculate perspective-correct UVs from world position
                    var texU: f32;
                    var texV: f32;

                    if (in.surfaceType > 1.5) {
                        // Ceiling (surfaceType = 2)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    } else if (in.surfaceType > 0.5) {
                        // Wall (surfaceType = 1)
                        // Determine orientation by measuring which axis is closest to an integer grid line
                        let fx = fract(in.worldPos.x);
                        let fz = fract(in.worldPos.z);
                        let distX = min(fx, 1.0 - fx);
                        let distZ = min(fz, 1.0 - fz);
                        if (distX < distZ) {
                            // East or West wall (plane perpendicular to X axis)
                            texU = fz;
                        } else {
                            // North or South wall (plane perpendicular to Z axis)
                            texU = fx;
                        }
                        texV = in.worldPos.y / 2.0; // wallHeight = 2.0
                    } else {
                        // Floor (surfaceType = 0)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    }

                    // Checkerboard pattern (4x4 per unit)
                    let checkerU = floor(texU * 4.0);
                    let checkerV = floor(texV * 4.0);
                    let checker = (i32(checkerU) + i32(checkerV)) & 1;
                    let checkerFactor = select(0.7, 1.0, checker == 0);

                    // Different colors based on surface type (matching g.html)
                    var baseColor: vec4<f32>;
                    if (in.surfaceType > 1.5) {
                        // Ceiling
                        baseColor = vec4<f32>(1.0, 1.0, 0.0, 1.0); // Yellow ceiling
                    } else if (in.surfaceType > 0.5) {
                        // Wall
                        baseColor = vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red walls
                    } else {
                        // Floor
                        baseColor = vec4<f32>(0.0, 0.0, 1.0, 1.0); // Blue floor
                    }

                    var color = baseColor * checkerFactor;

                    // Distance fog (exp2 like g.html)
                    let factor = exp2(-in.viewDist * 0.05);
                    color.r *= factor;
                    color.g *= factor;
                    color.b *= factor;

                    // Draw crosshair (like g.html)
                    let fragCoord = in.clipPos;
                    let centerX = u.viewWidth * 0.5;
                    let centerY = u.viewHeight * 0.5;
                    let crosshairSize = 10.0;
                    let crosshairThickness = 2.0;
                    let dx = abs(fragCoord.x - centerX);
                    let dy = abs(fragCoord.y - centerY);

                    if ((dx < crosshairThickness && dy < crosshairSize) ||
                        (dy < crosshairThickness && dx < crosshairSize)) {
                        // Crosshair color: white with black outline for visibility
                        if (dx < 1.0 || dy < 1.0) {
                            color = vec4<f32>(1.0, 1.0, 1.0, 1.0);
                        } else {
                            color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
                        }
                    }

                    return color;
                }
            `;

            const overlayVsSource = `
                struct VertexInput {
                    @location(0) position: vec2<f32>,
                };

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) frag_position: vec2<f32>,
                };

                @vertex
                fn vertex_main(input: VertexInput) -> VertexOutput {
                    var output: VertexOutput;
                    output.position = vec4<f32>(input.position, 0.0, 1.0);
                    output.frag_position = input.position * 0.5 + vec2<f32>(0.5, 0.5);
                    return output;
                }
            `;

            const overlayFsSource = `
                struct Params {
                    width: f32,
                    height: f32,
                    value: f32,
                    padding: f32,
                };

                @group(0) @binding(0)
                var<uniform> params: Params;

                struct FragIn {
                    @location(0) frag_position: vec2<f32>,
                };

                const font = array<u32, 5u>(
                    0xebfbe7fcu,
                    0xa89b21b4u,
                    0xa93fb9fcu,
                    0xaa1269a4u,
                    0xebf3f9e4u,
                );

                const max_number_length: u32 = 4u;

                fn number_to_digits(value: f32) -> array<u32, max_number_length> {
                    var digits = array<u32, max_number_length>(0u, 0u, 0u, 0u);
                    var num = clamp(floor(value + 0.5), 0.0, 9999.0);
                    var idx: u32 = max_number_length;
                    loop {
                        if (idx == 0u) { break; }
                        idx = idx - 1u;
                        digits[idx] = u32(num % 10.0);
                        num = floor(num / 10.0);
                        if (num == 0.0) { break; }
                    }
                    return digits;
                }

                fn digit_bit(digit: u32, column: u32, row: u32) -> bool {
                    let offset = digit * 3u;
                    let row_bits = (font[row] >> (29u - offset)) & 0x07u;
                    return ((row_bits >> (2u - column)) & 1u) == 1u;
                }

                @fragment
                fn fragment_main(fragData: FragIn) -> @location(0) vec4<f32> {
                    let screen = vec2<f32>(
                        fragData.frag_position.x * params.width,
                        (1.0 - fragData.frag_position.y) * params.height
                    );

                    let panelSize = vec2<f32>(200.0, 80.0);
                    let rectMin = vec2<f32>(10.0, params.height - panelSize.y - 10.0);
                    let rectMax = rectMin + panelSize;
                    var color = vec4<f32>(0.0, 0.0, 0.0, 0.0);

                    if (screen.x >= rectMin.x && screen.x <= rectMax.x && screen.y >= rectMin.y && screen.y <= rectMax.y) {
                        color = vec4<f32>(0.0, 1.0, 0.0, 0.4);

                        let digitsOrigin = rectMin + vec2<f32>(12.0, 12.0);
                        let local = screen - digitsOrigin;
                        if (local.x >= 0.0 && local.y >= 0.0) {
                            let digits = number_to_digits(params.value);
                            var first_non_zero: u32 = 0u;
                            loop {
                                if (first_non_zero >= max_number_length) { break; }
                                if (digits[first_non_zero] != 0u) { break; }
                                first_non_zero = first_non_zero + 1u;
                            }
                            if (first_non_zero >= max_number_length) {
                                first_non_zero = max_number_length - 1u;
                            }

                            let digitScale = 6.0;
                            let cellX = u32(floor(local.x / digitScale));
                            let cellY = u32(floor(local.y / digitScale));
                            if (cellY < 5u) {
                                let digitWidth: u32 = 3u;
                                let spacing: u32 = 1u;
                                let stride = digitWidth + spacing;
                                let digitIndex = cellX / stride;
                                if (digitIndex < max_number_length) {
                                    let column = cellX % stride;
                                    if (column < digitWidth) {
                                        let valueIndex = digitIndex;
                                        if (valueIndex < first_non_zero && digits[valueIndex] == 0u) {
                                            // Skip leading zeros
                                        } else if (digit_bit(digits[valueIndex], column, cellY)) {
                                            color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return color;
                }
            `;

            const vsModule = device.createShaderModule({ code: vsSource });
            const fsModule = device.createShaderModule({ code: fsSource });
            console.log('Shaders compiled successfully');

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
                ]
            });

            const overlayBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: {
                    module: vsModule,
                    entryPoint: 'vs_main',
                    buffers: [
                        {
                            arrayStride: 12, // vec3<f32>
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
                        },
                        {
                            arrayStride: 8, // vec2<f32>
                            attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }]
                        },
                        {
                            arrayStride: 4, // f32 surfaceType
                            attributes: [{ shaderLocation: 2, offset: 0, format: 'float32' }]
                        }
                    ]
                },
                fragment: {
                    module: fsModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: {
                    topology: 'triangle-list',
                    cullMode: 'none'  // No backface culling
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth24plus'
                }
            });

            const overlayVsModule = device.createShaderModule({ code: overlayVsSource });
            const overlayFsModule = device.createShaderModule({ code: overlayFsSource });

            const overlayPipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [overlayBindGroupLayout] }),
                vertex: {
                    module: overlayVsModule,
                    entryPoint: 'vertex_main',
                    buffers: [
                        {
                            arrayStride: 8,
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }]
                        }
                    ]
                },
                fragment: {
                    module: overlayFsModule,
                    entryPoint: 'fragment_main',
                    targets: [{
                        format,
                        blend: {
                            color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                            alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                        }
                    }]
                },
                primitive: {
                    topology: 'triangle-strip'
                },
                depthStencil: {
                    depthWriteEnabled: false,
                    depthCompare: 'always',
                    format: 'depth24plus'
                }
            });

            const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: sampler }
                ]
            });
            console.log('Pipeline and bind group created successfully');

            const overlayUniformBuffer = device.createBuffer({
                size: 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const overlayBindGroup = device.createBindGroup({
                layout: overlayBindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: overlayUniformBuffer } }
                ]
            });

            const overlayVertexData = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                 1,  1,
            ]);

            const overlayVertexBuffer = device.createBuffer({
                size: overlayVertexData.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(overlayVertexBuffer.getMappedRange()).set(overlayVertexData);
            overlayVertexBuffer.unmap();

            const overlayParams = new Float32Array(4);

            // Depth texture
            let depthTexture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            console.log(`Mesh generated: ${positions.length/3} vertices, ${indices.length/3} triangles`);

            // Camera and controls
            const personHeight = 1.0;
            const turnSpeed = 0.03;
            const mouseSensitivity = 0.004;
            const orientationSmoothing = 0.15;
            let cameraPos = { x: startX, y: personHeight, z: startZ };
            let yaw = startYaw;
            let pitch = 0.0;
            let targetYaw = yaw;
            let targetPitch = pitch;
            const fov = Math.PI / 3;
            const moveSpeed = 0.1;
            const collisionRadius = 0.2;
            const keys = {};
            let mapArray = map;

            document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function clampPitch(value) {
                return Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, value));
            }

            function onMouseMove(e) {
                targetYaw += e.movementX * mouseSensitivity;
                targetPitch = clampPitch(targetPitch - e.movementY * mouseSensitivity);
            }

            function isWalkable(x, z) {
                const minX = Math.floor(x - collisionRadius);
                const maxX = Math.floor(x + collisionRadius);
                const minZ = Math.floor(z - collisionRadius);
                const maxZ = Math.floor(z + collisionRadius);

                for (let tz = minZ; tz <= maxZ; tz++) {
                    if (tz < 0 || tz >= mapHeight) {
                        return false;
                    }
                    for (let tx = minX; tx <= maxX; tx++) {
                        if (tx < 0 || tx >= mapWidth || mapArray[tz][tx] !== 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function updateCamera() {
                const yawDeltaFromMouse = targetYaw - yaw;
                const pitchDeltaFromMouse = targetPitch - pitch;
                yaw += yawDeltaFromMouse * orientationSmoothing;
                pitch += pitchDeltaFromMouse * orientationSmoothing;

                let arrowUsed = false;
                let yawDelta = 0;
                if (keys['arrowleft']) {
                    yawDelta -= turnSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowright']) {
                    yawDelta += turnSpeed;
                    arrowUsed = true;
                }
                if (yawDelta !== 0) {
                    yaw += yawDelta;
                    targetYaw = yaw;
                }

                let arrowForward = 0;
                if (keys['arrowup']) {
                    arrowForward += moveSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowdown']) {
                    arrowForward -= moveSpeed;
                    arrowUsed = true;
                }

                if (arrowUsed) {
                    pitch = 0;
                    targetPitch = 0;
                }

                pitch = clampPitch(pitch);
                targetPitch = clampPitch(targetPitch);

                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);

                let dx = 0;
                let dy = 0;
                let dz = 0;

                const forwardX = cosPitch * cosYaw;
                const forwardY = sinPitch;
                const forwardZ = cosPitch * sinYaw;
                if (keys['w']) {
                    dx += forwardX * moveSpeed;
                    dy += forwardY * moveSpeed;
                    dz += forwardZ * moveSpeed;
                }
                if (keys['s']) {
                    dx -= forwardX * moveSpeed;
                    dy -= forwardY * moveSpeed;
                    dz -= forwardZ * moveSpeed;
                }
                if (keys['a']) {
                    dx += sinYaw * moveSpeed;
                    dz -= cosYaw * moveSpeed;
                }
                if (keys['d']) {
                    dx -= sinYaw * moveSpeed;
                    dz += cosYaw * moveSpeed;
                }

                if (arrowForward !== 0) {
                    dx += cosYaw * arrowForward;
                    dz += sinYaw * arrowForward;
                }

                const baseY = arrowUsed ? personHeight : cameraPos.y;
                const newY = baseY + dy;
                const candidateX = cameraPos.x + dx;
                const candidateZ = cameraPos.z + dz;

                if (isWalkable(candidateX, cameraPos.z)) {
                    cameraPos.x = candidateX;
                }
                if (isWalkable(cameraPos.x, candidateZ)) {
                    cameraPos.z = candidateZ;
                }
                cameraPos.y = Math.min(Math.max(newY, 0.1), wallHeight - 0.1);
                if (arrowUsed) {
                    cameraPos.y = personHeight;
                }
            }

            // Render loop
            let frameCount = 0;
            let lastFrameTime = performance.now();
            let fps = 0;
            let fpsUpdateTime = performance.now();
            let fpsFrameCount = 0;

            function render() {
                updateCamera();

                // FPS calc
                const currentTime = performance.now();
                fpsFrameCount++;
                if (currentTime - fpsUpdateTime >= 500) {
                    fps = Math.round(fpsFrameCount * 1000 / (currentTime - fpsUpdateTime));
                    fpsFrameCount = 0;
                    fpsUpdateTime = currentTime;
                }

                // Update uniforms with individual floats
                const data = new Float32Array(8);
                data[0] = cameraPos.x;       // cameraPosX
                data[1] = cameraPos.y;       // cameraPosY
                data[2] = cameraPos.z;       // cameraPosZ
                data[3] = yaw;
                data[4] = pitch;
                data[5] = fov;
                data[6] = canvas.width;      // viewWidth
                data[7] = canvas.height;     // viewHeight

                device.queue.writeBuffer(uniformBuffer, 0, data);

                overlayParams[0] = canvas.width;
                overlayParams[1] = canvas.height;
                overlayParams[2] = fps;
                overlayParams[3] = 0;
                device.queue.writeBuffer(overlayUniformBuffer, 0, overlayParams);

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 }, // Sky blue clear
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store'
                    }
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, positionBuffer);
                renderPass.setVertexBuffer(1, uvBuffer);
                renderPass.setVertexBuffer(2, surfaceTypeBuffer);
                renderPass.setIndexBuffer(indexBuffer, 'uint16');
                renderPass.drawIndexed(indices.length);

                renderPass.setPipeline(overlayPipeline);
                renderPass.setBindGroup(0, overlayBindGroup);
                renderPass.setVertexBuffer(0, overlayVertexBuffer);
                renderPass.draw(4);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                // Text overlay
                textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
                textCtx.font = '16px monospace';
                textCtx.fillStyle = 'white';
                textCtx.strokeStyle = 'black';
                textCtx.lineWidth = 3;

                const directionNames = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
                const directionIndex = Math.round(((yaw / Math.PI * 4) + 8) % 8);
                const direction = directionNames[directionIndex];

                const lines = [
                    `FPS: ${fps}`,
                    `Pos: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})`,
                    `Dir: ${direction} (yaw: ${(yaw * 180 / Math.PI).toFixed(1)}°, pitch: ${(pitch * 180 / Math.PI).toFixed(1)}°)`
                ];

                let y = 20;
                for (const line of lines) {
                    textCtx.strokeText(line, 10, y);
                    textCtx.fillText(line, 10, y);
                    y += 20;
                }

                requestAnimationFrame(render);
            }

            render();

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                textCanvas.width = window.innerWidth;
                textCanvas.height = window.innerHeight;
                // Recreate depth texture
                depthTexture.destroy();
                depthTexture = device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
            });
        }

        init();
    </script>
</body>
</html>
