<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">

        function createWasmWebGPUHost(adapter, device, canvas) {
            let memory = null;
            let nextHandle = 1;
            const decoder = new TextDecoder('utf-8');

            const context = canvas.getContext('webgpu');
            let depthTexture = null;

            const buffers = new Map();
            const shaderModules = new Map();
            const devices = new Map();
            const queues = new Map();
            const bindGroupLayouts = new Map();
            const pipelineLayouts = new Map();
            const renderPipelines = new Map();
            const bindGroups = new Map();
            const samplers = new Map();
            const textureViews = new Map();

            const GMResource = {
                BUFFER: 0,
                SAMPLER: 1,
                TEXTURE_VIEW: 2,
                STORAGE_TEXTURE: 3,
            };

            const bufferBindingTypeMap = new Map([
                [0x00000002, 'uniform'],
                [0x00000003, 'storage'],
                [0x00000004, 'read-only-storage'],
            ]);

            const samplerTypeMap = new Map([
                [0x00000002, 'filtering'],
                [0x00000003, 'non-filtering'],
                [0x00000004, 'comparison'],
            ]);

            const textureSampleTypeMap = new Map([
                [0x00000002, 'float'],
                [0x00000003, 'unfilterable-float'],
                [0x00000004, 'depth'],
                [0x00000005, 'sint'],
                [0x00000006, 'uint'],
            ]);

            const textureViewDimensionMap = new Map([
                [0x00000001, '1d'],
                [0x00000002, '2d'],
                [0x00000003, '2d-array'],
                [0x00000004, 'cube'],
                [0x00000005, 'cube-array'],
                [0x00000006, '3d'],
            ]);

            const vertexFormatMap = new Map([
                [0x0000001C, 'float32'],
                [0x0000001D, 'float32x2'],
                [0x0000001E, 'float32x3'],
                [0x0000001F, 'float32x4'],
            ]);

            const vertexStepModeMap = new Map([
                [0x00000001, 'vertex'],
                [0x00000002, 'instance'],
            ]);

            const primitiveTopologyMap = new Map([
                [0x00000004, 'triangle-list'],
                [0x00000005, 'triangle-strip'],
                [0x00000001, 'point-list'],
                [0x00000002, 'line-list'],
                [0x00000003, 'line-strip'],
            ]);

            const cullModeMap = new Map([
                [0x00000001, 'none'],
                [0x00000002, 'front'],
                [0x00000003, 'back'],
            ]);

            const frontFaceMap = new Map([
                [0x00000001, 'ccw'],
                [0x00000002, 'cw'],
            ]);

            const compareFunctionMap = new Map([
                [0x00000002, 'less'],
                [0x00000008, 'always'],
                [0x00000004, 'less-equal'],
                [0x00000005, 'greater'],
            ]);

            const filterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const mipmapFilterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const addressModeMap = new Map([
                [0x00000001, 'clamp-to-edge'],
                [0x00000002, 'repeat'],
                [0x00000003, 'mirror-repeat'],
            ]);

            const blendFactorMap = new Map([
                [0x00000001, 'zero'],
                [0x00000002, 'one'],
                [0x00000005, 'src-alpha'],
                [0x00000006, 'one-minus-src-alpha'],
                [0x00000009, 'dst-alpha'],
                [0x0000000A, 'one-minus-dst-alpha'],
            ]);

            const blendOperationMap = new Map([
                [0x00000001, 'add'],
                [0x00000002, 'subtract'],
                [0x00000003, 'reverse-subtract'],
                [0x00000004, 'min'],
                [0x00000005, 'max'],
            ]);

            // Texture format mapping for use within this function
            const textureFormatToEnum = {
                'rgba8unorm': 0x00000016,
                'rgba8unorm-srgb': 0x00000017,
                'bgra8unorm': 0x0000001B,
                'bgra8unorm-srgb': 0x0000001C,
            };

            const textureFormatFromEnumLocal = {
                0x00000016: 'rgba8unorm',
                0x00000017: 'rgba8unorm-srgb',
                0x0000001B: 'bgra8unorm',
                0x0000001C: 'bgra8unorm-srgb',
                0x0000002C: 'stencil8',
                0x0000002D: 'depth16unorm',
                0x0000002E: 'depth24plus',
                0x0000002F: 'depth24plus-stencil8',
                0x00000030: 'depth32float',
                0x00000031: 'depth32float-stencil8',
            };

            function textureFormatFromEnum(value) {
                return textureFormatFromEnumLocal[value] ?? 'bgra8unorm';
            }

            const deviceHandle = nextHandle++;
            devices.set(deviceHandle, device);
            const queueHandle = nextHandle++;
            queues.set(queueHandle, device.queue);

            function requireMemory() {
                if (!memory) {
                    throw new Error('WebGPU memory not registered');
                }
            }

            function readString(ptr, length) {
                if (!ptr || length === 0) {
                    return '';
                }
                const bytes = new Uint8Array(memory.buffer, ptr, length);
                return decoder.decode(bytes);
            }

            function mapOrDefault(map, key, fallback) {
                return map.get(key) ?? fallback;
            }

            function readBindGroupLayoutEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 56;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const visibility = dv.getUint32(base + 4, true);
                    const resourceType = dv.getUint32(base + 8, true);
                    const bufferType = dv.getUint32(base + 12, true);
                    const hasDynamicOffset = !!dv.getUint32(base + 16, true);
                    const minBindingSize = Number(dv.getBigUint64(base + 20, true));
                    const samplerType = dv.getUint32(base + 28, true);
                    const textureSampleType = dv.getUint32(base + 32, true);
                    const textureViewDim = dv.getUint32(base + 36, true);
                    const textureMultisampled = !!dv.getUint32(base + 40, true);
                    const storageAccess = dv.getUint32(base + 44, true);
                    const storageFormat = dv.getUint32(base + 48, true);
                    const storageViewDim = dv.getUint32(base + 52, true);

                    const entry = { binding, visibility };
                    if (resourceType === GMResource.BUFFER) {
                        entry.buffer = {
                            type: mapOrDefault(bufferBindingTypeMap, bufferType, 'uniform'),
                            hasDynamicOffset,
                            minBindingSize,
                        };
                    } else if (resourceType === GMResource.SAMPLER) {
                        entry.sampler = {
                            type: mapOrDefault(samplerTypeMap, samplerType, 'filtering'),
                        };
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        entry.texture = {
                            sampleType: mapOrDefault(textureSampleTypeMap, textureSampleType, 'float'),
                            viewDimension: mapOrDefault(textureViewDimensionMap, textureViewDim, '2d'),
                            multisampled: textureMultisampled,
                        };
                    } else if (resourceType === GMResource.STORAGE_TEXTURE) {
                        entry.storageTexture = {
                            access: storageAccess === 0x00000003 ? 'read-only' : 'write-only',
                            format: textureFormatFromEnum(storageFormat),
                            viewDimension: mapOrDefault(textureViewDimensionMap, storageViewDim, '2d'),
                        };
                    }
                    entries.push(entry);
                }
                return entries;
            }

            function readBindGroupEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 28;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const resourceType = dv.getUint32(base + 4, true);
                    const handle = dv.getUint32(base + 8, true);
                    const offset = Number(dv.getBigUint64(base + 12, true));
                    const rawSize = dv.getBigUint64(base + 20, true);
                    const size = rawSize === 0xFFFFFFFFFFFFFFFFn ? undefined : Number(rawSize);

                    if (resourceType === GMResource.BUFFER) {
                        const buffer = buffers.get(handle);
                        if (!buffer) {
                            throw new Error(`Unknown buffer handle ${handle}`);
                        }
                        const resource = { buffer, offset };
                        if (size !== undefined) {
                            resource.size = size;
                        }
                        entries.push({
                            binding,
                            resource,
                        });
                    } else if (resourceType === GMResource.SAMPLER) {
                        const sampler = samplers.get(handle);
                        if (!sampler) {
                            throw new Error(`Unknown sampler handle ${handle}`);
                        }
                        entries.push({ binding, resource: sampler });
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        const view = textureViews.get(handle);
                        if (!view) {
                            throw new Error(`Unknown texture view handle ${handle}`);
                        }
                        entries.push({ binding, resource: view });
                    } else {
                        throw new Error(`Unsupported bind group resource type ${resourceType}`);
                    }
                }
                return entries;
            }

            function readProgrammableStage(ptr) {
                if (!ptr) {
                    return null;
                }
                const dv = new DataView(memory.buffer);
                const moduleHandle = dv.getUint32(ptr, true);
                const entryPtr = dv.getUint32(ptr + 4, true);
                const entryLength = dv.getUint32(ptr + 8, true);
                const module = shaderModules.get(moduleHandle);
                if (!module) {
                    throw new Error(`Unknown shader module handle ${moduleHandle}`);
                }
                const entryPoint = readString(entryPtr, entryLength) || 'main';
                return { module, entryPoint };
            }

            function readVertexBuffers(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const buffersOut = [];
                const dv = new DataView(memory.buffer);
                const stride = 16;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const arrayStride = dv.getUint32(base, true);
                    const stepModeValue = dv.getUint32(base + 4, true);
                    const attributeCount = dv.getUint32(base + 8, true);
                    const attributesPtr = dv.getUint32(base + 12, true);
                    const attributes = [];
                    const attrStride = 12;
                    for (let j = 0; j < attributeCount; j++) {
                        const attrBase = attributesPtr + j * attrStride;
                        const shaderLocation = dv.getUint32(attrBase, true);
                        const offset = dv.getUint32(attrBase + 4, true);
                        const formatValue = dv.getUint32(attrBase + 8, true);
                        attributes.push({
                            shaderLocation,
                            offset,
                            format: mapOrDefault(vertexFormatMap, formatValue, 'float32'),
                        });
                    }
                    buffersOut.push({
                        arrayStride,
                        stepMode: mapOrDefault(vertexStepModeMap, stepModeValue, 'vertex'),
                        attributes,
                    });
                }
                return buffersOut;
            }

            function readVertexState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const bufferCount = dv.getUint32(ptr + 4, true);
                const buffersPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    buffers: readVertexBuffers(buffersPtr, bufferCount),
                };
            }

            function readColorTargets(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const targets = [];
                const dv = new DataView(memory.buffer);
                const stride = 36;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const format = textureFormatFromEnum(dv.getUint32(base, true));
                    const blendEnabled = !!dv.getUint32(base + 4, true);
                    const colorSrc = dv.getUint32(base + 8, true);
                    const colorDst = dv.getUint32(base + 12, true);
                    const colorOp = dv.getUint32(base + 16, true);
                    const alphaSrc = dv.getUint32(base + 20, true);
                    const alphaDst = dv.getUint32(base + 24, true);
                    const alphaOp = dv.getUint32(base + 28, true);
                    const writeMask = dv.getUint32(base + 32, true);
                    const target = { format, writeMask };
                    if (blendEnabled) {
                        target.blend = {
                            color: {
                                srcFactor: mapOrDefault(blendFactorMap, colorSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, colorDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, colorOp, 'add'),
                            },
                            alpha: {
                                srcFactor: mapOrDefault(blendFactorMap, alphaSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, alphaDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, alphaOp, 'add'),
                            },
                        };
                    }
                    targets.push(target);
                }
                return targets;
            }

            function readFragmentState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const targetCount = dv.getUint32(ptr + 4, true);
                const targetsPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    targets: readColorTargets(targetsPtr, targetCount),
                };
            }

            function readPrimitiveState(ptr) {
                const dv = new DataView(memory.buffer);
                const topology = mapOrDefault(primitiveTopologyMap, dv.getUint32(ptr, true), 'triangle-list');
                const cullMode = mapOrDefault(cullModeMap, dv.getUint32(ptr + 4, true), 'none');
                const frontFace = mapOrDefault(frontFaceMap, dv.getUint32(ptr + 8, true), 'ccw');
                const stripIndexFormat = dv.getUint32(ptr + 12, true);
                const primitive = { topology, cullMode, frontFace };
                if (stripIndexFormat === 0x00000001) {
                    primitive.stripIndexFormat = 'uint16';
                } else if (stripIndexFormat === 0x00000002) {
                    primitive.stripIndexFormat = 'uint32';
                }
                return primitive;
            }

            function readDepthStencilState(ptr) {
                const dv = new DataView(memory.buffer);
                const format = textureFormatFromEnum(dv.getUint32(ptr, true));
                const depthWriteEnabled = !!dv.getUint32(ptr + 4, true);
                const depthCompare = mapOrDefault(compareFunctionMap, dv.getUint32(ptr + 8, true), 'less');
                return { format, depthWriteEnabled, depthCompare };
            }

            const commandEncoders = new Map();
            const renderPassEncoders = new Map();
            const commandBuffers = new Map();

            const imports = {
                create_instance() {
                    return 1;
                },
                surface_get_preferred_format() {
                    const preferred = navigator.gpu.getPreferredCanvasFormat();
                    const value = textureFormatToEnum[preferred] ?? 0x0000001B;
                    console.log('[WebGPU] Preferred canvas format (JS):', preferred, '-> enum', value);
                    return value;
                },
                device_create_buffer(deviceHandleParam, sizeLow, sizeHigh, usage, mapped) {
                    const targetDevice = devices.get(deviceHandleParam);
                    const size = sizeLow + sizeHigh * 4294967296;
                    const buffer = targetDevice.createBuffer({
                        size,
                        usage,
                        mappedAtCreation: !!mapped,
                    });
                    const handle = nextHandle++;
                    buffers.set(handle, buffer);
                    return handle;
                },
                queue_write_buffer(queueHandleParam, bufferHandle, offsetLow, offsetHigh, dataPtr, size) {
                    requireMemory();
                    const queue = queues.get(queueHandleParam);
                    const buffer = buffers.get(bufferHandle);
                    const offset = offsetLow + offsetHigh * 4294967296;
                    const source = new Uint8Array(memory.buffer, dataPtr, size);
                    queue.writeBuffer(buffer, offset, source);
                },
                device_create_shader_module(deviceHandleParam, codePtr, codeLength) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const bytes = new Uint8Array(memory.buffer, codePtr, codeLength);
                    const code = decoder.decode(bytes);
                    const module = targetDevice.createShaderModule({ code });
                    const handle = nextHandle++;
                    shaderModules.set(handle, module);
                    return handle;
                },
                device_create_bind_group_layout(deviceHandleParam, entriesPtr, entryCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const entries = readBindGroupLayoutEntries(entriesPtr, entryCount);
                    const layout = targetDevice.createBindGroupLayout({ entries });
                    const handle = nextHandle++;
                    bindGroupLayouts.set(handle, layout);
                    return handle;
                },
                device_create_pipeline_layout(deviceHandleParam, layoutsPtr, layoutCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const handles = new Uint32Array(memory.buffer, layoutsPtr, layoutCount);
                    const layouts = [];
                    for (let i = 0; i < handles.length; i++) {
                        const layout = bindGroupLayouts.get(handles[i]);
                        if (!layout) {
                            throw new Error(`Unknown bind group layout handle ${handles[i]}`);
                        }
                        layouts.push(layout);
                    }
                    const pipelineLayout = targetDevice.createPipelineLayout({ bindGroupLayouts: layouts });
                    const handle = nextHandle++;
                    pipelineLayouts.set(handle, pipelineLayout);
                    return handle;
                },
                device_create_sampler(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const base = descriptorPtr;
                    const desc = {
                        magFilter: mapOrDefault(filterModeMap, dv.getUint32(base, true), 'nearest'),
                        minFilter: mapOrDefault(filterModeMap, dv.getUint32(base + 4, true), 'nearest'),
                        mipmapFilter: mapOrDefault(mipmapFilterModeMap, dv.getUint32(base + 8, true), 'nearest'),
                        addressModeU: mapOrDefault(addressModeMap, dv.getUint32(base + 12, true), 'clamp-to-edge'),
                        addressModeV: mapOrDefault(addressModeMap, dv.getUint32(base + 16, true), 'clamp-to-edge'),
                        addressModeW: mapOrDefault(addressModeMap, dv.getUint32(base + 20, true), 'clamp-to-edge'),
                        lodMinClamp: dv.getFloat32(base + 24, true),
                        lodMaxClamp: dv.getFloat32(base + 28, true),
                    };
                    const compareValue = dv.getUint32(base + 32, true);
                    if (compareValue !== 0) {
                        desc.compare = mapOrDefault(compareFunctionMap, compareValue, 'less');
                    }
                    const sampler = targetDevice.createSampler(desc);
                    const handle = nextHandle++;
                    samplers.set(handle, sampler);
                    return handle;
                },
                device_create_bind_group(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const entryCount = dv.getUint32(descriptorPtr + 4, true);
                    const entriesPtr = dv.getUint32(descriptorPtr + 8, true);
                    const layout = bindGroupLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown bind group layout handle ${layoutHandle}`);
                    }
                    const entries = readBindGroupEntries(entriesPtr, entryCount);
                    const bindGroup = targetDevice.createBindGroup({ layout, entries });
                    const handle = nextHandle++;
                    bindGroups.set(handle, bindGroup);
                    return handle;
                },
                device_create_render_pipeline(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const vertexStatePtr = dv.getUint32(descriptorPtr + 4, true);
                    const fragmentStatePtr = dv.getUint32(descriptorPtr + 8, true);
                    const primitiveStatePtr = dv.getUint32(descriptorPtr + 12, true);
                    const depthStatePtr = dv.getUint32(descriptorPtr + 16, true);
                    const sampleCount = dv.getUint32(descriptorPtr + 20, true);
                    const alphaToCoverage = !!dv.getUint32(descriptorPtr + 24, true);

                    const layout = pipelineLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown pipeline layout handle ${layoutHandle}`);
                    }

                    const descriptor = {
                        layout,
                        vertex: readVertexState(vertexStatePtr),
                        primitive: readPrimitiveState(primitiveStatePtr),
                        multisample: {
                            count: sampleCount || 1,
                            mask: 0xFFFFFFFF,
                            alphaToCoverageEnabled: alphaToCoverage,
                        },
                    };

                    if (fragmentStatePtr !== 0) {
                        descriptor.fragment = readFragmentState(fragmentStatePtr);
                    }
                    if (depthStatePtr !== 0) {
                        descriptor.depthStencil = readDepthStencilState(depthStatePtr);
                    }

                    const pipeline = targetDevice.createRenderPipeline(descriptor);
                    const handle = nextHandle++;
                    renderPipelines.set(handle, pipeline);
                    return handle;
                },
                device_create_command_encoder(deviceHandleParam) {
                    const targetDevice = devices.get(deviceHandleParam);
                    const encoder = targetDevice.createCommandEncoder();
                    const handle = nextHandle++;
                    commandEncoders.set(handle, encoder);
                    return handle;
                },
                command_encoder_begin_render_pass(encoderHandle, descriptorPtr) {
                    requireMemory();
                    const encoder = commandEncoders.get(encoderHandle);
                    const dv = new DataView(memory.buffer);
                    const colorAttachmentPtr = dv.getUint32(descriptorPtr, true);
                    const colorAttachmentCount = dv.getUint32(descriptorPtr + 4, true);
                    const depthStencilPtr = dv.getUint32(descriptorPtr + 8, true);

                    const colorAttachments = [];
                    const colorStride = 28;
                    for (let i = 0; i < colorAttachmentCount; i++) {
                        const base = colorAttachmentPtr + i * colorStride;
                        const viewHandle = dv.getUint32(base, true);
                        const loadOp = dv.getUint32(base + 4, true);
                        const storeOp = dv.getUint32(base + 8, true);
                        const clearR = dv.getFloat32(base + 12, true);
                        const clearG = dv.getFloat32(base + 16, true);
                        const clearB = dv.getFloat32(base + 20, true);
                        const clearA = dv.getFloat32(base + 24, true);

                        const view = textureViews.get(viewHandle);
                        if (!view) {
                            throw new Error(`Unknown texture view handle ${viewHandle}`);
                        }

                        colorAttachments.push({
                            view,
                            loadOp: loadOp === 0x00000001 ? 'load' : 'clear',
                            storeOp: storeOp === 0x00000001 ? 'store' : 'discard',
                            clearValue: { r: clearR, g: clearG, b: clearB, a: clearA },
                        });
                    }

                    const descriptor = { colorAttachments };

                    if (depthStencilPtr !== 0) {
                        const viewHandle = dv.getUint32(depthStencilPtr, true);
                        const depthLoadOp = dv.getUint32(depthStencilPtr + 4, true);
                        const depthStoreOp = dv.getUint32(depthStencilPtr + 8, true);
                        const depthClearValue = dv.getFloat32(depthStencilPtr + 12, true);

                        const view = textureViews.get(viewHandle);
                        if (!view) {
                            throw new Error(`Unknown depth texture view handle ${viewHandle}`);
                        }

                        descriptor.depthStencilAttachment = {
                            view,
                            depthLoadOp: depthLoadOp === 0x00000001 ? 'load' : 'clear',
                            depthStoreOp: depthStoreOp === 0x00000001 ? 'store' : 'discard',
                            depthClearValue,
                        };
                    }

                    const pass = encoder.beginRenderPass(descriptor);
                    const handle = nextHandle++;
                    renderPassEncoders.set(handle, pass);
                    return handle;
                },
                render_pass_set_pipeline(passHandle, pipelineHandle) {
                    const pass = renderPassEncoders.get(passHandle);
                    const pipeline = renderPipelines.get(pipelineHandle);
                    if (!pass || !pipeline) {
                        throw new Error('Invalid pass or pipeline handle');
                    }
                    pass.setPipeline(pipeline);
                },
                render_pass_set_bind_group(passHandle, groupIndex, bindGroupHandle) {
                    const pass = renderPassEncoders.get(passHandle);
                    const bindGroup = bindGroups.get(bindGroupHandle);
                    if (!pass || !bindGroup) {
                        throw new Error('Invalid pass or bind group handle');
                    }
                    pass.setBindGroup(groupIndex, bindGroup);
                },
                render_pass_set_vertex_buffer(passHandle, slot, bufferHandle) {
                    const pass = renderPassEncoders.get(passHandle);
                    const buffer = buffers.get(bufferHandle);
                    if (!pass || !buffer) {
                        throw new Error('Invalid pass or buffer handle');
                    }
                    pass.setVertexBuffer(slot, buffer);
                },
                render_pass_set_index_buffer(passHandle, bufferHandle, format) {
                    const pass = renderPassEncoders.get(passHandle);
                    const buffer = buffers.get(bufferHandle);
                    if (!pass || !buffer) {
                        throw new Error('Invalid pass or buffer handle');
                    }
                    const indexFormat = format === 0x00000001 ? 'uint16' : 'uint32';
                    pass.setIndexBuffer(buffer, indexFormat);
                },
                render_pass_draw_indexed(passHandle, indexCount) {
                    const pass = renderPassEncoders.get(passHandle);
                    if (!pass) {
                        throw new Error('Invalid pass handle');
                    }
                    pass.drawIndexed(indexCount);
                },
                render_pass_draw(passHandle, vertexCount) {
                    const pass = renderPassEncoders.get(passHandle);
                    if (!pass) {
                        throw new Error('Invalid pass handle');
                    }
                    pass.draw(vertexCount);
                },
                render_pass_end(passHandle) {
                    const pass = renderPassEncoders.get(passHandle);
                    if (!pass) {
                        throw new Error('Invalid pass handle');
                    }
                    pass.end();
                    renderPassEncoders.delete(passHandle);
                },
                command_encoder_finish(encoderHandle) {
                    const encoder = commandEncoders.get(encoderHandle);
                    if (!encoder) {
                        throw new Error('Invalid encoder handle');
                    }
                    const commandBuffer = encoder.finish();
                    const handle = nextHandle++;
                    commandBuffers.set(handle, commandBuffer);
                    commandEncoders.delete(encoderHandle);
                    return handle;
                },
                queue_submit(queueHandleParam, commandBufferHandle) {
                    const queue = queues.get(queueHandleParam);
                    const commandBuffer = commandBuffers.get(commandBufferHandle);
                    if (!queue || !commandBuffer) {
                        throw new Error('Invalid queue or command buffer handle');
                    }
                    queue.submit([commandBuffer]);
                    commandBuffers.delete(commandBufferHandle);
                },
                context_get_current_texture_view() {
                    const textureView = context.getCurrentTexture().createView();
                    const handle = nextHandle++;
                    textureViews.set(handle, textureView);
                    return handle;
                },
                get_depth_texture_view(width, height) {
                    if (depthTexture && (depthTexture.width !== width || depthTexture.height !== height)) {
                        depthTexture.destroy();
                        depthTexture = null;
                    }
                    if (!depthTexture) {
                        depthTexture = device.createTexture({
                            size: [width, height, 1],
                            format: 'depth24plus',
                            usage: GPUTextureUsage.RENDER_ATTACHMENT,
                        });
                    }
                    const view = depthTexture.createView();
                    const handle = nextHandle++;
                    textureViews.set(handle, view);
                    return handle;
                },
            };

            return {
                imports,
                setMemory(mem) {
                    memory = mem;
                },
                handles: {
                    device: deviceHandle,
                    queue: queueHandle,
                },
                getBuffer(handle) {
                    return buffers.get(handle);
                },
                getShaderModule(handle) {
                    return shaderModules.get(handle);
                },
                getBindGroup(handle) {
                    return bindGroups.get(handle);
                },
                getRenderPipeline(handle) {
                    return renderPipelines.get(handle);
                },
                registerTextureView(view) {
                    const handle = nextHandle++;
                    textureViews.set(handle, view);
                    return handle;
                },
                configureContext(format) {
                    context.configure({
                        device,
                        format,
                        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
                    });
                },
                createDepthTexture(width, height) {
                    if (depthTexture) {
                        depthTexture.destroy();
                    }
                    depthTexture = device.createTexture({
                        size: [width, height, 1],
                        format: 'depth24plus',
                        usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                },
            };
        }

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Add error handling
            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            function createSolidTexture(device, rgba, label) {
                const texture = device.createTexture({
                    label,
                    size: [1, 1, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                });
                const data = new Uint8Array(rgba);
                device.queue.writeTexture({ texture }, data, { bytesPerRow: 4 }, [1, 1, 1]);
                return texture.createView();
            }

            async function createTextureFromUrl(device, url, label) {
                console.log(`[Texture] Starting to load ${label} from ${url}`);
                try {
                    const response = await fetch(url, { mode: 'cors' });
                    console.log(`[Texture] Fetched ${label}, status: ${response.status}`);
                    const blob = await response.blob();
                    console.log(`[Texture] Blob size for ${label}: ${blob.size} bytes`);
                    const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    console.log(`[Texture] ImageBitmap created for ${label}: ${imageBitmap.width}x${imageBitmap.height}`);
                    const texture = device.createTexture({
                        label,
                        size: [imageBitmap.width, imageBitmap.height, 1],
                        format: 'rgba8unorm',
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                    console.log(`[Texture] Texture created for ${label}`);
                    device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture },
                        [imageBitmap.width, imageBitmap.height]
                    );
                    console.log(`[Texture] Data copied to texture for ${label}`);
                    const view = texture.createView();
                    console.log(`[Texture] Successfully loaded ${label}`);
                    return view;
                } catch (err) {
                    console.warn(`[Texture] ERROR loading ${label}:`, err);
                    console.warn(`Falling back to solid texture for ${label}`);
                    return createSolidTexture(device, [255, 255, 255, 255], `${label}-fallback`);
                }
            }

            // Load WASM module (with cache busting)
            const wasmResponse = await fetch('gm.wasm?v=' + Date.now());
            const wasmBytes = await wasmResponse.arrayBuffer();
            const webgpuHost = createWasmWebGPUHost(adapter, device, canvas);

            const textureFormatEnum = {
                'rgba8unorm': 0x00000016,
                'rgba8unorm-srgb': 0x00000017,
                'bgra8unorm': 0x0000001B,
                'bgra8unorm-srgb': 0x0000001C,
            };

            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const preferredFormatEnum = textureFormatEnum[canvasFormat] ?? textureFormatEnum['bgra8unorm'];

            webgpuHost.configureContext(canvasFormat);
            webgpuHost.createDepthTexture(canvas.width, canvas.height);

            const defaultTextures = {
                wall: 'https://threejs.org/examples/textures/brick_diffuse.jpg',
                floor: 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg',
                ceiling: 'https://threejs.org/examples/textures/lava/cloud.png',
            };

            const [wallTextureView, floorTextureView, ceilingTextureView] = await Promise.all([
                createTextureFromUrl(device, defaultTextures.wall, 'wall-texture'),
                createTextureFromUrl(device, defaultTextures.floor, 'floor-texture'),
                createTextureFromUrl(device, defaultTextures.ceiling, 'ceiling-texture'),
            ]);

            const hostConfigHandles = {
                device: webgpuHost.handles.device,
                queue: webgpuHost.handles.queue,
                wallTexture: webgpuHost.registerTextureView(wallTextureView),
                floorTexture: webgpuHost.registerTextureView(floorTextureView),
                ceilingTexture: webgpuHost.registerTextureView(ceilingTextureView),
                preferredFormat: preferredFormatEnum,
            };
            let hostConfigReady = true;


            const keyStates = new Uint8Array(256);
            let mouseDeltaX = 0;
            let mouseDeltaY = 0;

            document.addEventListener('keydown', (event) => {
                let code = event.keyCode;
                // Convert uppercase letters (A-Z: 65-90) to lowercase (a-z: 97-122)
                if (code >= 65 && code <= 90) {
                    code = code + 32;
                }
                if (code >= 0 && code < 256) {
                    keyStates[code] = 1;
                    event.preventDefault();
                }
            });

            document.addEventListener('keyup', (event) => {
                let code = event.keyCode;
                // Convert uppercase letters (A-Z: 65-90) to lowercase (a-z: 97-122)
                if (code >= 65 && code <= 90) {
                    code = code + 32;
                }
                if (code >= 0 && code < 256) {
                    keyStates[code] = 0;
                    event.preventDefault();
                }
            });

            canvas.addEventListener('click', () => canvas.requestPointerLock());

            function onMouseMove(event) {
                mouseDeltaX += event.movementX;
                mouseDeltaY += event.movementY;
            }

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            let memory = null;
            let lastResizeId = 0;

            // Texture request tracking
            const textureLoadRequests = new Map();
            let nextTextureRequestId = 1;

            const platformAPI = {
                get_canvas_size: (widthPtr, heightPtr) => {
                    const view = new Int32Array(memory.buffer);
                    view[widthPtr / 4] = canvas.width;
                    view[heightPtr / 4] = canvas.height;
                },
                get_time: () => performance.now(),
                get_resize_flag: () => lastResizeId,
                get_visibility: () => document.visibilityState === 'visible' ? 1 : 0,
                get_host_config: (configPtr) => {
                    if (!hostConfigReady) {
                        return 0;
                    }
                    const view = new DataView(memory.buffer, configPtr, 24);
                    view.setUint32(0, hostConfigHandles.device, true);
                    view.setUint32(4, hostConfigHandles.queue, true);
                    view.setUint32(8, hostConfigHandles.wallTexture, true);
                    view.setUint32(12, hostConfigHandles.floorTexture, true);
                    view.setUint32(16, hostConfigHandles.ceilingTexture, true);
                    view.setUint32(20, hostConfigHandles.preferredFormat, true);
                    return 1;
                },
                get_input_state: (snapshotPtr) => {
                    const keysView = new Uint8Array(memory.buffer, snapshotPtr, 256);
                    keysView.set(keyStates);
                    const dv = new DataView(memory.buffer, snapshotPtr + 256, 8);
                    dv.setFloat32(0, mouseDeltaX, true);
                    dv.setFloat32(4, mouseDeltaY, true);
                    mouseDeltaX = 0;
                    mouseDeltaY = 0;
                },
                request_texture_load: (urlPtr, urlLen) => {
                    if (!memory) {
                        console.error('[Texture] Memory not initialized');
                        return 0;
                    }
                    function readString(ptr, length) {
                        if (!ptr || length === 0) {
                            return '';
                        }
                        const bytes = new Uint8Array(memory.buffer, ptr, length);
                        const decoder = new TextDecoder('utf-8');
                        return decoder.decode(bytes);
                    }
                    const url = readString(urlPtr, urlLen);
                    const requestId = nextTextureRequestId++;

                    const request = {
                        id: requestId,
                        status: 'loading',  // 'loading', 'ready', 'error'
                        textureView: null,
                        textureViewHandle: 0,
                    };

                    textureLoadRequests.set(requestId, request);

                    console.log(`[Texture] Request ${requestId}: loading ${url}`);

                    // Load texture asynchronously
                    createTextureFromUrl(device, url, `texture-req-${requestId}`)
                        .then((view) => {
                            request.textureView = view;
                            request.textureViewHandle = webgpuHost.registerTextureView(view);
                            request.status = 'ready';
                            console.log(`[Texture] Request ${requestId} ready, handle=${request.textureViewHandle}`);
                        })
                        .catch((err) => {
                            console.error(`[Texture] Request ${requestId} failed:`, err);
                            request.status = 'error';
                        });

                    return requestId;
                },
                poll_texture_load: (requestId, handleOutPtr) => {
                    const request = textureLoadRequests.get(requestId);
                    if (!request) {
                        console.warn(`[Texture] Poll: unknown request ${requestId}`);
                        return -1;  // Invalid request ID
                    }

                    if (request.status === 'loading') {
                        return 0;  // Still loading
                    }

                    if (request.status === 'error') {
                        return -1;  // Failed
                    }

                    // Ready! Write handle to output pointer
                    const view = new DataView(memory.buffer);
                    view.setUint32(handleOutPtr, request.textureViewHandle, true);
                    return 1;  // Ready
                },
                cancel_texture_load: (requestId) => {
                    const request = textureLoadRequests.get(requestId);
                    if (request) {
                        console.log(`[Texture] Cancelled request ${requestId}`);
                        textureLoadRequests.delete(requestId);
                    }
                },
            };

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                env: {
                    cosf: (x) => Math.cos(x),
                    sinf: (x) => Math.sin(x),
                },
                platform: platformAPI,
                wasi_snapshot_preview1: {
                    fd_write: (fd, iovs, iovs_len, nwritten) => {
                        let written = 0;
                        const view = new DataView(memory.buffer);
                        const decoder = new TextDecoder();
                        for (let i = 0; i < iovs_len; i++) {
                            const ptr = view.getUint32(iovs + i * 8, true);
                            const len = view.getUint32(iovs + i * 8 + 4, true);
                            const bytes = new Uint8Array(memory.buffer, ptr, len);
                            console.log(decoder.decode(bytes));
                            written += len;
                        }
                        view.setUint32(nwritten, written, true);
                        return 0;
                    },
                    proc_exit: (code) => {
                        console.log('WASM exited with code:', code);
                        throw new Error('WASM called proc_exit with code: ' + code);
                    },
                },
                webgpu: webgpuHost.imports,
            });

            const wasmInstance = wasmModule.instance;
            memory = wasmInstance.exports.memory;
            webgpuHost.setMemory(memory);

            const gm_init = wasmInstance.exports.gm_init;
            const gm_frame = wasmInstance.exports.gm_frame;

            gm_init();

            // Pause rendering when tab is hidden
            let animationFrameId = null;
            let isPaused = false;

            function frame() {
                gm_frame();
                animationFrameId = requestAnimationFrame(frame);
            }

            animationFrameId = requestAnimationFrame(frame);

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                webgpuHost.configureContext(canvasFormat);
                webgpuHost.createDepthTexture(canvas.width, canvas.height);
                lastResizeId++;
            });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    isPaused = true;
                    if (animationFrameId !== null) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                } else {
                    if (isPaused) {
                        isPaused = false;
                        animationFrameId = requestAnimationFrame(frame);
                    }
                }
            });
        }

        init();
    </script>
</body>
</html>
