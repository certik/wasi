<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        // GMBufferSlot enum - keep in sync with gm.c
        const GMBufferSlot = Object.freeze({
            POSITIONS: 0,
            UVS: 1,
            SURFACE_TYPES: 2,
            TRIANGLE_IDS: 3,
            NORMALS: 4,
            INDICES: 5,
            UNIFORM: 6,
            OVERLAY_UNIFORM: 7,
            OVERLAY_TEXT: 8,
            OVERLAY_MAP: 9,
            OVERLAY_VERTEX: 10,
        });

        function createWasmWebGPUHost(adapter, device) {
            let memory = null;
            let nextHandle = 1;
            const decoder = new TextDecoder('utf-8');

            const buffers = new Map();
            const shaderModules = new Map();
            const devices = new Map();
            const queues = new Map();
            const bindGroupLayouts = new Map();
            const pipelineLayouts = new Map();
            const renderPipelines = new Map();
            const bindGroups = new Map();
            const samplers = new Map();
            const textureViews = new Map();

            const GMResource = {
                BUFFER: 0,
                SAMPLER: 1,
                TEXTURE_VIEW: 2,
                STORAGE_TEXTURE: 3,
            };

            const bufferBindingTypeMap = new Map([
                [0x00000002, 'uniform'],
                [0x00000003, 'storage'],
                [0x00000004, 'read-only-storage'],
            ]);

            const samplerTypeMap = new Map([
                [0x00000002, 'filtering'],
                [0x00000003, 'non-filtering'],
                [0x00000004, 'comparison'],
            ]);

            const textureSampleTypeMap = new Map([
                [0x00000002, 'float'],
                [0x00000003, 'unfilterable-float'],
                [0x00000004, 'depth'],
                [0x00000005, 'sint'],
                [0x00000006, 'uint'],
            ]);

            const textureViewDimensionMap = new Map([
                [0x00000001, '1d'],
                [0x00000002, '2d'],
                [0x00000003, '2d-array'],
                [0x00000004, 'cube'],
                [0x00000005, 'cube-array'],
                [0x00000006, '3d'],
            ]);

            const vertexFormatMap = new Map([
                [0x0000001C, 'float32'],
                [0x0000001D, 'float32x2'],
                [0x0000001E, 'float32x3'],
                [0x0000001F, 'float32x4'],
            ]);

            const vertexStepModeMap = new Map([
                [0x00000001, 'vertex'],
                [0x00000002, 'instance'],
            ]);

            const primitiveTopologyMap = new Map([
                [0x00000004, 'triangle-list'],
                [0x00000005, 'triangle-strip'],
                [0x00000001, 'point-list'],
                [0x00000002, 'line-list'],
                [0x00000003, 'line-strip'],
            ]);

            const cullModeMap = new Map([
                [0x00000001, 'none'],
                [0x00000002, 'front'],
                [0x00000003, 'back'],
            ]);

            const frontFaceMap = new Map([
                [0x00000001, 'ccw'],
                [0x00000002, 'cw'],
            ]);

            const compareFunctionMap = new Map([
                [0x00000002, 'less'],
                [0x00000008, 'always'],
                [0x00000004, 'less-equal'],
                [0x00000005, 'greater'],
            ]);

            const filterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const mipmapFilterModeMap = new Map([
                [0x00000001, 'nearest'],
                [0x00000002, 'linear'],
            ]);

            const addressModeMap = new Map([
                [0x00000001, 'clamp-to-edge'],
                [0x00000002, 'repeat'],
                [0x00000003, 'mirror-repeat'],
            ]);

            const blendFactorMap = new Map([
                [0x00000001, 'zero'],
                [0x00000002, 'one'],
                [0x00000005, 'src-alpha'],
                [0x00000006, 'one-minus-src-alpha'],
                [0x00000009, 'dst-alpha'],
                [0x0000000A, 'one-minus-dst-alpha'],
            ]);

            const blendOperationMap = new Map([
                [0x00000001, 'add'],
                [0x00000002, 'subtract'],
                [0x00000003, 'reverse-subtract'],
                [0x00000004, 'min'],
                [0x00000005, 'max'],
            ]);

            // Texture format mapping for use within this function
            const textureFormatToEnum = {
                'rgba8unorm': 0x00000016,
                'rgba8unorm-srgb': 0x00000017,
                'bgra8unorm': 0x0000001B,
                'bgra8unorm-srgb': 0x0000001C,
            };

            const textureFormatFromEnumLocal = {
                0x00000016: 'rgba8unorm',
                0x00000017: 'rgba8unorm-srgb',
                0x0000001B: 'bgra8unorm',
                0x0000001C: 'bgra8unorm-srgb',
                0x0000002C: 'stencil8',
                0x0000002D: 'depth16unorm',
                0x0000002E: 'depth24plus',
                0x0000002F: 'depth24plus-stencil8',
                0x00000030: 'depth32float',
                0x00000031: 'depth32float-stencil8',
            };

            function textureFormatFromEnum(value) {
                return textureFormatFromEnumLocal[value] ?? 'bgra8unorm';
            }

            const deviceHandle = nextHandle++;
            devices.set(deviceHandle, device);
            const queueHandle = nextHandle++;
            queues.set(queueHandle, device.queue);

            function requireMemory() {
                if (!memory) {
                    throw new Error('WebGPU memory not registered');
                }
            }

            function readString(ptr, length) {
                if (!ptr || length === 0) {
                    return '';
                }
                const bytes = new Uint8Array(memory.buffer, ptr, length);
                return decoder.decode(bytes);
            }

            function mapOrDefault(map, key, fallback) {
                return map.get(key) ?? fallback;
            }

            function readBindGroupLayoutEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 56;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const visibility = dv.getUint32(base + 4, true);
                    const resourceType = dv.getUint32(base + 8, true);
                    const bufferType = dv.getUint32(base + 12, true);
                    const hasDynamicOffset = !!dv.getUint32(base + 16, true);
                    const minBindingSize = Number(dv.getBigUint64(base + 20, true));
                    const samplerType = dv.getUint32(base + 28, true);
                    const textureSampleType = dv.getUint32(base + 32, true);
                    const textureViewDim = dv.getUint32(base + 36, true);
                    const textureMultisampled = !!dv.getUint32(base + 40, true);
                    const storageAccess = dv.getUint32(base + 44, true);
                    const storageFormat = dv.getUint32(base + 48, true);
                    const storageViewDim = dv.getUint32(base + 52, true);

                    const entry = { binding, visibility };
                    if (resourceType === GMResource.BUFFER) {
                        entry.buffer = {
                            type: mapOrDefault(bufferBindingTypeMap, bufferType, 'uniform'),
                            hasDynamicOffset,
                            minBindingSize,
                        };
                    } else if (resourceType === GMResource.SAMPLER) {
                        entry.sampler = {
                            type: mapOrDefault(samplerTypeMap, samplerType, 'filtering'),
                        };
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        entry.texture = {
                            sampleType: mapOrDefault(textureSampleTypeMap, textureSampleType, 'float'),
                            viewDimension: mapOrDefault(textureViewDimensionMap, textureViewDim, '2d'),
                            multisampled: textureMultisampled,
                        };
                    } else if (resourceType === GMResource.STORAGE_TEXTURE) {
                        entry.storageTexture = {
                            access: storageAccess === 0x00000003 ? 'read-only' : 'write-only',
                            format: textureFormatFromEnum(storageFormat),
                            viewDimension: mapOrDefault(textureViewDimensionMap, storageViewDim, '2d'),
                        };
                    }
                    entries.push(entry);
                }
                return entries;
            }

            function readBindGroupEntries(ptr, count) {
                const entries = [];
                const dv = new DataView(memory.buffer);
                const stride = 28;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const binding = dv.getUint32(base, true);
                    const resourceType = dv.getUint32(base + 4, true);
                    const handle = dv.getUint32(base + 8, true);
                    const offset = Number(dv.getBigUint64(base + 12, true));
                    const rawSize = dv.getBigUint64(base + 20, true);
                    const size = rawSize === 0xFFFFFFFFFFFFFFFFn ? undefined : Number(rawSize);

                    if (resourceType === GMResource.BUFFER) {
                        const buffer = buffers.get(handle);
                        if (!buffer) {
                            throw new Error(`Unknown buffer handle ${handle}`);
                        }
                        const resource = { buffer, offset };
                        if (size !== undefined) {
                            resource.size = size;
                        }
                        entries.push({
                            binding,
                            resource,
                        });
                    } else if (resourceType === GMResource.SAMPLER) {
                        const sampler = samplers.get(handle);
                        if (!sampler) {
                            throw new Error(`Unknown sampler handle ${handle}`);
                        }
                        entries.push({ binding, resource: sampler });
                    } else if (resourceType === GMResource.TEXTURE_VIEW) {
                        const view = textureViews.get(handle);
                        if (!view) {
                            throw new Error(`Unknown texture view handle ${handle}`);
                        }
                        entries.push({ binding, resource: view });
                    } else {
                        throw new Error(`Unsupported bind group resource type ${resourceType}`);
                    }
                }
                return entries;
            }

            function readProgrammableStage(ptr) {
                if (!ptr) {
                    return null;
                }
                const dv = new DataView(memory.buffer);
                const moduleHandle = dv.getUint32(ptr, true);
                const entryPtr = dv.getUint32(ptr + 4, true);
                const entryLength = dv.getUint32(ptr + 8, true);
                const module = shaderModules.get(moduleHandle);
                if (!module) {
                    throw new Error(`Unknown shader module handle ${moduleHandle}`);
                }
                const entryPoint = readString(entryPtr, entryLength) || 'main';
                return { module, entryPoint };
            }

            function readVertexBuffers(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const buffersOut = [];
                const dv = new DataView(memory.buffer);
                const stride = 16;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const arrayStride = dv.getUint32(base, true);
                    const stepModeValue = dv.getUint32(base + 4, true);
                    const attributeCount = dv.getUint32(base + 8, true);
                    const attributesPtr = dv.getUint32(base + 12, true);
                    const attributes = [];
                    const attrStride = 12;
                    for (let j = 0; j < attributeCount; j++) {
                        const attrBase = attributesPtr + j * attrStride;
                        const shaderLocation = dv.getUint32(attrBase, true);
                        const offset = dv.getUint32(attrBase + 4, true);
                        const formatValue = dv.getUint32(attrBase + 8, true);
                        attributes.push({
                            shaderLocation,
                            offset,
                            format: mapOrDefault(vertexFormatMap, formatValue, 'float32'),
                        });
                    }
                    buffersOut.push({
                        arrayStride,
                        stepMode: mapOrDefault(vertexStepModeMap, stepModeValue, 'vertex'),
                        attributes,
                    });
                }
                return buffersOut;
            }

            function readVertexState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const bufferCount = dv.getUint32(ptr + 4, true);
                const buffersPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    buffers: readVertexBuffers(buffersPtr, bufferCount),
                };
            }

            function readColorTargets(ptr, count) {
                if (!ptr || count === 0) {
                    return [];
                }
                const targets = [];
                const dv = new DataView(memory.buffer);
                const stride = 36;
                for (let i = 0; i < count; i++) {
                    const base = ptr + i * stride;
                    const format = textureFormatFromEnum(dv.getUint32(base, true));
                    const blendEnabled = !!dv.getUint32(base + 4, true);
                    const colorSrc = dv.getUint32(base + 8, true);
                    const colorDst = dv.getUint32(base + 12, true);
                    const colorOp = dv.getUint32(base + 16, true);
                    const alphaSrc = dv.getUint32(base + 20, true);
                    const alphaDst = dv.getUint32(base + 24, true);
                    const alphaOp = dv.getUint32(base + 28, true);
                    const writeMask = dv.getUint32(base + 32, true);
                    const target = { format, writeMask };
                    if (blendEnabled) {
                        target.blend = {
                            color: {
                                srcFactor: mapOrDefault(blendFactorMap, colorSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, colorDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, colorOp, 'add'),
                            },
                            alpha: {
                                srcFactor: mapOrDefault(blendFactorMap, alphaSrc, 'one'),
                                dstFactor: mapOrDefault(blendFactorMap, alphaDst, 'zero'),
                                operation: mapOrDefault(blendOperationMap, alphaOp, 'add'),
                            },
                        };
                    }
                    targets.push(target);
                }
                return targets;
            }

            function readFragmentState(ptr) {
                const dv = new DataView(memory.buffer);
                const stagePtr = dv.getUint32(ptr, true);
                const targetCount = dv.getUint32(ptr + 4, true);
                const targetsPtr = dv.getUint32(ptr + 8, true);
                const stage = readProgrammableStage(stagePtr);
                return {
                    module: stage.module,
                    entryPoint: stage.entryPoint,
                    targets: readColorTargets(targetsPtr, targetCount),
                };
            }

            function readPrimitiveState(ptr) {
                const dv = new DataView(memory.buffer);
                const topology = mapOrDefault(primitiveTopologyMap, dv.getUint32(ptr, true), 'triangle-list');
                const cullMode = mapOrDefault(cullModeMap, dv.getUint32(ptr + 4, true), 'none');
                const frontFace = mapOrDefault(frontFaceMap, dv.getUint32(ptr + 8, true), 'ccw');
                const stripIndexFormat = dv.getUint32(ptr + 12, true);
                const primitive = { topology, cullMode, frontFace };
                if (stripIndexFormat === 0x00000001) {
                    primitive.stripIndexFormat = 'uint16';
                } else if (stripIndexFormat === 0x00000002) {
                    primitive.stripIndexFormat = 'uint32';
                }
                return primitive;
            }

            function readDepthStencilState(ptr) {
                const dv = new DataView(memory.buffer);
                const format = textureFormatFromEnum(dv.getUint32(ptr, true));
                const depthWriteEnabled = !!dv.getUint32(ptr + 4, true);
                const depthCompare = mapOrDefault(compareFunctionMap, dv.getUint32(ptr + 8, true), 'less');
                return { format, depthWriteEnabled, depthCompare };
            }

            const imports = {
                create_instance() {
                    return 1;
                },
                surface_get_preferred_format() {
                    const preferred = navigator.gpu.getPreferredCanvasFormat();
                    const value = textureFormatToEnum[preferred] ?? 0x0000001B;
                    console.log('[WebGPU] Preferred canvas format (JS):', preferred, '-> enum', value);
                    return value;
                },
                device_create_buffer(deviceHandleParam, sizeLow, sizeHigh, usage, mapped) {
                    const targetDevice = devices.get(deviceHandleParam);
                    const size = sizeLow + sizeHigh * 4294967296;
                    const buffer = targetDevice.createBuffer({
                        size,
                        usage,
                        mappedAtCreation: !!mapped,
                    });
                    const handle = nextHandle++;
                    buffers.set(handle, buffer);
                    return handle;
                },
                queue_write_buffer(queueHandleParam, bufferHandle, offsetLow, offsetHigh, dataPtr, size) {
                    requireMemory();
                    const queue = queues.get(queueHandleParam);
                    const buffer = buffers.get(bufferHandle);
                    const offset = offsetLow + offsetHigh * 4294967296;
                    const source = new Uint8Array(memory.buffer, dataPtr, size);
                    queue.writeBuffer(buffer, offset, source);
                },
                device_create_shader_module(deviceHandleParam, codePtr, codeLength) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const bytes = new Uint8Array(memory.buffer, codePtr, codeLength);
                    const code = decoder.decode(bytes);
                    const module = targetDevice.createShaderModule({ code });
                    const handle = nextHandle++;
                    shaderModules.set(handle, module);
                    return handle;
                },
                device_create_bind_group_layout(deviceHandleParam, entriesPtr, entryCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const entries = readBindGroupLayoutEntries(entriesPtr, entryCount);
                    const layout = targetDevice.createBindGroupLayout({ entries });
                    const handle = nextHandle++;
                    bindGroupLayouts.set(handle, layout);
                    return handle;
                },
                device_create_pipeline_layout(deviceHandleParam, layoutsPtr, layoutCount) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const handles = new Uint32Array(memory.buffer, layoutsPtr, layoutCount);
                    const layouts = [];
                    for (let i = 0; i < handles.length; i++) {
                        const layout = bindGroupLayouts.get(handles[i]);
                        if (!layout) {
                            throw new Error(`Unknown bind group layout handle ${handles[i]}`);
                        }
                        layouts.push(layout);
                    }
                    const pipelineLayout = targetDevice.createPipelineLayout({ bindGroupLayouts: layouts });
                    const handle = nextHandle++;
                    pipelineLayouts.set(handle, pipelineLayout);
                    return handle;
                },
                device_create_sampler(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const base = descriptorPtr;
                    const desc = {
                        magFilter: mapOrDefault(filterModeMap, dv.getUint32(base, true), 'nearest'),
                        minFilter: mapOrDefault(filterModeMap, dv.getUint32(base + 4, true), 'nearest'),
                        mipmapFilter: mapOrDefault(mipmapFilterModeMap, dv.getUint32(base + 8, true), 'nearest'),
                        addressModeU: mapOrDefault(addressModeMap, dv.getUint32(base + 12, true), 'clamp-to-edge'),
                        addressModeV: mapOrDefault(addressModeMap, dv.getUint32(base + 16, true), 'clamp-to-edge'),
                        addressModeW: mapOrDefault(addressModeMap, dv.getUint32(base + 20, true), 'clamp-to-edge'),
                        lodMinClamp: dv.getFloat32(base + 24, true),
                        lodMaxClamp: dv.getFloat32(base + 28, true),
                    };
                    const compareValue = dv.getUint32(base + 32, true);
                    if (compareValue !== 0) {
                        desc.compare = mapOrDefault(compareFunctionMap, compareValue, 'less');
                    }
                    const sampler = targetDevice.createSampler(desc);
                    const handle = nextHandle++;
                    samplers.set(handle, sampler);
                    return handle;
                },
                device_create_bind_group(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const entryCount = dv.getUint32(descriptorPtr + 4, true);
                    const entriesPtr = dv.getUint32(descriptorPtr + 8, true);
                    const layout = bindGroupLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown bind group layout handle ${layoutHandle}`);
                    }
                    const entries = readBindGroupEntries(entriesPtr, entryCount);
                    const bindGroup = targetDevice.createBindGroup({ layout, entries });
                    const handle = nextHandle++;
                    bindGroups.set(handle, bindGroup);
                    return handle;
                },
                device_create_render_pipeline(deviceHandleParam, descriptorPtr) {
                    requireMemory();
                    const targetDevice = devices.get(deviceHandleParam);
                    const dv = new DataView(memory.buffer);
                    const layoutHandle = dv.getUint32(descriptorPtr, true);
                    const vertexStatePtr = dv.getUint32(descriptorPtr + 4, true);
                    const fragmentStatePtr = dv.getUint32(descriptorPtr + 8, true);
                    const primitiveStatePtr = dv.getUint32(descriptorPtr + 12, true);
                    const depthStatePtr = dv.getUint32(descriptorPtr + 16, true);
                    const sampleCount = dv.getUint32(descriptorPtr + 20, true);
                    const alphaToCoverage = !!dv.getUint32(descriptorPtr + 24, true);

                    const layout = pipelineLayouts.get(layoutHandle);
                    if (!layout) {
                        throw new Error(`Unknown pipeline layout handle ${layoutHandle}`);
                    }

                    const descriptor = {
                        layout,
                        vertex: readVertexState(vertexStatePtr),
                        primitive: readPrimitiveState(primitiveStatePtr),
                        multisample: {
                            count: sampleCount || 1,
                            mask: 0xFFFFFFFF,
                            alphaToCoverageEnabled: alphaToCoverage,
                        },
                    };

                    if (fragmentStatePtr !== 0) {
                        descriptor.fragment = readFragmentState(fragmentStatePtr);
                    }
                    if (depthStatePtr !== 0) {
                        descriptor.depthStencil = readDepthStencilState(depthStatePtr);
                    }

                    const pipeline = targetDevice.createRenderPipeline(descriptor);
                    const handle = nextHandle++;
                    renderPipelines.set(handle, pipeline);
                    return handle;
                },
            };

            return {
                imports,
                setMemory(mem) {
                    memory = mem;
                },
                handles: {
                    device: deviceHandle,
                    queue: queueHandle,
                },
                getBuffer(handle) {
                    return buffers.get(handle);
                },
                getShaderModule(handle) {
                    return shaderModules.get(handle);
                },
                getBindGroup(handle) {
                    return bindGroups.get(handle);
                },
                getRenderPipeline(handle) {
                    return renderPipelines.get(handle);
                },
                registerTextureView(view) {
                    const handle = nextHandle++;
                    textureViews.set(handle, view);
                    return handle;
                },
            };
        }

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Add error handling
            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const context = canvas.getContext('webgpu');

            function createSolidTexture(device, rgba, label) {
                const texture = device.createTexture({
                    label,
                    size: [1, 1, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                });
                const data = new Uint8Array(rgba);
                device.queue.writeTexture({ texture }, data, { bytesPerRow: 4 }, [1, 1, 1]);
                return texture.createView();
            }

            async function createTextureFromUrl(device, url, label) {
                console.log(`[Texture] Starting to load ${label} from ${url}`);
                try {
                    const response = await fetch(url, { mode: 'cors' });
                    console.log(`[Texture] Fetched ${label}, status: ${response.status}`);
                    const blob = await response.blob();
                    console.log(`[Texture] Blob size for ${label}: ${blob.size} bytes`);
                    const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    console.log(`[Texture] ImageBitmap created for ${label}: ${imageBitmap.width}x${imageBitmap.height}`);
                    const texture = device.createTexture({
                        label,
                        size: [imageBitmap.width, imageBitmap.height, 1],
                        format: 'rgba8unorm',
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                    console.log(`[Texture] Texture created for ${label}`);
                    device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture },
                        [imageBitmap.width, imageBitmap.height]
                    );
                    console.log(`[Texture] Data copied to texture for ${label}`);
                    const view = texture.createView();
                    console.log(`[Texture] Successfully loaded ${label}`);
                    return view;
                } catch (err) {
                    console.warn(`[Texture] ERROR loading ${label}:`, err);
                    console.warn(`Falling back to solid texture for ${label}`);
                    return createSolidTexture(device, [255, 255, 255, 255], `${label}-fallback`);
                }
            }

            // Load WASM module (with cache busting)
            const wasmResponse = await fetch('gm.wasm?v=' + Date.now());
            const wasmBytes = await wasmResponse.arrayBuffer();
            const webgpuHost = createWasmWebGPUHost(adapter, device);

            const textureFormatEnum = {
                'rgba8unorm': 0x00000016,
                'rgba8unorm-srgb': 0x00000017,
                'bgra8unorm': 0x0000001B,
                'bgra8unorm-srgb': 0x0000001C,
            };

            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const preferredFormatEnum = textureFormatEnum[canvasFormat] ?? textureFormatEnum['bgra8unorm'];

            context.configure({
                device,
                format: canvasFormat,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
            });

            function createDepthTexture() {
                return device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT,
                });
            }

            let depthTexture = createDepthTexture();

            const defaultTextures = {
                wall: 'https://threejs.org/examples/textures/brick_diffuse.jpg',
                floor: 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg',
                ceiling: 'https://threejs.org/examples/textures/lava/cloud.png',
            };

            const [wallTextureView, floorTextureView, ceilingTextureView] = await Promise.all([
                createTextureFromUrl(device, defaultTextures.wall, 'wall-texture'),
                createTextureFromUrl(device, defaultTextures.floor, 'floor-texture'),
                createTextureFromUrl(device, defaultTextures.ceiling, 'ceiling-texture'),
            ]);

            const hostConfigHandles = {
                device: webgpuHost.handles.device,
                queue: webgpuHost.handles.queue,
                wallTexture: webgpuHost.registerTextureView(wallTextureView),
                floorTexture: webgpuHost.registerTextureView(floorTextureView),
                ceilingTexture: webgpuHost.registerTextureView(ceilingTextureView),
                preferredFormat: preferredFormatEnum,
            };
            let hostConfigReady = true;

            const engineState = {
                uniformFloatCount: 0,
                overlayUniformFloatCount: 0,
                overlayTextCapacity: 0,
                mapCellCount: 0,
                vertexCount: 0,
                indexCount: 0,
                buffers: [],
                bindGroups: [],
                pipelines: [],
            };

            let uniformBuffer = null;
            let overlayUniformBuffer = null;
            let overlayTextBuffer = null;
            let overlayVertexBuffer = null;
            let bindGroup = null;
            let overlayBindGroup = null;
            let pipeline = null;
            let overlayPipeline = null;

            const keyStates = new Uint8Array(256);
            let mouseDeltaX = 0;
            let mouseDeltaY = 0;

            const arrowKeyMap = {
                'arrowleft': '<'.charCodeAt(0),
                'arrowright': '>'.charCodeAt(0),
                'arrowup': '^'.charCodeAt(0),
                'arrowdown': 'v'.charCodeAt(0),
            };

            function resolveKeyCode(event) {
                const key = event.key.toLowerCase();
                if (arrowKeyMap[key] !== undefined) {
                    return arrowKeyMap[key];
                }
                if (key.length === 1) {
                    return key.charCodeAt(0);
                }
                return null;
            }

            document.addEventListener('keydown', (event) => {
                const code = resolveKeyCode(event);
                if (code !== null) {
                    keyStates[code] = 1;
                    event.preventDefault();
                }
            });

            document.addEventListener('keyup', (event) => {
                const code = resolveKeyCode(event);
                if (code !== null) {
                    keyStates[code] = 0;
                    event.preventDefault();
                }
            });

            canvas.addEventListener('click', () => canvas.requestPointerLock());

            function onMouseMove(event) {
                mouseDeltaX += event.movementX;
                mouseDeltaY += event.movementY;
            }

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            let memory = null;

            let frameCounter = 0;

            const platformAPI = {
                get_canvas_size: (widthPtr, heightPtr) => {
                    const view = new Int32Array(memory.buffer);
                    view[widthPtr / 4] = canvas.width;
                    view[heightPtr / 4] = canvas.height;
                },
                get_time: () => performance.now(),
                request_animation_frame: () => {
                    requestAnimationFrame(frame);
                },
                render_frame: (uniformDataPtr, overlayUniformDataPtr, overlayTextDataPtr, overlayTextLength,
                               jsTimeOutPtr, gpuCopyTimeOutPtr, gpuRenderTimeOutPtr) => {
                    frameCounter++;
                    if (!pipeline || !bindGroup || !uniformBuffer) {
                        if (frameCounter <= 10 || frameCounter % 60 === 0) {
                            console.warn('[GM] render_frame missing resources', {
                                pipelineReady: !!pipeline,
                                bindGroupReady: !!bindGroup,
                                uniformReady: !!uniformBuffer,
                                frameCounter,
                            });
                        }
                        return 0;
                    }

                    const frameStartTime = performance.now();

                    const uniformData = new Float32Array(memory.buffer, uniformDataPtr, engineState.uniformFloatCount);
                    const overlayUniformData = new Float32Array(memory.buffer, overlayUniformDataPtr, engineState.overlayUniformFloatCount);
                    const overlayTextData = new Uint32Array(memory.buffer, overlayTextDataPtr, overlayTextLength);

                    device.queue.writeBuffer(uniformBuffer, 0, uniformData);
                    device.queue.writeBuffer(overlayUniformBuffer, 0, overlayUniformData);
                    if (overlayTextLength > 0) {
                        device.queue.writeBuffer(overlayTextBuffer, 0, overlayTextData);
                    }

                    const jsEndTime = performance.now();
                    const jsTime = jsEndTime - frameStartTime;

                    const commandEncoder = device.createCommandEncoder();
                    const textureView = context.getCurrentTexture().createView();
                    const depthView = depthTexture.createView();

                    const renderPass = commandEncoder.beginRenderPass({
                        colorAttachments: [{
                            view: textureView,
                            clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store',
                        }],
                        depthStencilAttachment: {
                            view: depthView,
                            depthClearValue: 1.0,
                            depthLoadOp: 'clear',
                            depthStoreOp: 'store',
                        },
                    });

                    renderPass.setPipeline(pipeline);
                    renderPass.setBindGroup(0, bindGroup);
                    renderPass.setVertexBuffer(0, engineState.buffers[GMBufferSlot.POSITIONS]);
                    renderPass.setVertexBuffer(1, engineState.buffers[GMBufferSlot.UVS]);
                    renderPass.setVertexBuffer(2, engineState.buffers[GMBufferSlot.SURFACE_TYPES]);
                    renderPass.setVertexBuffer(3, engineState.buffers[GMBufferSlot.TRIANGLE_IDS]);
                    renderPass.setVertexBuffer(4, engineState.buffers[GMBufferSlot.NORMALS]);
                    renderPass.setIndexBuffer(engineState.buffers[GMBufferSlot.INDICES], 'uint16');
                    renderPass.drawIndexed(engineState.indexCount);

                    renderPass.setPipeline(overlayPipeline);
                    renderPass.setBindGroup(0, overlayBindGroup);
                    renderPass.setVertexBuffer(0, overlayVertexBuffer);
                    renderPass.draw(4);
                    renderPass.end();

                    device.queue.submit([commandEncoder.finish()]);

                    const gpuRenderEndTime = performance.now();
                    const gpuRenderTime = gpuRenderEndTime - jsEndTime;
                    const totalFrameTime = gpuRenderEndTime - frameStartTime;

                    const timings = new Float64Array(memory.buffer);
                    timings[jsTimeOutPtr / 8] = jsTime;
                    timings[gpuCopyTimeOutPtr / 8] = 0.0;
                    timings[gpuRenderTimeOutPtr / 8] = gpuRenderTime;

                    return totalFrameTime;
                },
                get_host_config: (configPtr) => {
                    if (!hostConfigReady) {
                        return 0;
                    }
                    const view = new DataView(memory.buffer, configPtr, 24);
                    view.setUint32(0, hostConfigHandles.device, true);
                    view.setUint32(4, hostConfigHandles.queue, true);
                    view.setUint32(8, hostConfigHandles.wallTexture, true);
                    view.setUint32(12, hostConfigHandles.floorTexture, true);
                    view.setUint32(16, hostConfigHandles.ceilingTexture, true);
                    view.setUint32(20, hostConfigHandles.preferredFormat, true);
                    return 1;
                },
                register_uniform_info: (uniformFloatCount, overlayUniformFloatCount, overlayTextCapacity, mapCellCount) => {
                    console.log('[GM] register_uniform_info', { uniformFloatCount, overlayUniformFloatCount, overlayTextCapacity, mapCellCount });
                    engineState.uniformFloatCount = uniformFloatCount;
                    engineState.overlayUniformFloatCount = overlayUniformFloatCount;
                    engineState.overlayTextCapacity = overlayTextCapacity;
                    engineState.mapCellCount = mapCellCount;
                },
                register_gpu_buffers: (handlesPtr, count) => {
                    const handlesView = new Uint32Array(memory.buffer, handlesPtr, count);
                    const handles = Array.from(handlesView);
                    engineState.buffers = handles.map((handle) => webgpuHost.getBuffer(handle));
                    console.log('[GM] register_gpu_buffers', { count, handles });
                    uniformBuffer = engineState.buffers[GMBufferSlot.UNIFORM];
                    overlayUniformBuffer = engineState.buffers[GMBufferSlot.OVERLAY_UNIFORM];
                    overlayTextBuffer = engineState.buffers[GMBufferSlot.OVERLAY_TEXT];
                    overlayVertexBuffer = engineState.buffers[GMBufferSlot.OVERLAY_VERTEX];
                },
                register_bind_groups: (handlesPtr, count) => {
                    const handlesView = new Uint32Array(memory.buffer, handlesPtr, count);
                    const handles = Array.from(handlesView);
                    engineState.bindGroups = handles.map((handle) => webgpuHost.getBindGroup(handle));
                    console.log('[GM] register_bind_groups', { count, handles });
                    bindGroup = engineState.bindGroups[0];
                    overlayBindGroup = engineState.bindGroups[1];
                },
                register_render_pipelines: (handlesPtr, count) => {
                    const handlesView = new Uint32Array(memory.buffer, handlesPtr, count);
                    const handles = Array.from(handlesView);
                    engineState.pipelines = handles.map((handle) => webgpuHost.getRenderPipeline(handle));
                    console.log('[GM] register_render_pipelines', { count, handles });
                    pipeline = engineState.pipelines[0];
                    overlayPipeline = engineState.pipelines[1];
                },
                register_mesh_info: (vertexCount, indexCount) => {
                    console.log('[GM] register_mesh_info', { vertexCount, indexCount });
                    engineState.vertexCount = vertexCount;
                    engineState.indexCount = indexCount;
                },
                get_input_state: (snapshotPtr) => {
                    const keysView = new Uint8Array(memory.buffer, snapshotPtr, 256);
                    keysView.set(keyStates);
                    const dv = new DataView(memory.buffer, snapshotPtr + 256, 8);
                    dv.setFloat32(0, mouseDeltaX, true);
                    dv.setFloat32(4, mouseDeltaY, true);
                    mouseDeltaX = 0;
                    mouseDeltaY = 0;
                },
            };

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                env: {
                    cosf: (x) => Math.cos(x),
                    sinf: (x) => Math.sin(x),
                },
                platform: platformAPI,
                wasi_snapshot_preview1: {
                    fd_write: (fd, iovs, iovs_len, nwritten) => {
                        let written = 0;
                        const view = new DataView(memory.buffer);
                        const decoder = new TextDecoder();
                        for (let i = 0; i < iovs_len; i++) {
                            const ptr = view.getUint32(iovs + i * 8, true);
                            const len = view.getUint32(iovs + i * 8 + 4, true);
                            const bytes = new Uint8Array(memory.buffer, ptr, len);
                            console.log(decoder.decode(bytes));
                            written += len;
                        }
                        view.setUint32(nwritten, written, true);
                        return 0;
                    },
                    proc_exit: (code) => {
                        console.log('WASM exited with code:', code);
                        throw new Error('WASM called proc_exit with code: ' + code);
                    },
                },
                webgpu: webgpuHost.imports,
            });

            const wasmInstance = wasmModule.instance;
            memory = wasmInstance.exports.memory;
            webgpuHost.setMemory(memory);

            const gm_frame = wasmInstance.exports.gm_frame;

            function frame() {
                gm_frame();
                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                context.configure({
                    device,
                    format: canvasFormat,
                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
                });
                depthTexture.destroy();
                depthTexture = createDepthTexture();
            });
        }

        init();
    </script>
</body>
</html>
