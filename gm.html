<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map (Mesh-Based)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; position: absolute; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Add error handling
            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            console.log('[WebGPU] Preferred canvas format:', format);
            context.configure({
                device,
                format,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST
            });
            console.log('[WebGPU] Canvas configured');

            function createSolidTexture(device, rgba, label) {
                const texture = device.createTexture({
                    label,
                    size: [1, 1, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                });
                const data = new Uint8Array(rgba);
                device.queue.writeTexture({ texture }, data, { bytesPerRow: 4 }, [1, 1, 1]);
                return texture.createView();
            }

            async function createTextureFromUrl(device, url, label) {
                console.log(`[Texture] Starting to load ${label} from ${url}`);
                try {
                    const response = await fetch(url, { mode: 'cors' });
                    console.log(`[Texture] Fetched ${label}, status: ${response.status}`);
                    const blob = await response.blob();
                    console.log(`[Texture] Blob size for ${label}: ${blob.size} bytes`);
                    const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    console.log(`[Texture] ImageBitmap created for ${label}: ${imageBitmap.width}x${imageBitmap.height}`);
                    const texture = device.createTexture({
                        label,
                        size: [imageBitmap.width, imageBitmap.height, 1],
                        format: 'rgba8unorm',
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                    });
                    console.log(`[Texture] Texture created for ${label}`);
                    device.queue.copyExternalImageToTexture(
                        { source: imageBitmap },
                        { texture },
                        [imageBitmap.width, imageBitmap.height]
                    );
                    console.log(`[Texture] Data copied to texture for ${label}`);
                    const view = texture.createView();
                    console.log(`[Texture] Successfully loaded ${label}`);
                    return view;
                } catch (err) {
                    console.warn(`[Texture] ERROR loading ${label}:`, err);
                    console.warn(`Falling back to solid texture for ${label}`);
                    return createSolidTexture(device, [255, 255, 255, 255], `${label}-fallback`);
                }
            }

            // Map definition (1 = wall, 2 = wall with north/south window, 3 = wall with east/west window, 0 = floor, 5-8 = starting position with direction)
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,7,0,0,0,0,0,0,0,1],
                [1,0,1,2,1,0,2,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,0,3,0,1,0,0,1],
                [1,0,3,0,1,1,0,0,1,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction using WASM
            let startX = 1.5, startZ = 1.5, startYaw = 0;

            // Load and use WASM module for finding start position
            try {
                const wasmResponse = await fetch('gm_init.wasm');
                const wasmBytes = await wasmResponse.arrayBuffer();
                const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                    wasi_snapshot_preview1: {
                        fd_write: () => 0,
                        proc_exit: () => {},
                        path_open: () => 0,
                        fd_close: () => 0,
                        fd_read: () => 0,
                        fd_seek: () => 0,
                        fd_tell: () => 0,
                        args_sizes_get: () => 0,
                        args_get: () => 0,
                    }
                });

                const wasmInstance = wasmModule.instance;
                const memory = wasmInstance.exports.memory;
                const find_start_position = wasmInstance.exports.find_start_position;

                // Flatten the 2D map into 1D array
                const flatMap = new Int32Array(mapWidth * mapHeight);
                for (let z = 0; z < mapHeight; z++) {
                    for (let x = 0; x < mapWidth; x++) {
                        flatMap[z * mapWidth + x] = map[z][x];
                    }
                }

                // Allocate memory in WASM for map, startX, startZ, startYaw
                const mapPtr = 1024; // Safe offset in WASM memory
                const startXPtr = mapPtr + flatMap.length * 4 + 4;
                const startZPtr = startXPtr + 4;
                const startYawPtr = startZPtr + 4;

                // Copy map to WASM memory
                const wasmMemory = new Int32Array(memory.buffer);
                wasmMemory.set(flatMap, mapPtr / 4);

                // Call WASM function
                const found = find_start_position(mapPtr, mapWidth, mapHeight, startXPtr, startZPtr, startYawPtr);

                if (found) {
                    // Read results from WASM memory
                    const floatView = new Float32Array(memory.buffer);
                    startX = floatView[startXPtr / 4];
                    startZ = floatView[startZPtr / 4];
                    startYaw = floatView[startYawPtr / 4];

                    // Update JavaScript map with cleared marker
                    for (let z = 0; z < mapHeight; z++) {
                        for (let x = 0; x < mapWidth; x++) {
                            map[z][x] = wasmMemory[mapPtr / 4 + z * mapWidth + x];
                        }
                    }

                    const dirName = startYaw < -1.0 ? 'North' : startYaw < 1.0 ? 'East' : startYaw < 2.0 ? 'South' : 'West';
                    console.log(`[WASM] Starting at (${startX}, ${startZ}) facing ${dirName} with yaw=${startYaw}`);
                } else {
                    console.error('[WASM] Starting position not found!');
                }
            } catch (error) {
                console.warn('[WASM] Failed to load WASM module, using JavaScript fallback:', error);
                // JavaScript fallback
                for (let z = 0; z < mapHeight; z++) {
                    for (let x = 0; x < mapWidth; x++) {
                        const cell = map[z][x];
                        if (cell >= 5 && cell <= 8) {
                            startX = x + 0.5;
                            startZ = z + 0.5;
                            if (cell === 5) startYaw = -Math.PI / 2;    // North
                            else if (cell === 6) startYaw = 0;          // East
                            else if (cell === 7) startYaw = Math.PI / 2; // South
                            else if (cell === 8) startYaw = Math.PI;    // West
                            map[z][x] = 0; // Clear the marker
                            console.log(`[JS] Starting at (${startX}, ${startZ}) facing ${cell===5?'North':cell===6?'East':cell===7?'South':'West'} with yaw=${startYaw}`);
                        }
                    }
                }
            }

            const wallHeight = 2.0;
            const checkerSize = 4.0; // For 4x4 checker per unit

            // Generate meshes
            const positions = [];
            const uvs = [];
            const normals = []; // vertex normals
            const surfaceTypes = []; // 0=floor, 1=wall, 2=ceiling
            const triangleIDs = []; // unique ID for each triangle
            const indices = [];
            let indexOffset = 0;
            let triangleCounter = 0;

            const windowBottom = wallHeight * 0.3;
            const windowTop = wallHeight - windowBottom;
            const windowMargin = 0.15;
            const invWallHeight = 1.0 / wallHeight;

            function pushNorthSegmentRange(x0, x1, z, y0, y1, normalizeU = false, surfaceType = 1) {
                const v0 = y0 * invWallHeight;
                const v1 = y1 * invWallHeight;
                const uSpan = normalizeU ? 1.0 : (x1 - x0);
                positions.push(
                    x0, y0, z,
                    x1, y0, z,
                    x0, y1, z,
                    x1, y1, z
                );
                uvs.push(0, v0, uSpan, v0, 0, v1, uSpan, v1);
                normals.push(0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1); // North face normal
                surfaceTypes.push(surfaceType, surfaceType, surfaceType, surfaceType);
                // Triangle IDs for flat interpolation: only the first vertex of each triangle matters (provoking vertex)
                // Triangle 1: [0,1,2] - provoking vertex 0 → gets triangleCounter
                // Triangle 2: [1,3,2] - provoking vertex 1 → gets triangleCounter+1
                triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
                indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                indexOffset += 4;
                triangleCounter += 2;
            }

            function pushSouthSegmentRange(x0, x1, z, y0, y1, normalizeU = false, surfaceType = 1) {
                const v0 = y0 * invWallHeight;
                const v1 = y1 * invWallHeight;
                const uSpan = normalizeU ? 1.0 : (x1 - x0);
                positions.push(
                    x0, y0, z + 1,
                    x1, y0, z + 1,
                    x0, y1, z + 1,
                    x1, y1, z + 1
                );
                uvs.push(0, v0, uSpan, v0, 0, v1, uSpan, v1);
                normals.push(0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1); // South face normal
                surfaceTypes.push(surfaceType, surfaceType, surfaceType, surfaceType);
                triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
                indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                indexOffset += 4;
                triangleCounter += 2;
            }

            function pushWestSegmentRange(x, z0, z1, y0, y1, normalizeU = false, surfaceType = 1) {
                const v0 = y0 * invWallHeight;
                const v1 = y1 * invWallHeight;
                const uSpan = normalizeU ? 1.0 : (z1 - z0);
                positions.push(
                    x, y0, z0,
                    x, y0, z1,
                    x, y1, z0,
                    x, y1, z1
                );
                uvs.push(0, v0, uSpan, v0, 0, v1, uSpan, v1);
                normals.push(-1, 0, 0,  -1, 0, 0,  -1, 0, 0,  -1, 0, 0); // West face normal
                surfaceTypes.push(surfaceType, surfaceType, surfaceType, surfaceType);
                triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
                indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                indexOffset += 4;
                triangleCounter += 2;
            }

            function pushEastSegmentRange(x, z0, z1, y0, y1, normalizeU = false, surfaceType = 1) {
                const v0 = y0 * invWallHeight;
                const v1 = y1 * invWallHeight;
                const uSpan = normalizeU ? 1.0 : (z1 - z0);
                positions.push(
                    x, y0, z0,
                    x, y0, z1,
                    x, y1, z0,
                    x, y1, z1
                );
                uvs.push(0, v0, uSpan, v0, 0, v1, uSpan, v1);
                normals.push(1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0); // East face normal
                surfaceTypes.push(surfaceType, surfaceType, surfaceType, surfaceType);
                triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
                indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                indexOffset += 4;
                triangleCounter += 2;
            }

            function pushHorizontalFill(x0, x1, z0, z1, y, surfaceType) {
                const uSpan = x1 - x0;
                const vSpan = z1 - z0;
                positions.push(
                    x0, y, z0,
                    x1, y, z0,
                    x0, y, z1,
                    x1, y, z1
                );
                uvs.push(0, 0, uSpan, 0, 0, vSpan, uSpan, vSpan);
                // Normal depends on surface type: floor (0) = (0,1,0), ceiling (2) = (0,-1,0)
                const ny = surfaceType === 0 ? 1 : -1;
                normals.push(0, ny, 0,  0, ny, 0,  0, ny, 0,  0, ny, 0);
                surfaceTypes.push(surfaceType, surfaceType, surfaceType, surfaceType);
                triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
                indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
                indexOffset += 4;
                triangleCounter += 2;
            }

            function pushNorthSegment(x, z, y0, y1) {
                pushNorthSegmentRange(x, x + 1, z, y0, y1);
            }

            function pushSouthSegment(x, z, y0, y1) {
                pushSouthSegmentRange(x, x + 1, z, y0, y1);
            }

            function pushWestSegment(x, z, y0, y1) {
                pushWestSegmentRange(x, z, z + 1, y0, y1);
            }

            function pushEastSegment(x, z, y0, y1) {
                pushEastSegmentRange(x + 1, z, z + 1, y0, y1);
            }

            // Floor: one big quad (matching collision coordinate system)
            const floorPositions = [
                0, 0, 0,  mapWidth, 0, 0,
                0, 0, mapHeight,  mapWidth, 0, mapHeight
            ];
            const floorUVs = [
                0, 0,  mapWidth * checkerSize, 0,
                0, mapHeight * checkerSize,  mapWidth * checkerSize, mapHeight * checkerSize
            ];
            positions.push(...floorPositions);
            uvs.push(...floorUVs);
            normals.push(0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0); // Floor normal (up)
            surfaceTypes.push(0, 0, 0, 0); // floor
            triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
            indexOffset += 4;
            triangleCounter += 2;

            // Ceiling: similar but at wallHeight (matching collision coordinate system)
            const ceilingPositions = [
                0, wallHeight, 0,  mapWidth, wallHeight, 0,
                0, wallHeight, mapHeight,  mapWidth, wallHeight, mapHeight
            ];
            const ceilingUVs = floorUVs; // Same tiling
            positions.push(...ceilingPositions);
            uvs.push(...ceilingUVs);
            normals.push(0, -1, 0,  0, -1, 0,  0, -1, 0,  0, -1, 0); // Ceiling normal (down)
            surfaceTypes.push(2, 2, 2, 2); // ceiling
            triangleIDs.push(triangleCounter, triangleCounter + 1, 0, 0);
            indices.push(indexOffset, indexOffset + 1, indexOffset + 2, indexOffset + 1, indexOffset + 3, indexOffset + 2);
            indexOffset += 4;
            triangleCounter += 2;

            const isSolidCell = (value) => value === 1 || value === 2 || value === 3;

            // Walls: generate quads for each boundary
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    const cell = map[z][x];
                    if (!isSolidCell(cell)) {
                        continue;
                    }

                    const isWindowNS = cell === 2;
                    const isWindowEW = cell === 3;

                    const xInner0 = x + windowMargin;
                    const xInner1 = x + 1 - windowMargin;
                    const zInner0 = z + windowMargin;
                    const zInner1 = z + 1 - windowMargin;

                    // North face (negative Z)
                    if (z === 0 || !isSolidCell(map[z - 1][x])) {
                        if (isWindowNS) {
                            pushNorthSegmentRange(x, x + 1, z, 0, windowBottom);
                            pushNorthSegmentRange(x, x + 1, z, windowTop, wallHeight);
                            pushNorthSegmentRange(x, xInner0, z, windowBottom, windowTop, false, 3);
                            pushNorthSegmentRange(xInner1, x + 1, z, windowBottom, windowTop, false, 3);
                        } else {
                            pushNorthSegment(x, z, 0, wallHeight);
                        }
                    }
                    // South face (positive Z)
                    if (z === mapHeight - 1 || !isSolidCell(map[z + 1][x])) {
                        if (isWindowNS) {
                            pushSouthSegmentRange(x, x + 1, z, 0, windowBottom);
                            pushSouthSegmentRange(x, x + 1, z, windowTop, wallHeight);
                            pushSouthSegmentRange(x, xInner0, z, windowBottom, windowTop, false, 3);
                            pushSouthSegmentRange(xInner1, x + 1, z, windowBottom, windowTop, false, 3);
                        } else {
                            pushSouthSegment(x, z, 0, wallHeight);
                        }
                    }
                    // West face (negative X)
                    if (x === 0 || !isSolidCell(map[z][x - 1])) {
                        if (isWindowEW) {
                            pushWestSegmentRange(x, z, z + 1, 0, windowBottom);
                            pushWestSegmentRange(x, z, z + 1, windowTop, wallHeight);
                            pushWestSegmentRange(x, z, zInner0, windowBottom, windowTop, false, 3);
                            pushWestSegmentRange(x, zInner1, z + 1, windowBottom, windowTop, false, 3);
                        } else {
                            pushWestSegment(x, z, 0, wallHeight);
                        }
                    }
                    // East face (positive X)
                    if (x === mapWidth - 1 || !isSolidCell(map[z][x + 1])) {
                        if (isWindowEW) {
                            pushEastSegmentRange(x + 1, z, z + 1, 0, windowBottom);
                            pushEastSegmentRange(x + 1, z, z + 1, windowTop, wallHeight);
                            pushEastSegmentRange(x + 1, z, zInner0, windowBottom, windowTop, false, 3);
                            pushEastSegmentRange(x + 1, zInner1, z + 1, windowBottom, windowTop, false, 3);
                        } else {
                            pushEastSegment(x, z, 0, wallHeight);
                        }
                    }

                    if (isWindowNS) {
                        pushWestSegmentRange(xInner0, z, z + 1, windowBottom, windowTop, true, 3);
                        pushEastSegmentRange(xInner1, z, z + 1, windowBottom, windowTop, true, 3);
                        pushHorizontalFill(xInner0, xInner1, z, z + 1, windowBottom, 0);
                        pushHorizontalFill(xInner0, xInner1, z, z + 1, windowTop, 2);
                    } else if (isWindowEW) {
                        pushNorthSegmentRange(x, x + 1, zInner0, windowBottom, windowTop, true, 3);
                        pushSouthSegmentRange(x, x + 1, zInner1 - 1, windowBottom, windowTop, true, 3);
                        pushHorizontalFill(x, x + 1, zInner0, zInner1, windowBottom, 0);
                        pushHorizontalFill(x, x + 1, zInner0, zInner1, windowTop, 2);
                    }
                }
            }

            const mapDataArray = new Uint32Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    mapDataArray[z * mapWidth + x] = map[z][x];
                }
            }

            // Buffers
            const positionBuffer = device.createBuffer({
                size: positions.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(positionBuffer.getMappedRange()).set(positions);
            positionBuffer.unmap();

            const uvBuffer = device.createBuffer({
                size: uvs.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(uvBuffer.getMappedRange()).set(uvs);
            uvBuffer.unmap();

            const surfaceTypeBuffer = device.createBuffer({
                size: surfaceTypes.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(surfaceTypeBuffer.getMappedRange()).set(surfaceTypes);
            surfaceTypeBuffer.unmap();

            const triangleIDBuffer = device.createBuffer({
                size: triangleIDs.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(triangleIDBuffer.getMappedRange()).set(triangleIDs);
            triangleIDBuffer.unmap();

            const normalBuffer = device.createBuffer({
                size: normals.length * 4,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(normalBuffer.getMappedRange()).set(normals);
            normalBuffer.unmap();

            const indexBuffer = device.createBuffer({
                size: indices.length * 2,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true
            });
            new Uint16Array(indexBuffer.getMappedRange()).set(indices);
            indexBuffer.unmap();

            // Uniform buffer - use individual floats to avoid vec/matrix alignment issues
            // Layout: cameraPosX, cameraPosY, cameraPosZ, yaw, pitch, fov, viewWidth, viewHeight, useTextures, padding0..2
            const uniformFloatCount = 12;
            const uniformBuffer = device.createBuffer({
                size: uniformFloatCount * 4,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Shaders
            const vsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                    useTextures: f32,
                    showTriangles: f32,
                    debugMode: f32,
                    padding2: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                    @location(3) materialUV: vec2<f32>,
                    @location(4) normal: vec3<f32>,
                    @location(5) @interpolate(flat) triangleID: f32,
                };

                @vertex fn vs_main(
                    @location(0) position: vec3<f32>,
                    @location(1) uv: vec2<f32>,
                    @location(2) surfaceType: f32,
                    @location(3) triangleID: f32,
                    @location(4) normal: vec3<f32>
                ) -> VertexOutput {
                    var output: VertexOutput;

                    // Transform to camera space
                    let cy = cos(u.yaw);
                    let sy = sin(u.yaw);
                    let cp = cos(u.pitch);
                    let sp = sin(u.pitch);

                    // Position relative to camera
                    let dx = position.x - u.cameraPosX;
                    let dy = position.y - u.cameraPosY;
                    let dz = position.z - u.cameraPosZ;

                    // Transform to view space
                    // Forward direction is (cos(yaw), 0, sin(yaw)) in world space
                    // Right direction is (-sin(yaw), 0, cos(yaw)) in world space
                    let viewX = -dx * sy + dz * cy;
                    let viewZ_noPitch = dx * cy + dz * sy;

                    // Rotate by pitch (around X axis in view space)
                    let viewY = dy * cp - viewZ_noPitch * sp;
                    let viewZ = dy * sp + viewZ_noPitch * cp;

                    // Calculate distance from camera for fog
                    let viewDist = sqrt(viewX * viewX + viewY * viewY + viewZ * viewZ);

                    // Perspective projection
                    let aspect = u.viewWidth / u.viewHeight;
                    let f = tan(u.fov * 0.5);
                    let near = 0.01;
                    let far = 100.0;

                    // Output clip-space coordinates (before perspective divide)
                    // Let GPU handle perspective divide by setting w = viewZ
                    let clipX = viewX / (f * aspect);
                    let clipY = viewY / f;
                    let clipZ = ((far + near) * viewZ - 2.0 * far * near) / (far - near);
                    let clipW = viewZ;

                    output.clipPos = vec4<f32>(clipX, clipY, clipZ, clipW);
                    output.worldPos = position;
                    output.surfaceType = surfaceType;
                    output.viewDist = viewDist;
                    output.materialUV = uv;
                    output.normal = normal;
                    output.triangleID = triangleID;
                    return output;
                }
            `;

            const fsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                    useTextures: f32,
                    showTriangles: f32,
                    debugMode: f32,
                    padding2: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;
                @group(0) @binding(1) var s: sampler;
                @group(0) @binding(2) var wallTexture: texture_2d<f32>;
                @group(0) @binding(3) var floorTexture: texture_2d<f32>;
                @group(0) @binding(4) var ceilingTexture: texture_2d<f32>;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                    @location(3) materialUV: vec2<f32>,
                    @location(4) normal: vec3<f32>,
                    @location(5) @interpolate(flat) triangleID: f32,
                };

                @fragment fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
                    // Calculate perspective-correct UVs from world position
                    var texU: f32;
                    var texV: f32;

                    if (in.surfaceType > 1.5 && in.surfaceType < 2.5) {
                        // Ceiling (surfaceType = 2)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    } else if (in.surfaceType > 0.5 && in.surfaceType < 2.5) {
                        // Wall (surfaceType = 1)
                        let fx = fract(in.worldPos.x);
                        let fz = fract(in.worldPos.z);
                        let distX = min(fx, 1.0 - fx);
                        let distZ = min(fz, 1.0 - fz);
                        if (distX < distZ) {
                            texU = fz;
                        } else {
                            texU = fx;
                        }
                        texV = in.worldPos.y / 2.0; // wallHeight = 2.0
                    } else {
                        // Floor (surfaceType = 0) or window frames (3) initial default
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    }

                    let isFrame = in.surfaceType > 2.5;
                    if (isFrame) {
                        texU = in.materialUV.x;
                        texV = in.materialUV.y;
                    }

                    var tileScale = 4.0;
                    var baseColor: vec4<f32>;
                    if (u.useTextures > 0.5) {
                        if (in.surfaceType > 1.5 && in.surfaceType < 2.5) {
                            tileScale = 4.0 / 3.0; // Ceiling texture 3x larger
                        } else if (in.surfaceType > 0.5) {
                            tileScale = 4.0 / 5.0; // Wall/window texture 5x larger
                        } else {
                            tileScale = 4.0 / 5.0; // Floor texture 5x larger
                        }
                        let sampleUV = vec2<f32>(texU, texV) * tileScale;

                        // Sample all textures unconditionally to satisfy uniform control flow requirement
                        let ceilingSample = textureSample(ceilingTexture, s, sampleUV);
                        let wallSample = textureSample(wallTexture, s, sampleUV);
                        let floorSample = textureSample(floorTexture, s, sampleUV);

                        // Select the appropriate sample based on surface type
                        if (in.surfaceType > 1.5 && in.surfaceType < 2.5) {
                            baseColor = ceilingSample;
                        } else if (in.surfaceType > 0.5) {
                            baseColor = wallSample;
                        } else {
                            baseColor = floorSample;
                        }
                    } else {
                        let checkerU = floor(texU * 4.0);
                        let checkerV = floor(texV * 4.0);
                        let checker = (i32(checkerU) + i32(checkerV)) & 1;
                        let checkerFactor = select(0.7, 1.0, checker == 0);

                        if (in.surfaceType > 1.5 && in.surfaceType < 2.5) {
                            baseColor = vec4<f32>(1.0, 1.0, 0.0, 1.0); // Yellow ceiling
                        } else if (in.surfaceType > 0.5) {
                            baseColor = vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red walls
                        } else {
                            baseColor = vec4<f32>(0.0, 0.0, 1.0, 1.0); // Blue floor
                        }

                        baseColor *= checkerFactor;
                    }

                    var color = baseColor;

                    // Distance fog (exp2 like g.html)
                    let factor = exp2(-in.viewDist * 0.05);
                    color.r *= factor;
                    color.g *= factor;
                    color.b *= factor;

                    // Debug mode - visualize normals and UV coordinates
                    if (u.debugMode > 0.5) {
                        // Show normals as RGB colors (remap from [-1,1] to [0,1])
                        // Red=X, Green=Y, Blue=Z
                        let normalColor = (in.normal + vec3<f32>(1.0)) * 0.5;

                        // Show UV in the alpha/brightness
                        // Or blend with UV visualization
                        color = vec4<f32>(normalColor, 1.0);
                    }

                    // Triangle visualization mode
                    if (u.showTriangles > 0.5) {
                        // Generate unique color per triangle using triangle ID
                        let id = in.triangleID;

                        // Simple hash function to generate varied colors from triangle ID
                        let h1 = fract(sin(id * 12.9898) * 43758.5453);
                        let h2 = fract(sin(id * 78.233) * 28451.3791);
                        let h3 = fract(sin(id * 45.164) * 19283.4567);

                        // Create distinct colors with good saturation
                        color = vec4<f32>(
                            h1 * 0.7 + 0.3,
                            h2 * 0.7 + 0.3,
                            h3 * 0.7 + 0.3,
                            1.0
                        );
                    }

                    return color;
                }
            `;

            const overlayVsSource = `
                struct VertexInput {
                    @location(0) position: vec2<f32>,
                };

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) frag_position: vec2<f32>,
                };

                @vertex
                fn vertex_main(input: VertexInput) -> VertexOutput {
                    var output: VertexOutput;
                    output.position = vec4<f32>(input.position, 0.0, 1.0);
                    output.frag_position = input.position * 0.5 + vec2<f32>(0.5, 0.5);
                    return output;
                }
            `;

            const overlayFsSource = `
                struct Params {
                    viewportAndOrigin: vec4<f32>,
                    sizeAndMetrics: vec4<f32>,
                    spacingAndPadding: vec4<f32>,
                    mapRect: vec4<f32>,
                    mapMeta: vec4<f32>,
                    playerInfo: vec4<f32>,
                };

                @group(0) @binding(0)
                var<uniform> params: Params;

                @group(0) @binding(1)
                var<storage, read> textData: array<u32>;

                @group(0) @binding(2)
                var<storage, read> mapData: array<u32>;

                const FONT_GLYPHS = array<array<u32, 8>, 256>(
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x18u, 0x3cu, 0x3cu, 0x18u, 0x18u, 0x00u, 0x18u, 0x00u),
                            array<u32, 8>(0x36u, 0x36u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x36u, 0x36u, 0x7fu, 0x36u, 0x7fu, 0x36u, 0x36u, 0x00u),
                            array<u32, 8>(0x0cu, 0x3eu, 0x03u, 0x1eu, 0x30u, 0x1fu, 0x0cu, 0x00u),
                            array<u32, 8>(0x00u, 0x63u, 0x33u, 0x18u, 0x0cu, 0x66u, 0x63u, 0x00u),
                            array<u32, 8>(0x1cu, 0x36u, 0x1cu, 0x6eu, 0x3bu, 0x33u, 0x6eu, 0x00u),
                            array<u32, 8>(0x06u, 0x06u, 0x03u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x18u, 0x0cu, 0x06u, 0x06u, 0x06u, 0x0cu, 0x18u, 0x00u),
                            array<u32, 8>(0x06u, 0x0cu, 0x18u, 0x18u, 0x18u, 0x0cu, 0x06u, 0x00u),
                            array<u32, 8>(0x00u, 0x66u, 0x3cu, 0xffu, 0x3cu, 0x66u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x0cu, 0x0cu, 0x3fu, 0x0cu, 0x0cu, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x0cu, 0x0cu, 0x06u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x3fu, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x0cu, 0x0cu, 0x00u),
                            array<u32, 8>(0x60u, 0x30u, 0x18u, 0x0cu, 0x06u, 0x03u, 0x01u, 0x00u),
                            array<u32, 8>(0x3eu, 0x63u, 0x73u, 0x7bu, 0x6fu, 0x67u, 0x3eu, 0x00u),
                            array<u32, 8>(0x0cu, 0x0eu, 0x0cu, 0x0cu, 0x0cu, 0x0cu, 0x3fu, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x30u, 0x1cu, 0x06u, 0x33u, 0x3fu, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x30u, 0x1cu, 0x30u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x38u, 0x3cu, 0x36u, 0x33u, 0x7fu, 0x30u, 0x78u, 0x00u),
                            array<u32, 8>(0x3fu, 0x03u, 0x1fu, 0x30u, 0x30u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x1cu, 0x06u, 0x03u, 0x1fu, 0x33u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x3fu, 0x33u, 0x30u, 0x18u, 0x0cu, 0x0cu, 0x0cu, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x33u, 0x1eu, 0x33u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x33u, 0x3eu, 0x30u, 0x18u, 0x0eu, 0x00u),
                            array<u32, 8>(0x00u, 0x0cu, 0x0cu, 0x00u, 0x00u, 0x0cu, 0x0cu, 0x00u),
                            array<u32, 8>(0x00u, 0x0cu, 0x0cu, 0x00u, 0x00u, 0x0cu, 0x0cu, 0x06u),
                            array<u32, 8>(0x18u, 0x0cu, 0x06u, 0x03u, 0x06u, 0x0cu, 0x18u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x3fu, 0x00u, 0x00u, 0x3fu, 0x00u, 0x00u),
                            array<u32, 8>(0x06u, 0x0cu, 0x18u, 0x30u, 0x18u, 0x0cu, 0x06u, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x30u, 0x18u, 0x0cu, 0x00u, 0x0cu, 0x00u),
                            array<u32, 8>(0x3eu, 0x63u, 0x7bu, 0x7bu, 0x7bu, 0x03u, 0x1eu, 0x00u),
                            array<u32, 8>(0x0cu, 0x1eu, 0x33u, 0x33u, 0x3fu, 0x33u, 0x33u, 0x00u),
                            array<u32, 8>(0x3fu, 0x66u, 0x66u, 0x3eu, 0x66u, 0x66u, 0x3fu, 0x00u),
                            array<u32, 8>(0x3cu, 0x66u, 0x03u, 0x03u, 0x03u, 0x66u, 0x3cu, 0x00u),
                            array<u32, 8>(0x1fu, 0x36u, 0x66u, 0x66u, 0x66u, 0x36u, 0x1fu, 0x00u),
                            array<u32, 8>(0x7fu, 0x46u, 0x16u, 0x1eu, 0x16u, 0x46u, 0x7fu, 0x00u),
                            array<u32, 8>(0x7fu, 0x46u, 0x16u, 0x1eu, 0x16u, 0x06u, 0x0fu, 0x00u),
                            array<u32, 8>(0x3cu, 0x66u, 0x03u, 0x03u, 0x73u, 0x66u, 0x7cu, 0x00u),
                            array<u32, 8>(0x33u, 0x33u, 0x33u, 0x3fu, 0x33u, 0x33u, 0x33u, 0x00u),
                            array<u32, 8>(0x1eu, 0x0cu, 0x0cu, 0x0cu, 0x0cu, 0x0cu, 0x1eu, 0x00u),
                            array<u32, 8>(0x78u, 0x30u, 0x30u, 0x30u, 0x33u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x67u, 0x66u, 0x36u, 0x1eu, 0x36u, 0x66u, 0x67u, 0x00u),
                            array<u32, 8>(0x0fu, 0x06u, 0x06u, 0x06u, 0x46u, 0x66u, 0x7fu, 0x00u),
                            array<u32, 8>(0x63u, 0x77u, 0x7fu, 0x7fu, 0x6bu, 0x63u, 0x63u, 0x00u),
                            array<u32, 8>(0x63u, 0x67u, 0x6fu, 0x7bu, 0x73u, 0x63u, 0x63u, 0x00u),
                            array<u32, 8>(0x1cu, 0x36u, 0x63u, 0x63u, 0x63u, 0x36u, 0x1cu, 0x00u),
                            array<u32, 8>(0x3fu, 0x66u, 0x66u, 0x3eu, 0x06u, 0x06u, 0x0fu, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x33u, 0x33u, 0x3bu, 0x1eu, 0x38u, 0x00u),
                            array<u32, 8>(0x3fu, 0x66u, 0x66u, 0x3eu, 0x36u, 0x66u, 0x67u, 0x00u),
                            array<u32, 8>(0x1eu, 0x33u, 0x07u, 0x0eu, 0x38u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x3fu, 0x2du, 0x0cu, 0x0cu, 0x0cu, 0x0cu, 0x1eu, 0x00u),
                            array<u32, 8>(0x33u, 0x33u, 0x33u, 0x33u, 0x33u, 0x33u, 0x3fu, 0x00u),
                            array<u32, 8>(0x33u, 0x33u, 0x33u, 0x33u, 0x33u, 0x1eu, 0x0cu, 0x00u),
                            array<u32, 8>(0x63u, 0x63u, 0x63u, 0x6bu, 0x7fu, 0x77u, 0x63u, 0x00u),
                            array<u32, 8>(0x63u, 0x63u, 0x36u, 0x1cu, 0x1cu, 0x36u, 0x63u, 0x00u),
                            array<u32, 8>(0x33u, 0x33u, 0x33u, 0x1eu, 0x0cu, 0x0cu, 0x1eu, 0x00u),
                            array<u32, 8>(0x7fu, 0x63u, 0x31u, 0x18u, 0x4cu, 0x66u, 0x7fu, 0x00u),
                            array<u32, 8>(0x1eu, 0x06u, 0x06u, 0x06u, 0x06u, 0x06u, 0x1eu, 0x00u),
                            array<u32, 8>(0x03u, 0x06u, 0x0cu, 0x18u, 0x30u, 0x60u, 0x40u, 0x00u),
                            array<u32, 8>(0x1eu, 0x18u, 0x18u, 0x18u, 0x18u, 0x18u, 0x1eu, 0x00u),
                            array<u32, 8>(0x08u, 0x1cu, 0x36u, 0x63u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0xffu),
                            array<u32, 8>(0x0cu, 0x0cu, 0x18u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x1eu, 0x30u, 0x3eu, 0x33u, 0x6eu, 0x00u),
                            array<u32, 8>(0x07u, 0x06u, 0x06u, 0x3eu, 0x66u, 0x66u, 0x3bu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x1eu, 0x33u, 0x03u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x38u, 0x30u, 0x30u, 0x3eu, 0x33u, 0x33u, 0x6eu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x1eu, 0x33u, 0x3fu, 0x03u, 0x1eu, 0x00u),
                            array<u32, 8>(0x1cu, 0x36u, 0x06u, 0x0fu, 0x06u, 0x06u, 0x0fu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x6eu, 0x33u, 0x33u, 0x3eu, 0x30u, 0x1fu),
                            array<u32, 8>(0x07u, 0x06u, 0x36u, 0x6eu, 0x66u, 0x66u, 0x67u, 0x00u),
                            array<u32, 8>(0x0cu, 0x00u, 0x0eu, 0x0cu, 0x0cu, 0x0cu, 0x1eu, 0x00u),
                            array<u32, 8>(0x30u, 0x00u, 0x30u, 0x30u, 0x30u, 0x33u, 0x33u, 0x1eu),
                            array<u32, 8>(0x07u, 0x06u, 0x66u, 0x36u, 0x1eu, 0x36u, 0x67u, 0x00u),
                            array<u32, 8>(0x0eu, 0x0cu, 0x0cu, 0x0cu, 0x0cu, 0x0cu, 0x1eu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x33u, 0x7fu, 0x7fu, 0x6bu, 0x63u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x1fu, 0x33u, 0x33u, 0x33u, 0x33u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x1eu, 0x33u, 0x33u, 0x33u, 0x1eu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x3bu, 0x66u, 0x66u, 0x3eu, 0x06u, 0x0fu),
                            array<u32, 8>(0x00u, 0x00u, 0x6eu, 0x33u, 0x33u, 0x3eu, 0x30u, 0x78u),
                            array<u32, 8>(0x00u, 0x00u, 0x3bu, 0x6eu, 0x66u, 0x06u, 0x0fu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x3eu, 0x03u, 0x1eu, 0x30u, 0x1fu, 0x00u),
                            array<u32, 8>(0x08u, 0x0cu, 0x3eu, 0x0cu, 0x0cu, 0x2cu, 0x18u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x33u, 0x33u, 0x33u, 0x33u, 0x6eu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x33u, 0x33u, 0x33u, 0x1eu, 0x0cu, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x63u, 0x6bu, 0x7fu, 0x7fu, 0x36u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x63u, 0x36u, 0x1cu, 0x36u, 0x63u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x33u, 0x33u, 0x33u, 0x3eu, 0x30u, 0x1fu),
                            array<u32, 8>(0x00u, 0x00u, 0x3fu, 0x19u, 0x0cu, 0x26u, 0x3fu, 0x00u),
                            array<u32, 8>(0x38u, 0x0cu, 0x0cu, 0x07u, 0x0cu, 0x0cu, 0x38u, 0x00u),
                            array<u32, 8>(0x18u, 0x18u, 0x18u, 0x00u, 0x18u, 0x18u, 0x18u, 0x00u),
                            array<u32, 8>(0x07u, 0x0cu, 0x0cu, 0x38u, 0x0cu, 0x0cu, 0x07u, 0x00u),
                            array<u32, 8>(0x6eu, 0x3bu, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x1cu, 0x36u, 0x36u, 0x1cu, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u),
                            array<u32, 8>(0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u)
                );

                const GLYPH_WIDTH: u32 = 8u;
                const GLYPH_HEIGHT: u32 = 8u;
                const NEWLINE_CODE: u32 = 255u;

                fn glyph_on(char_idx: u32, column: u32, row: u32) -> bool {
                    if (char_idx >= 256u) {
                        return false;
                    }
                    let rowData = FONT_GLYPHS[char_idx][row];
                    return ((rowData >> column) & 1u) == 1u;
                }

                struct FragIn {
                    @location(0) frag_position: vec2<f32>,
                };

                @fragment
                fn fragment_main(fragData: FragIn) -> @location(0) vec4<f32> {
                    let viewportSize = vec2<f32>(params.viewportAndOrigin.x, params.viewportAndOrigin.y);
                    let panelOrigin = vec2<f32>(params.viewportAndOrigin.z, params.viewportAndOrigin.w);
                    let panelSize = vec2<f32>(params.sizeAndMetrics.x, params.sizeAndMetrics.y);
                    let panelMax = panelOrigin + panelSize;

                    let screen = vec2<f32>(
                        fragData.frag_position.x * viewportSize.x,
                        (1.0 - fragData.frag_position.y) * viewportSize.y
                    );

                    let center = viewportSize * 0.5;
                    let crosshairSize = 10.0;
                    let crosshairThickness = 2.0;
                    let innerThickness = 1.0;
                    let dx = abs(screen.x - center.x);
                    let dy = abs(screen.y - center.y);
                    if ((dx < crosshairThickness && dy < crosshairSize) ||
                        (dy < crosshairThickness && dx < crosshairSize)) {
                        if (dx < innerThickness || dy < innerThickness) {
                            return vec4<f32>(1.0, 1.0, 1.0, 1.0);
                        }
                        return vec4<f32>(0.0, 0.0, 0.0, 1.0);
                    }

                    if (screen.x < panelOrigin.x || screen.x > panelMax.x ||
                        screen.y < panelOrigin.y || screen.y > panelMax.y) {
                        return vec4<f32>(0.0, 0.0, 0.0, 0.0);
                    }

                    var color = vec4<f32>(0.0, 1.0, 0.0, 0.3);

                    let textScale = params.sizeAndMetrics.z;
                    let glyphSpacing = u32(params.sizeAndMetrics.w + 0.5);
                    let lineSpacing = u32(params.spacingAndPadding.x + 0.5);
                    let textLength = u32(params.spacingAndPadding.y + 0.5);
                    let padding = vec2<f32>(params.spacingAndPadding.z, params.spacingAndPadding.w);

                    let hudVisible = params.playerInfo.w;
                    if (hudVisible <= 0.5) {
                        return vec4<f32>(0.0, 0.0, 0.0, 0.0);
                    }

                    let textLocal = screen - (panelOrigin + padding);
                    if (textLocal.x >= 0.0 && textLocal.y >= 0.0) {
                        var cursorX: u32 = 0u;
                        var cursorY: u32 = 0u;
                        var idx: u32 = 0u;
                        loop {
                            if (idx >= textLength) { break; }
                            let code = textData[idx];
                            if (code == NEWLINE_CODE) {
                                cursorX = 0u;
                                cursorY = cursorY + GLYPH_HEIGHT + lineSpacing;
                                idx = idx + 1u;
                                continue;
                            }

                            let glyphOrigin = vec2<f32>(
                                f32(cursorX) * textScale,
                                f32(cursorY) * textScale
                            );
                            let glyphLocal = textLocal - glyphOrigin;
                            if (glyphLocal.x >= 0.0 && glyphLocal.y >= 0.0 &&
                                glyphLocal.x < textScale * f32(GLYPH_WIDTH) &&
                                glyphLocal.y < textScale * f32(GLYPH_HEIGHT)) {
                                let column = u32(floor(glyphLocal.x / textScale));
                                let row = u32(floor(glyphLocal.y / textScale));
                                if (column < GLYPH_WIDTH && row < GLYPH_HEIGHT) {
                                    if (glyph_on(code, column, row)) {
                                        return vec4<f32>(1.0, 0.0, 0.0, 1.0);
                                    }
                                }
                            }

                            cursorX = cursorX + GLYPH_WIDTH + glyphSpacing;
                            idx = idx + 1u;
                        }
                    }

                    let mapVisible = params.mapRect.w;
                    if (mapVisible > 0.5) {
                        let mapOrigin = vec2<f32>(params.mapRect.x, params.mapRect.y);
                        let mapScale = params.mapRect.z;
                        let mapMode = params.mapMeta.x;
                        let mapWidth = u32(params.mapMeta.y + 0.5);
                        let mapHeight = u32(params.mapMeta.z + 0.5);
                        let playerPos = vec2<f32>(params.playerInfo.x, params.playerInfo.y);
                        let playerYaw = params.playerInfo.z;
                        let mapSize = vec2<f32>(f32(mapWidth) * mapScale, f32(mapHeight) * mapScale);
                        let mapMax = mapOrigin + mapSize;

                        if (screen.x >= mapOrigin.x && screen.x <= mapMax.x &&
                            screen.y >= mapOrigin.y && screen.y <= mapMax.y) {
                            let local = screen - mapOrigin;
                            var worldPos = vec2<f32>(local.x / mapScale, local.y / mapScale);
                            var playerScreen = mapOrigin + playerPos * mapScale;

                            if (mapMode > 0.5) {
                                let mapCenter = mapOrigin + mapSize * 0.5;
                                let offsetScaled = (screen - mapCenter) / mapScale;
                                let forward = vec2<f32>(cos(playerYaw), sin(playerYaw));
                                let right = vec2<f32>(-forward.y, forward.x);
                                worldPos = playerPos + right * offsetScaled.x - forward * offsetScaled.y;
                                playerScreen = mapCenter;
                            }

                            let tileX = i32(floor(worldPos.x));
                            let tileY = i32(floor(worldPos.y));
                            var tileColor = vec4<f32>(0.02, 0.05, 0.08, 0.6);

                            if (tileX >= 0 && tileX < i32(mapWidth) && tileY >= 0 && tileY < i32(mapHeight)) {
                                let idx = u32(tileY) * mapWidth + u32(tileX);
                                let cell = mapData[idx];
                                if (cell >= 1u) {
                                    tileColor = vec4<f32>(0.7, 0.1, 0.1, 0.9);
                                } else {
                                    tileColor = vec4<f32>(0.1, 0.2, 0.35, 0.7);
                                }
                            }

                            let markerOffset = screen - playerScreen;
                            let markerDist = length(markerOffset);
                            let markerRadius = mapScale * 0.25;
                            if (markerDist < markerRadius) {
                                tileColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);
                            } else {
                                if (mapMode < 0.5) {
                                    let dir = vec2<f32>(cos(playerYaw), sin(playerYaw));
                                    let forward = markerOffset.x * dir.x + markerOffset.y * dir.y;
                                    let perpendicular = abs(markerOffset.x * dir.y - markerOffset.y * dir.x);
                                    if (forward > 0.0 && forward < mapScale && perpendicular < mapScale * 0.18) {
                                        tileColor = vec4<f32>(1.0, 0.8, 0.2, 1.0);
                                    }
                                } else {
                                    let offsetNorm = markerOffset / mapScale;
                                    if (-offsetNorm.y > 0.0 && -offsetNorm.y < 1.0 && abs(offsetNorm.x) < 0.2) {
                                        tileColor = vec4<f32>(1.0, 0.8, 0.2, 1.0);
                                    }
                                }
                            }

                            return tileColor;
                        }
                    }

                    return color;
                }
            `;
            const vsModule = device.createShaderModule({ code: vsSource });
            const fsModule = device.createShaderModule({ code: fsSource });

            // Check for shader compilation errors
            vsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Vertex shader compilation messages:', info.messages);
                }
            });
            fsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.error('[Shader] Fragment shader compilation messages:', info.messages);
                }
            });

            console.log('Shaders compiled successfully');

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                    { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                    { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                ]
            });

            const overlayBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'read-only-storage' } }
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: {
                    module: vsModule,
                    entryPoint: 'vs_main',
                    buffers: [
                        {
                            arrayStride: 12, // vec3<f32>
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
                        },
                        {
                            arrayStride: 8, // vec2<f32>
                            attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }]
                        },
                        {
                            arrayStride: 4, // f32 surfaceType
                            attributes: [{ shaderLocation: 2, offset: 0, format: 'float32' }]
                        },
                        {
                            arrayStride: 4, // f32 triangleID
                            attributes: [{ shaderLocation: 3, offset: 0, format: 'float32' }]
                        },
                        {
                            arrayStride: 12, // vec3<f32> normal
                            attributes: [{ shaderLocation: 4, offset: 0, format: 'float32x3' }]
                        }
                    ]
                },
                fragment: {
                    module: fsModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: {
                    topology: 'triangle-list',
                    cullMode: 'none'  // No backface culling
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth24plus'
                }
            });

            const overlayVsModule = device.createShaderModule({ code: overlayVsSource });
            const overlayFsModule = device.createShaderModule({ code: overlayFsSource });

            const overlayPipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [overlayBindGroupLayout] }),
                vertex: {
                    module: overlayVsModule,
                    entryPoint: 'vertex_main',
                    buffers: [
                        {
                            arrayStride: 8,
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }]
                        }
                    ]
                },
                fragment: {
                    module: overlayFsModule,
                    entryPoint: 'fragment_main',
                    targets: [{
                        format,
                        blend: {
                            color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                            alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                        }
                    }]
                },
                primitive: {
                    topology: 'triangle-strip'
                },
                depthStencil: {
                    depthWriteEnabled: false,
                    depthCompare: 'always',
                    format: 'depth24plus'
                }
            });

            console.log('[Texture] Starting to load all textures...');
            const [wallTextureView, floorTextureView, ceilingTextureView] = await Promise.all([
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/brick_diffuse.jpg', 'wall-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg', 'floor-texture'),
                createTextureFromUrl(device, 'https://threejs.org/examples/textures/lava/cloud.png', 'ceiling-texture')
            ]);
            console.log('[Texture] All textures loaded successfully');
            console.log('[Texture] Wall texture view:', wallTextureView);
            console.log('[Texture] Floor texture view:', floorTextureView);
            console.log('[Texture] Ceiling texture view:', ceilingTextureView);

            const sampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                addressModeU: 'repeat',
                addressModeV: 'repeat'
            });
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: sampler },
                    { binding: 2, resource: wallTextureView },
                    { binding: 3, resource: floorTextureView },
                    { binding: 4, resource: ceilingTextureView }
                ]
            });
            console.log('Pipeline and bind group created successfully');

            const overlayUniformFloatCount = 24;
            const overlayUniformBuffer = device.createBuffer({
                size: overlayUniformFloatCount * 4,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const overlayTextCapacity = 256;
            const overlayTextBuffer = device.createBuffer({
                size: overlayTextCapacity * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });

            const overlayMapBuffer = device.createBuffer({
                size: mapDataArray.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(overlayMapBuffer, 0, mapDataArray);

            const overlayBindGroup = device.createBindGroup({
                layout: overlayBindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: overlayUniformBuffer } },
                    { binding: 1, resource: { buffer: overlayTextBuffer } },
                    { binding: 2, resource: { buffer: overlayMapBuffer } }
                ]
            });

            const overlayVertexData = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                 1,  1,
            ]);

            const overlayVertexBuffer = device.createBuffer({
                size: overlayVertexData.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(overlayVertexBuffer.getMappedRange()).set(overlayVertexData);
            overlayVertexBuffer.unmap();

            const overlayParams = new Float32Array(overlayUniformFloatCount);
            const overlayTextArray = new Uint32Array(overlayTextCapacity);

            const GLYPH_WIDTH = 8;
            const GLYPH_HEIGHT = 8;
            const GLYPH_SPACING = 0;
            const LINE_SPACING = 2;
            const TEXT_SCALE = 4.0;
            const PANEL_PADDING_X = 12.0;
            const PANEL_PADDING_Y = 12.0;
            const PANEL_MARGIN = 10.0;
            const MAP_SCALE = 12.0;
            const MAP_GAP = 12.0;
            const NEWLINE_CODE = 255;
            const SPACE_CODE = 32;

            function charToGlyphCode(ch) {
                const code = ch.charCodeAt(0);
                if (code >= 0 && code < 256) {
                    return code;
                }
                return SPACE_CODE;
            }

            function buildOverlayText(lines) {
                let index = 0;
                let maxLineLength = 0;
                overlayTextArray.fill(SPACE_CODE);
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    maxLineLength = Math.max(maxLineLength, line.length);
                    for (let j = 0; j < line.length && index < overlayTextCapacity; j++) {
                        overlayTextArray[index++] = charToGlyphCode(line[j]);
                    }
                    if (i < lines.length - 1 && index < overlayTextCapacity) {
                        overlayTextArray[index++] = NEWLINE_CODE;
                    }
                }
                return { length: index, maxLineLength };
            }

            // Depth texture
            let depthTexture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
            console.log(`Mesh generated: ${positions.length/3} vertices, ${indices.length/3} triangles`);

            // Camera and controls
            const personHeight = 1.0;
            const turnSpeed = 0.03;
            const mouseSensitivity = 0.002;
            const orientationSmoothing = 0.35;
            let cameraPos = { x: startX, y: personHeight, z: startZ };
            let yaw = startYaw;
            let pitch = 0.0;
            let targetYaw = yaw;
            let targetPitch = pitch;
            const fov = Math.PI / 3;
            const moveSpeed = 0.1;
            const collisionRadius = 0.2;
            const keys = {};
            let mapArray = map;
            let mapVisible = false;
            let mapRelativeMode = false;
            let hudVisible = true;
            let texturesEnabled = false;
            let triangleMode = false;
            let debugMode = false;
            let horizontalMovement = true;
            let lastLoggedTextureState = false;

            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (!e.repeat) {
                    if (key === 'm') {
                        mapVisible = !mapVisible;
                    } else if (key === 'r') {
                        mapRelativeMode = !mapRelativeMode;
                    } else if (key === 't') {
                        texturesEnabled = !texturesEnabled;
                        console.log('[Texture] Textures toggled:', texturesEnabled ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'v') {
                        triangleMode = !triangleMode;
                        console.log('[Visualization] Triangle mode:', triangleMode ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'b') {
                        debugMode = !debugMode;
                        console.log('[Debug] Debug mode:', debugMode ? 'ENABLED' : 'DISABLED');
                    } else if (key === 'h') {
                        hudVisible = !hudVisible;
                    } else if (key === 'f') {
                        horizontalMovement = !horizontalMovement;
                        if (horizontalMovement) {
                            cameraPos.y = personHeight;
                        }
                    }
                }
                keys[key] = true;
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function clampPitch(value) {
                return Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, value));
            }

            function onMouseMove(e) {
                targetYaw += e.movementX * mouseSensitivity;
                targetPitch = clampPitch(targetPitch - e.movementY * mouseSensitivity);
            }

            function isWalkable(x, z) {
                const minX = Math.floor(x - collisionRadius);
                const maxX = Math.floor(x + collisionRadius);
                const minZ = Math.floor(z - collisionRadius);
                const maxZ = Math.floor(z + collisionRadius);

                for (let tz = minZ; tz <= maxZ; tz++) {
                    if (tz < 0 || tz >= mapHeight) {
                        return false;
                    }
                    for (let tx = minX; tx <= maxX; tx++) {
                        if (tx < 0 || tx >= mapWidth || mapArray[tz][tx] !== 0) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function updateCamera() {
                const yawDeltaFromMouse = targetYaw - yaw;
                const pitchDeltaFromMouse = targetPitch - pitch;
                yaw += yawDeltaFromMouse * orientationSmoothing;
                pitch += pitchDeltaFromMouse * orientationSmoothing;

                let arrowUsed = false;
                let yawDelta = 0;
                if (keys['arrowleft']) {
                    yawDelta -= turnSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowright']) {
                    yawDelta += turnSpeed;
                    arrowUsed = true;
                }
                if (yawDelta !== 0) {
                    yaw += yawDelta;
                    targetYaw = yaw;
                }

                let arrowForward = 0;
                if (keys['arrowup']) {
                    arrowForward += moveSpeed;
                    arrowUsed = true;
                }
                if (keys['arrowdown']) {
                    arrowForward -= moveSpeed;
                    arrowUsed = true;
                }

                if (arrowUsed) {
                    pitch = 0;
                    targetPitch = 0;
                }

                pitch = clampPitch(pitch);
                targetPitch = clampPitch(targetPitch);

                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                const cosPitch = Math.cos(pitch);
                const sinPitch = Math.sin(pitch);

                let dx = 0;
                let dy = 0;
                let dz = 0;

                let forwardX, forwardY, forwardZ;
                if (horizontalMovement) {
                    // Person movement: horizontal plane only
                    forwardX = cosYaw;
                    forwardY = 0;
                    forwardZ = sinYaw;
                } else {
                    // Flying mode: arbitrary direction
                    forwardX = cosPitch * cosYaw;
                    forwardY = sinPitch;
                    forwardZ = cosPitch * sinYaw;
                }
                if (keys['w']) {
                    dx += forwardX * moveSpeed;
                    dy += forwardY * moveSpeed;
                    dz += forwardZ * moveSpeed;
                }
                if (keys['s']) {
                    dx -= forwardX * moveSpeed;
                    dy -= forwardY * moveSpeed;
                    dz -= forwardZ * moveSpeed;
                }
                if (keys['a']) {
                    dx += sinYaw * moveSpeed;
                    dz -= cosYaw * moveSpeed;
                }
                if (keys['d']) {
                    dx -= sinYaw * moveSpeed;
                    dz += cosYaw * moveSpeed;
                }

                if (arrowForward !== 0) {
                    dx += cosYaw * arrowForward;
                    dz += sinYaw * arrowForward;
                }

                const baseY = arrowUsed ? personHeight : cameraPos.y;
                const newY = baseY + dy;
                const candidateX = cameraPos.x + dx;
                const candidateZ = cameraPos.z + dz;

                if (isWalkable(candidateX, cameraPos.z)) {
                    cameraPos.x = candidateX;
                }
                if (isWalkable(cameraPos.x, candidateZ)) {
                    cameraPos.z = candidateZ;
                }
                cameraPos.y = Math.min(Math.max(newY, 0.1), wallHeight - 0.1);
                if (arrowUsed) {
                    cameraPos.y = personHeight;
                }
            }

            // Render loop
            let frameCount = 0;
            let lastFrameTime = performance.now();
            let fps = 0;
            let fpsUpdateTime = performance.now();
            let fpsFrameCount = 0;

            // Performance timing
            let avgFrameTime = 0;
            let avgJsTime = 0;
            let avgGpuCopyTime = 0;
            let avgGpuRenderTime = 0;
            const PERF_SMOOTHING = 0.9; // Exponential moving average

            function render() {
                const frameStartTime = performance.now();

                updateCamera();

                // FPS calc
                const currentTime = performance.now();
                fpsFrameCount++;
                if (currentTime - fpsUpdateTime >= 500) {
                    fps = Math.round(fpsFrameCount * 1000 / (currentTime - fpsUpdateTime));
                    fpsFrameCount = 0;
                    fpsUpdateTime = currentTime;
                }

                // Update uniforms with individual floats
                const data = new Float32Array(uniformFloatCount);
                data[0] = cameraPos.x;       // cameraPosX
                data[1] = cameraPos.y;       // cameraPosY
                data[2] = cameraPos.z;       // cameraPosZ
                data[3] = yaw;
                data[4] = pitch;
                data[5] = fov;
                data[6] = canvas.width;      // viewWidth
                data[7] = canvas.height;     // viewHeight
                data[8] = texturesEnabled ? 1 : 0;
                data[9] = triangleMode ? 1 : 0; // showTriangles
                data[10] = debugMode ? 1 : 0; // debugMode
                data[11] = 0;

                if (texturesEnabled !== lastLoggedTextureState) {
                    console.log('[Texture] Uniform buffer useTextures value:', data[8]);
                    lastLoggedTextureState = texturesEnabled;
                }

                device.queue.writeBuffer(uniformBuffer, 0, data);

                const jsEndTime = performance.now();
                const jsTime = jsEndTime - frameStartTime;

                const directionNames = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
                const directionIndex = Math.round(((yaw / Math.PI * 4) + 8) % 8);
                const direction = directionNames[directionIndex];

                const lines = [
                    `FPS: ${fps}  Frame: ${avgFrameTime.toFixed(2)}ms`,
                    `JS: ${avgJsTime.toFixed(2)}ms  GPU Copy: ${avgGpuCopyTime.toFixed(2)}ms  GPU Render: ${avgGpuRenderTime.toFixed(2)}ms`,
                    `Pos: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})`,
                    `Dir: ${direction} (yaw: ${(yaw * 180 / Math.PI).toFixed(1)}°, pitch: ${(pitch * 180 / Math.PI).toFixed(1)}°)`,
                    `Movement: ${horizontalMovement ? 'Person' : 'Flying'} (f)  HUD: ${hudVisible ? 'ON' : 'OFF'} (h)  Map: ${mapVisible ? 'ON' : 'OFF'} (m/r)`,
                    `Textures: ${texturesEnabled ? 'ON' : 'OFF'} (t)  Triangles: ${triangleMode ? 'ON' : 'OFF'} (v)  Debug: ${debugMode ? 'ON' : 'OFF'} (b)`
                ];

                const { length: textLength, maxLineLength } = buildOverlayText(lines);
                const lineCount = lines.length;
                const charAdvance = GLYPH_WIDTH * TEXT_SCALE;
                const textWidth = maxLineLength * charAdvance;
                const textHeight = lineCount * GLYPH_HEIGHT * TEXT_SCALE + Math.max(0, (lineCount - 1)) * LINE_SPACING * TEXT_SCALE;
                const panelOriginX = PANEL_MARGIN;
                const panelOriginY = PANEL_MARGIN;
                const mapWidthPixels = mapWidth * MAP_SCALE;
                const mapHeightPixels = mapHeight * MAP_SCALE;
                let panelWidth = PANEL_PADDING_X * 2 + textWidth;
                if (mapVisible) {
                    panelWidth = Math.max(panelWidth, PANEL_PADDING_X * 2 + mapWidthPixels);
                }
                let panelHeight = PANEL_PADDING_Y * 2 + textHeight;
                const mapOriginX = panelOriginX + PANEL_PADDING_X;
                const mapOriginY = panelOriginY + PANEL_PADDING_Y + textHeight + (mapVisible ? MAP_GAP : 0);
                if (mapVisible) {
                    panelHeight += MAP_GAP + mapHeightPixels;
                }

                overlayParams[0] = canvas.width;
                overlayParams[1] = canvas.height;
                overlayParams[2] = panelOriginX;
                overlayParams[3] = panelOriginY;
                overlayParams[4] = panelWidth;
                overlayParams[5] = panelHeight;
                overlayParams[6] = TEXT_SCALE;
                overlayParams[7] = GLYPH_SPACING;
                overlayParams[8] = LINE_SPACING;
                overlayParams[9] = textLength;
                overlayParams[10] = PANEL_PADDING_X;
                overlayParams[11] = PANEL_PADDING_Y;
                overlayParams[12] = mapOriginX;
                overlayParams[13] = mapOriginY;
                overlayParams[14] = MAP_SCALE;
                overlayParams[15] = mapVisible ? 1 : 0;
                overlayParams[16] = mapRelativeMode ? 1 : 0;
                overlayParams[17] = mapWidth;
                overlayParams[18] = mapHeight;
                overlayParams[19] = 0;
                overlayParams[20] = cameraPos.x;
                overlayParams[21] = cameraPos.z;
                overlayParams[22] = yaw;
                overlayParams[23] = hudVisible ? 1 : 0;

                device.queue.writeBuffer(overlayUniformBuffer, 0, overlayParams);
                device.queue.writeBuffer(overlayTextBuffer, 0, overlayTextArray);

                const gpuCopyEndTime = performance.now();
                const gpuCopyTime = gpuCopyEndTime - jsEndTime;

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 }, // Sky blue clear
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store'
                    }
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, positionBuffer);
                renderPass.setVertexBuffer(1, uvBuffer);
                renderPass.setVertexBuffer(2, surfaceTypeBuffer);
                renderPass.setVertexBuffer(3, triangleIDBuffer);
                renderPass.setVertexBuffer(4, normalBuffer);
                renderPass.setIndexBuffer(indexBuffer, 'uint16');
                renderPass.drawIndexed(indices.length);

                renderPass.setPipeline(overlayPipeline);
                renderPass.setBindGroup(0, overlayBindGroup);
                renderPass.setVertexBuffer(0, overlayVertexBuffer);
                renderPass.draw(4);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                const gpuRenderEndTime = performance.now();
                const gpuRenderTime = gpuRenderEndTime - gpuCopyEndTime;
                const totalFrameTime = gpuRenderEndTime - frameStartTime;

                // Update smoothed averages
                avgFrameTime = avgFrameTime * PERF_SMOOTHING + totalFrameTime * (1 - PERF_SMOOTHING);
                avgJsTime = avgJsTime * PERF_SMOOTHING + jsTime * (1 - PERF_SMOOTHING);
                avgGpuCopyTime = avgGpuCopyTime * PERF_SMOOTHING + gpuCopyTime * (1 - PERF_SMOOTHING);
                avgGpuRenderTime = avgGpuRenderTime * PERF_SMOOTHING + gpuRenderTime * (1 - PERF_SMOOTHING);

                requestAnimationFrame(render);
            }

            render();

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Recreate depth texture
                depthTexture.destroy();
                depthTexture = device.createTexture({
                    size: [canvas.width, canvas.height, 1],
                    format: 'depth24plus',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                });
            });
        }

        init();
    </script>
</body>
</html>
