use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process;

use naga::back::{hlsl, msl, spv};
use naga::valid::{Capabilities, ValidationFlags, Validator};
use naga::{AddressSpace, ResourceBinding, StorageAccess, TypeInner};

const NAGA_VERSION: &str = env!("CARGO_PKG_VERSION");

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        eprintln!("Usage: {} <input.wgsl>", args[0]);
        eprintln!("Generates MSL, HLSL, and SPIR-V to respective output directories");
        process::exit(1);
    }

    let input_path = PathBuf::from(&args[1]);

    if let Err(e) = compile_shader(&input_path) {
        eprintln!("Error: {}", e);
        process::exit(1);
    }
}

fn compile_shader(input_path: &Path) -> Result<(), String> {
    // Determine output paths
    let file_stem = input_path
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or("Invalid filename")?;

    // Assume input is in shaders/WGSL/, outputs go to shaders/{MSL,HLSL,SPIRV}/
    let shader_root = input_path
        .parent()
        .and_then(|p| p.parent())
        .ok_or("Invalid shader path structure")?;

    let msl_path = shader_root.join("MSL").join(format!("{}.msl", file_stem));
    let hlsl_path = shader_root.join("HLSL").join(format!("{}.hlsl", file_stem));
    let spirv_path = shader_root.join("SPIRV").join(format!("{}.spv", file_stem));
    let spirv_meta_path = shader_root.join("SPIRV").join(format!("{}.spv.txt", file_stem));

    // Read and parse WGSL
    let wgsl_source = fs::read_to_string(input_path)
        .map_err(|e| format!("Failed to read {}: {}", input_path.display(), e))?;

    let module = naga::front::wgsl::parse_str(&wgsl_source)
        .map_err(|e| format!("WGSL parse error: {}", e))?;

    // Validate module
    let mut validator = Validator::new(ValidationFlags::all(), Capabilities::all());
    let module_info = validator
        .validate(&module)
        .map_err(|e| format!("Validation error: {}", e))?;

    // Generate header comment
    let source_path_str = input_path
        .strip_prefix(shader_root)
        .unwrap_or(input_path)
        .display()
        .to_string();

    let header_comment = format!(
        "AUTO-GENERATED from {}\nGenerated by: shader_compiler (Naga {})\nDO NOT EDIT - Modify the source WGSL file instead",
        source_path_str, NAGA_VERSION
    );

    // Determine entrypoint name from filename
    let entrypoint_name = determine_entrypoint_name(file_stem);

    println!("Compiling {} -> MSL, HLSL, SPIR-V", input_path.display());

    // Generate MSL
    generate_msl(&module, &module_info, &msl_path, &header_comment, entrypoint_name)?;

    // Generate HLSL
    generate_hlsl(&module, &module_info, &hlsl_path, &header_comment)?;

    // Generate SPIR-V
    generate_spirv(&module, &module_info, &spirv_path, &spirv_meta_path, &header_comment)?;

    Ok(())
}

fn generate_msl(
    module: &naga::Module,
    module_info: &naga::valid::ModuleInfo,
    output_path: &Path,
    header_comment: &str,
    entrypoint_name: Option<&'static str>,
) -> Result<(), String> {
    // Build binding map for all entry points
    let mut per_entry_point_map = BTreeMap::new();

    for (ep_index, entry_point) in module.entry_points.iter().enumerate() {
        let mut resources = BTreeMap::new();
        let ep_info = module_info.get_entry_point(ep_index);

        // For each global variable in the module
        for (handle, global_var) in module.global_variables.iter() {
            // Check if this variable is used by this entry point
            if !ep_info[handle].is_empty() {
                // If the variable has a binding
                if let Some(ref binding) = global_var.binding {
                    let resource_binding = ResourceBinding {
                        group: binding.group,
                        binding: binding.binding,
                    };

                    let mut bind_target = msl::BindTarget::default();

                    match global_var.space {
                        AddressSpace::Uniform => {
                            bind_target.buffer = Some(binding.binding as u8);
                        }
                        AddressSpace::Storage { access } => {
                            bind_target.buffer = Some(binding.binding as u8);
                            bind_target.mutable = access.contains(StorageAccess::STORE);
                        }
                        AddressSpace::Handle => {
                            let ty = &module.types[global_var.ty];
                            match ty.inner {
                                TypeInner::Sampler { .. } => {
                                    bind_target.sampler = Some(msl::BindSamplerTarget::Resource(
                                        binding.binding as u8,
                                    ));
                                }
                                TypeInner::Image { .. } => {
                                    bind_target.texture = Some(binding.binding as u8);
                                }
                                _ => continue,
                            }
                        }
                        _ => continue,
                    }

                    // Skip targets that didn't map to any resource slot
                    if bind_target.buffer.is_none()
                        && bind_target.texture.is_none()
                        && bind_target.sampler.is_none()
                    {
                        continue;
                    }

                    resources.insert(resource_binding, bind_target);
                }
            }
        }

        let entry_point_resources = msl::EntryPointResources {
            resources,
            push_constant_buffer: None,
            sizes_buffer: None,
        };

        per_entry_point_map.insert(entry_point.name.clone(), entry_point_resources);
    }

    // Configure MSL options
    let options = msl::Options {
        lang_version: (1, 0),
        per_entry_point_map,
        inline_samplers: Vec::new(),
        spirv_cross_compatibility: false,
        fake_missing_bindings: false,
        bounds_check_policies: Default::default(),
        zero_initialize_workgroup_memory: true,
        force_loop_bounding: false,
    };

    let pipeline_options = msl::PipelineOptions {
        entry_point: None,
        allow_and_force_point_size: false,
        vertex_pulling_transform: false,
        vertex_buffer_mappings: Default::default(),
    };

    let (msl_source, _) = msl::write_string(module, module_info, &options, &pipeline_options)
        .map_err(|e| format!("MSL generation error: {:?}", e))?;

    // Rename entrypoint if needed
    let msl_final = if let Some(new_name) = entrypoint_name {
        rename_entrypoint(&msl_source, "main_", new_name)
    } else {
        msl_source
    };

    // Add header comment (each line prefixed with //)
    let header_lines: Vec<_> = header_comment.lines().map(|line| format!("// {}", line)).collect();
    let output = format!("{}\n\n{}", header_lines.join("\n"), msl_final);

    fs::write(output_path, output)
        .map_err(|e| format!("Failed to write {}: {}", output_path.display(), e))?;

    Ok(())
}

fn generate_hlsl(
    module: &naga::Module,
    module_info: &naga::valid::ModuleInfo,
    output_path: &Path,
    header_comment: &str,
) -> Result<(), String> {
    // Build binding map for D3D12 descriptor spaces
    // SDL3 uses: space1 for vertex shader resources, space3 for fragment shader resources
    let mut binding_map = BTreeMap::new();
    
    for (ep_index, entry_point) in module.entry_points.iter().enumerate() {
        let ep_info = module_info.get_entry_point(ep_index);
        
        // Determine space based on shader stage
        // SDL3 uses: space1 for vertex, space3 for fragment
        let space = match entry_point.stage {
            naga::ShaderStage::Vertex => 1,
            naga::ShaderStage::Fragment => 3,
            naga::ShaderStage::Compute => 2,
            naga::ShaderStage::Task => 4,
            naga::ShaderStage::Mesh => 5,
        };
        
        // Map all resources used by this entry point to the appropriate space
        for (handle, global_var) in module.global_variables.iter() {
            if !ep_info[handle].is_empty() {
                if let Some(ref binding) = global_var.binding {
                    let resource_binding = ResourceBinding {
                        group: binding.group,
                        binding: binding.binding,
                    };
                    
                    // Map to D3D12 register and space
                    let bind_target = hlsl::BindTarget {
                        space,
                        register: binding.binding,
                        binding_array_size: None,
                        dynamic_storage_buffer_offsets_index: None,
                        restrict_indexing: true,
                    };
                    
                    binding_map.insert(resource_binding, bind_target);
                }
            }
        }
    }

    // Configure HLSL options for D3D12 (Shader Model 6.0)
    let options = hlsl::Options {
        shader_model: hlsl::ShaderModel::V6_0,
        binding_map,
        fake_missing_bindings: false,
        special_constants_binding: None,
        push_constants_target: None,
        zero_initialize_workgroup_memory: true,
        force_loop_bounding: false,
        dynamic_storage_buffer_offsets_targets: Default::default(),
        sampler_heap_target: Default::default(),
        sampler_buffer_binding_map: Default::default(),
        restrict_indexing: true,
    };

    let pipeline_options = hlsl::PipelineOptions {
        entry_point: None,
    };

    // Generate HLSL using Writer
    let mut hlsl_source = String::new();
    let mut writer = hlsl::Writer::new(&mut hlsl_source, &options, &pipeline_options);
    writer
        .write(module, module_info, None)
        .map_err(|e| format!("HLSL generation error: {:?}", e))?;

    // Post-process HLSL for SDL3 D3D12 compatibility
    let hlsl_fixed = fix_hlsl_for_sdl3(&hlsl_source);

    // Add header comment (each line prefixed with //)
    let header_lines: Vec<_> = header_comment.lines().map(|line| format!("// {}", line)).collect();
    let output = format!("{}\n\n{}", header_lines.join("\n"), hlsl_fixed);

    fs::write(output_path, output)
        .map_err(|e| format!("Failed to write {}: {}", output_path.display(), e))?;

    Ok(())
}

fn fix_hlsl_for_sdl3(hlsl_source: &str) -> String {
    let mut result = hlsl_source.to_string();
    
    // 1. Replace LOC0-9 semantics with TEXCOORD0-9 (SDL3 expects TEXCOORD)
    for i in 0..10 {
        result = result.replace(&format!(" : LOC{}", i), &format!(" : TEXCOORD{}", i));
    }
    
    // 2. Fix cbuffer syntax from Naga's nested form to flattened form
    // Pattern: cbuffer uniforms : register(...) { StructName uniforms; }
    // Target: cbuffer StructName : register(...) { struct fields }
    result = fix_cbuffer_syntax(&result);
    
    // 3. Remove "uniforms." prefix since cbuffer fields are now directly accessible
    result = result.replace("uniforms.mvp", "mvp");
    result = result.replace("uniforms.cameraPos", "cameraPos");
    result = result.replace("uniforms.fogColor", "fogColor");
    
    // 4. Remove unnecessary wrapper structs and simplify main function
    // Naga generates VertexOutput_main wrapper structs that aren't needed for SDL3
    result = simplify_stage_io(&result);
    
    result
}

fn fix_cbuffer_syntax(hlsl: &str) -> String {
    let mut result = hlsl.to_string();
    
    // Find all struct definitions first to extract their fields
    let mut struct_fields = std::collections::HashMap::new();
    
    for line in hlsl.lines() {
        let trimmed = line.trim();
        // Look for struct definitions
        if trimmed.starts_with("struct ") && trimmed.ends_with(" {") {
            let struct_name = trimmed
                .strip_prefix("struct ")
                .and_then(|s| s.strip_suffix(" {"))
                .unwrap_or("");
            
            // Collect fields for this struct
            let mut in_struct = false;
            let mut fields = Vec::new();
            let mut brace_count = 0;
            
            for scan_line in hlsl.lines() {
                let scan_trimmed = scan_line.trim();
                if scan_trimmed == format!("struct {} {{", struct_name) {
                    in_struct = true;
                    brace_count = 1;
                    continue;
                }
                if in_struct {
                    if scan_trimmed.contains('{') {
                        brace_count += scan_trimmed.matches('{').count();
                    }
                    if scan_trimmed.contains('}') {
                        brace_count -= scan_trimmed.matches('}').count();
                        if brace_count == 0 {
                            break;
                        }
                    }
                    if brace_count == 1 && !scan_trimmed.is_empty() && scan_trimmed != "}" {
                        fields.push(scan_line.to_string());
                    }
                }
            }
            
            if !fields.is_empty() {
                struct_fields.insert(struct_name.to_string(), fields);
            }
        }
    }
    
    // Now fix cbuffer declarations
    // Pattern: "cbuffer uniforms : register(b0, spaceN) { StructName uniforms; }"
    for (struct_name, fields) in &struct_fields {
        let old_pattern = format!("cbuffer uniforms : register(b0, space");
        if let Some(start_pos) = result.find(&old_pattern) {
            // Find the end of this cbuffer declaration
            if let Some(end_pos) = result[start_pos..].find('}') {
                let cbuffer_section = &result[start_pos..start_pos + end_pos + 1];
                
                // Extract the register clause
                if let Some(reg_start) = cbuffer_section.find("register(") {
                    if let Some(reg_end) = cbuffer_section[reg_start..].find(')') {
                        let register_clause = &cbuffer_section[reg_start..reg_start + reg_end + 1];
                        
                        // Check if this cbuffer uses our struct
                        if cbuffer_section.contains(struct_name) {
                            // Build the replacement
                            let mut replacement = format!("cbuffer {} : {} {{\n", struct_name, register_clause);
                            for field in fields {
                                replacement.push_str(field);
                                replacement.push('\n');
                            }
                            replacement.push_str("}");
                            
                            result = result.replace(cbuffer_section, &replacement);
                        }
                    }
                }
            }
        }
    }
    
    result
}

fn simplify_stage_io(hlsl: &str) -> String {
    // For now, keep the wrapper structs as Naga generates them
    // They should still work with SDL3, even if not ideal
    // Future enhancement: detect and simplify these patterns
    hlsl.to_string()
}

fn generate_spirv(
    module: &naga::Module,
    module_info: &naga::valid::ModuleInfo,
    output_path: &Path,
    meta_path: &Path,
    header_comment: &str,
) -> Result<(), String> {
    // Configure SPIR-V options
    let options = spv::Options {
        lang_version: (1, 0),
        flags: spv::WriterFlags::DEBUG | spv::WriterFlags::ADJUST_COORDINATE_SPACE,
        capabilities: None,
        bounds_check_policies: Default::default(),
        zero_initialize_workgroup_memory: spv::ZeroInitializeWorkgroupMemoryMode::Polyfill,
        force_loop_bounding: false,
        binding_map: Default::default(),
        debug_info: None,
    };

    // Generate SPIR-V binary
    let spirv_binary = spv::write_vec(module, module_info, &options, None)
        .map_err(|e| format!("SPIR-V generation error: {:?}", e))?;

    // Write binary file
    let binary_bytes: Vec<u8> = spirv_binary
        .iter()
        .flat_map(|word| word.to_le_bytes())
        .collect();

    fs::write(output_path, binary_bytes)
        .map_err(|e| format!("Failed to write {}: {}", output_path.display(), e))?;

    // Write metadata file
    let meta_content = format!(
        "{}\nSPIR-V binary file\nWords: {}\nBytes: {}\n",
        header_comment,
        spirv_binary.len(),
        spirv_binary.len() * 4
    );

    fs::write(meta_path, meta_content)
        .map_err(|e| format!("Failed to write {}: {}", meta_path.display(), e))?;

    Ok(())
}

fn determine_entrypoint_name(file_stem: &str) -> Option<&'static str> {
    // Determine target entrypoint name based on filename convention
    if file_stem.ends_with("_vertex") {
        if file_stem.contains("_overlay_") {
            Some("overlay_vertex")
        } else {
            Some("main_vertex")
        }
    } else if file_stem.ends_with("_fragment") {
        if file_stem.contains("_overlay_") {
            Some("overlay_fragment")
        } else {
            Some("main_fragment")
        }
    } else {
        None
    }
}

fn rename_entrypoint(msl_source: &str, old_name: &str, new_name: &str) -> String {
    // Replace function definition
    let vertex_pattern = format!("vertex main_Output {}(", old_name);
    let fragment_pattern = format!("fragment main_Output {}(", old_name);

    let result = msl_source.replace(&vertex_pattern, &format!("vertex main_Output {}(", new_name));
    let result = result.replace(&fragment_pattern, &format!("fragment main_Output {}(", new_name));

    result
}
