use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process;

use naga::back::{hlsl, msl, spv};
use naga::valid::{Capabilities, ValidationFlags, Validator};
use naga::{AddressSpace, ResourceBinding, StorageAccess, TypeInner};

const NAGA_VERSION: &str = env!("CARGO_PKG_VERSION");

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        eprintln!("Usage: {} <input.wgsl>", args[0]);
        eprintln!("Generates MSL, HLSL, and SPIR-V to respective output directories");
        process::exit(1);
    }

    let input_path = PathBuf::from(&args[1]);

    if let Err(e) = compile_shader(&input_path) {
        eprintln!("Error: {}", e);
        process::exit(1);
    }
}

fn compile_shader(input_path: &Path) -> Result<(), String> {
    // Determine output paths
    let file_stem = input_path
        .file_stem()
        .and_then(|s| s.to_str())
        .ok_or("Invalid filename")?;

    // Assume input is in shaders/WGSL/, outputs go to shaders/{MSL,HLSL,SPIRV}/
    let shader_root = input_path
        .parent()
        .and_then(|p| p.parent())
        .ok_or("Invalid shader path structure")?;

    let msl_path = shader_root.join("MSL").join(format!("{}.msl", file_stem));
    let hlsl_path = shader_root.join("HLSL").join(format!("{}.hlsl", file_stem));
    let spirv_path = shader_root.join("SPIRV").join(format!("{}.spv", file_stem));
    let spirv_meta_path = shader_root.join("SPIRV").join(format!("{}.spv.txt", file_stem));

    // Read and parse WGSL
    let wgsl_source = fs::read_to_string(input_path)
        .map_err(|e| format!("Failed to read {}: {}", input_path.display(), e))?;

    let module = naga::front::wgsl::parse_str(&wgsl_source)
        .map_err(|e| format!("WGSL parse error: {}", e))?;

    // Validate module
    let mut validator = Validator::new(ValidationFlags::all(), Capabilities::all());
    let module_info = validator
        .validate(&module)
        .map_err(|e| format!("Validation error: {}", e))?;

    // Generate header comment
    let source_path_str = input_path
        .strip_prefix(shader_root)
        .unwrap_or(input_path)
        .display()
        .to_string()
        .replace('\\', "/");  // Use forward slashes on all platforms

    let header_comment = format!(
        "AUTO-GENERATED from {}\nGenerated by: shader_compiler (Naga {})\nDO NOT EDIT - Modify the source WGSL file instead",
        source_path_str, NAGA_VERSION
    );

    println!("Compiling {} -> MSL, HLSL, SPIR-V", input_path.display());

    // Generate MSL
    generate_msl(&module, &module_info, &msl_path, &header_comment)?;

    // Generate HLSL
    generate_hlsl(&module, &module_info, &hlsl_path, &header_comment)?;

    // Generate SPIR-V
    generate_spirv(&module, &module_info, &spirv_path, &spirv_meta_path, &header_comment)?;

    Ok(())
}

fn generate_msl(
    module: &naga::Module,
    module_info: &naga::valid::ModuleInfo,
    output_path: &Path,
    header_comment: &str,
) -> Result<(), String> {
    // Build binding map for all entry points
    let mut per_entry_point_map = BTreeMap::new();

    for (ep_index, entry_point) in module.entry_points.iter().enumerate() {
        let mut resources = BTreeMap::new();
        let ep_info = module_info.get_entry_point(ep_index);
        let mut buffer_slot: u8 = 0;
        let mut texture_slot: u8 = 0;
        let mut sampler_slot: u8 = 0;

        // For each global variable in the module
        for (handle, global_var) in module.global_variables.iter() {
            // Check if this variable is used by this entry point
            if !ep_info[handle].is_empty() {
                // If the variable has a binding
                if let Some(ref binding) = global_var.binding {
                    let resource_binding = ResourceBinding {
                        group: binding.group,
                        binding: binding.binding,
                    };

                    let mut bind_target = msl::BindTarget::default();

                    match global_var.space {
                        AddressSpace::Uniform => {
                            bind_target.buffer = Some(buffer_slot);
                            buffer_slot = buffer_slot.saturating_add(1);
                        }
                        AddressSpace::Storage { access } => {
                            bind_target.buffer = Some(buffer_slot);
                            buffer_slot = buffer_slot.saturating_add(1);
                            bind_target.mutable = access.contains(StorageAccess::STORE);
                        }
                        AddressSpace::Handle => {
                            let ty = &module.types[global_var.ty];
                            match ty.inner {
                                TypeInner::Sampler { .. } => {
                                    bind_target.sampler = Some(msl::BindSamplerTarget::Resource(
                                        sampler_slot,
                                    ));
                                    sampler_slot = sampler_slot.saturating_add(1);
                                }
                                TypeInner::Image { .. } => {
                                    bind_target.texture = Some(texture_slot);
                                    texture_slot = texture_slot.saturating_add(1);
                                }
                                _ => continue,
                            }
                        }
                        _ => continue,
                    }

                    // Skip targets that didn't map to any resource slot
                    if bind_target.buffer.is_none()
                        && bind_target.texture.is_none()
                        && bind_target.sampler.is_none()
                    {
                        continue;
                    }

                    resources.insert(resource_binding, bind_target);
                }
            }
        }

        let entry_point_resources = msl::EntryPointResources {
            resources,
            push_constant_buffer: None,
            sizes_buffer: None,
        };

        per_entry_point_map.insert(entry_point.name.clone(), entry_point_resources);
    }

    // Configure MSL options
    let options = msl::Options {
        lang_version: (1, 0),
        per_entry_point_map,
        inline_samplers: Vec::new(),
        spirv_cross_compatibility: false,
        fake_missing_bindings: false,
        bounds_check_policies: Default::default(),
        zero_initialize_workgroup_memory: true,
        force_loop_bounding: false,
    };

    let pipeline_options = msl::PipelineOptions {
        entry_point: None,
        allow_and_force_point_size: false,
        vertex_pulling_transform: false,
        vertex_buffer_mappings: Default::default(),
    };

    let (msl_source, _) = msl::write_string(module, module_info, &options, &pipeline_options)
        .map_err(|e| format!("MSL generation error: {:?}", e))?;

    // Naga generates "main_" for MSL - keep it as-is (no post-processing needed)
    let msl_final = msl_source;

    // Add header comment (each line prefixed with //)
    let header_lines: Vec<_> = header_comment.lines().map(|line| format!("// {}", line)).collect();
    let output = format!("{}\n\n{}", header_lines.join("\n"), msl_final);

    fs::write(output_path, output)
        .map_err(|e| format!("Failed to write {}: {}", output_path.display(), e))?;

    Ok(())
}

fn generate_hlsl(
    module: &naga::Module,
    module_info: &naga::valid::ModuleInfo,
    output_path: &Path,
    header_comment: &str,
) -> Result<(), String> {
    // Build binding map for D3D12 descriptor spaces
    // SDL3 uses: space2 for textures/samplers (to avoid conflicts with uniforms in space3)
    let mut binding_map = BTreeMap::new();

    for (ep_index, entry_point) in module.entry_points.iter().enumerate() {
        let ep_info = module_info.get_entry_point(ep_index);

        // Track separate register counters per resource type for this entry point
        let mut texture_register = 0u32;
        let mut sampler_register = 0u32;

        // Collect all bindings for this entry point and sort by binding number
        let mut bindings_to_process: Vec<_> = module.global_variables
            .iter()
            .filter(|(handle, _)| !ep_info[*handle].is_empty())
            .filter_map(|(handle, global_var)| {
                global_var.binding.as_ref().map(|binding| (handle, global_var, binding))
            })
            .collect();

        // Sort by group, then binding number to ensure consistent ordering
        bindings_to_process.sort_by_key(|(_, _, binding)| (binding.group, binding.binding));

        // Map all resources used by this entry point
        for (_handle, global_var, binding) in bindings_to_process {
            let resource_binding = ResourceBinding {
                group: binding.group,
                binding: binding.binding,
            };

            // Determine resource type and assign appropriate register
            let ty = &module.types[global_var.ty];
            let (register, space) = match ty.inner {
                // Textures and images use t-registers in space2
                TypeInner::Image { .. } => {
                    let reg = texture_register;
                    texture_register += 1;
                    (reg, 2) // Use space2 for textures
                }
                // Samplers use s-registers, also in space2
                // Each sampler gets its own sequential s-register
                TypeInner::Sampler { .. } => {
                    let reg = sampler_register;
                    sampler_register += 1;
                    (reg, 2) // Use space2 for samplers (same space as textures)
                }
                // Buffers and uniforms keep their original binding number
                _ => {
                    let space = match entry_point.stage {
                        naga::ShaderStage::Vertex => 1,
                        naga::ShaderStage::Fragment => 3,
                        naga::ShaderStage::Compute => 2,
                        naga::ShaderStage::Task => 4,
                        naga::ShaderStage::Mesh => 5,
                    };
                    (binding.binding, space)
                }
            };

            let bind_target = hlsl::BindTarget {
                space,
                register,
                binding_array_size: None,
                dynamic_storage_buffer_offsets_index: None,
                restrict_indexing: true,
            };

            binding_map.insert(resource_binding, bind_target);
        }
    }

    // Configure HLSL options for D3D12 (Shader Model 6.0)
    let options = hlsl::Options {
        shader_model: hlsl::ShaderModel::V6_0,
        binding_map,
        fake_missing_bindings: true,
        special_constants_binding: None,
        push_constants_target: None,
        zero_initialize_workgroup_memory: true,
        force_loop_bounding: false,
        dynamic_storage_buffer_offsets_targets: Default::default(),
        sampler_heap_target: Default::default(),
        sampler_buffer_binding_map: Default::default(),
        restrict_indexing: true,
    };

    let pipeline_options = hlsl::PipelineOptions {
        entry_point: None,
    };

    // Generate HLSL using Writer
    let mut hlsl_source = String::new();
    let mut writer = hlsl::Writer::new(&mut hlsl_source, &options, &pipeline_options);
    writer
        .write(module, module_info, None)
        .map_err(|e| format!("HLSL generation error: {:?}", e))?;

    // Post-process HLSL for SDL3 D3D12 compatibility
    let mut hlsl_fixed = fix_hlsl_for_sdl3(&hlsl_source);

    // Naga generates "main" for HLSL but "main_" for MSL
    // Rename to "main_" for consistency across all backends
    hlsl_fixed = hlsl_fixed.replace("main(", "main_(");

    // Add header comment (each line prefixed with //)
    let header_lines: Vec<_> = header_comment.lines().map(|line| format!("// {}", line)).collect();
    let output = format!("{}\n\n{}", header_lines.join("\n"), hlsl_fixed);

    fs::write(output_path, output)
        .map_err(|e| format!("Failed to write {}: {}", output_path.display(), e))?;

    Ok(())
}

fn fix_hlsl_for_sdl3(hlsl_source: &str) -> String {
    let mut result = hlsl_source.to_string();

    // 1. Replace LOC0-9 semantics with TEXCOORD0-9 (SDL3 expects TEXCOORD)
    for i in 0..10 {
        result = result.replace(&format!(" : LOC{}", i), &format!(" : TEXCOORD{}", i));
    }

    // 2. Convert Naga sampler heap to direct sampler bindings
    // Naga still generates sampler heap despite binding_map, so we need to fix it
    result = fix_sampler_heap_to_direct(&result);

    // 3. Fix cbuffer syntax from Naga's nested form to flattened form
    // Pattern: cbuffer uniforms : register(...) { StructName uniforms; }
    // Target: cbuffer StructName : register(...) { struct fields }
    result = fix_cbuffer_syntax(&result);

    // 4. Remove "uniforms." prefix since cbuffer fields are now directly accessible
    result = result.replace("uniforms.mvp", "mvp");
    result = result.replace("uniforms.cameraPos", "cameraPos");
    result = result.replace("uniforms.fogColor", "fogColor");

    // 5. Remove unnecessary wrapper structs and simplify main function
    // Naga generates VertexOutput_main wrapper structs that aren't needed for SDL3
    result = simplify_stage_io(&result);

    result
}

fn fix_sampler_heap_to_direct(hlsl: &str) -> String {
    // Naga generates sampler heap pattern for all samplers:
    // SamplerState nagaSamplerHeap[2048]: register(s0, space0);
    // StructuredBuffer<uint> nagaGroup1SamplerIndexArray : register(t1, space255);
    // static const SamplerState floorSampler = nagaSamplerHeap[nagaGroup1SamplerIndexArray[0]];
    // static const SamplerState wallSampler = nagaSamplerHeap[nagaGroup1SamplerIndexArray[1]];
    //
    // Convert to direct bindings that work with DXC:
    // SamplerState floorSampler : register(s0, space2);
    // SamplerState wallSampler : register(s1, space2);

    let result = hlsl.to_string();

    // Check if we have the sampler heap pattern
    if !result.contains("nagaSamplerHeap") {
        return result;  // No heap pattern, return as-is
    }

    // First pass: collect all sampler names and their indices
    let mut samplers = Vec::new();
    for line in result.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("static const SamplerState ") {
            if let Some(name_start) = trimmed.find("SamplerState ") {
                let after_type = &trimmed[name_start + "SamplerState ".len()..];
                if let Some(name_end) = after_type.find(" =") {
                    let sampler_name = &after_type[..name_end];
                    samplers.push(sampler_name.to_string());
                }
            }
        }
    }

    // Second pass: remove heap declarations and convert sampler declarations
    let lines: Vec<&str> = result.lines().collect();
    let mut new_lines = Vec::new();

    for line in lines {
        let trimmed = line.trim();

        // Skip sampler heap and related declarations
        if trimmed.starts_with("SamplerState nagaSamplerHeap") ||
           trimmed.starts_with("SamplerComparisonState nagaComparisonSamplerHeap") ||
           trimmed.starts_with("StructuredBuffer<uint> nagaGroup") {
            continue;
        }

        // Convert static const sampler declarations to direct register bindings
        if trimmed.starts_with("static const SamplerState ") {
            if let Some(name_start) = trimmed.find("SamplerState ") {
                let after_type = &trimmed[name_start + "SamplerState ".len()..];
                if let Some(name_end) = after_type.find(" =") {
                    let sampler_name = &after_type[..name_end];
                    // Find the index of this sampler in our collected list
                    if let Some(index) = samplers.iter().position(|s| s == sampler_name) {
                        new_lines.push(format!("SamplerState {} : register(s{}, space2);", sampler_name, index));
                        continue;
                    }
                }
            }
        }

        new_lines.push(line.to_string());
    }

    new_lines.join("\n")
}

fn fix_cbuffer_syntax(hlsl: &str) -> String {
    let mut result = hlsl.to_string();

    // Find all struct definitions first to extract their fields
    let mut struct_fields = std::collections::HashMap::new();

    for line in hlsl.lines() {
        let trimmed = line.trim();
        // Look for struct definitions
        if trimmed.starts_with("struct ") && trimmed.ends_with(" {") {
            let struct_name = trimmed
                .strip_prefix("struct ")
                .and_then(|s| s.strip_suffix(" {"))
                .unwrap_or("");

            // Collect fields for this struct
            let mut in_struct = false;
            let mut fields = Vec::new();
            let mut brace_count = 0;

            for scan_line in hlsl.lines() {
                let scan_trimmed = scan_line.trim();
                if scan_trimmed == format!("struct {} {{", struct_name) {
                    in_struct = true;
                    brace_count = 1;
                    continue;
                }
                if in_struct {
                    if scan_trimmed.contains('{') {
                        brace_count += scan_trimmed.matches('{').count();
                    }
                    if scan_trimmed.contains('}') {
                        brace_count -= scan_trimmed.matches('}').count();
                        if brace_count == 0 {
                            break;
                        }
                    }
                    if brace_count == 1 && !scan_trimmed.is_empty() && scan_trimmed != "}" {
                        fields.push(scan_line.to_string());
                    }
                }
            }

            if !fields.is_empty() {
                struct_fields.insert(struct_name.to_string(), fields);
            }
        }
    }

    // Now fix cbuffer declarations
    // Pattern: "cbuffer uniforms : register(b0, spaceN) { StructName uniforms; }"
    for (struct_name, fields) in &struct_fields {
        let old_pattern = format!("cbuffer uniforms : register(b0, space");
        if let Some(start_pos) = result.find(&old_pattern) {
            // Find the end of this cbuffer declaration
            if let Some(end_pos) = result[start_pos..].find('}') {
                let cbuffer_section = &result[start_pos..start_pos + end_pos + 1];

                // Extract the register clause
                if let Some(reg_start) = cbuffer_section.find("register(") {
                    if let Some(reg_end) = cbuffer_section[reg_start..].find(')') {
                        let register_clause = &cbuffer_section[reg_start..reg_start + reg_end + 1];

                        // Check if this cbuffer uses our struct
                        if cbuffer_section.contains(struct_name) {
                            // Build the replacement
                            let mut replacement = format!("cbuffer {} : {} {{\n", struct_name, register_clause);
                            for field in fields {
                                replacement.push_str(field);
                                replacement.push('\n');
                            }
                            replacement.push_str("}");

                            result = result.replace(cbuffer_section, &replacement);
                        }
                    }
                }
            }
        }
    }

    result
}

fn simplify_stage_io(hlsl: &str) -> String {
    // For now, keep the wrapper structs as Naga generates them
    // They should still work with SDL3, even if not ideal
    // Future enhancement: detect and simplify these patterns
    hlsl.to_string()
}

fn generate_spirv(
    module: &naga::Module,
    module_info: &naga::valid::ModuleInfo,
    output_path: &Path,
    meta_path: &Path,
    header_comment: &str,
) -> Result<(), String> {
    // Configure SPIR-V options
    let options = spv::Options {
        lang_version: (1, 0),
        flags: spv::WriterFlags::DEBUG | spv::WriterFlags::ADJUST_COORDINATE_SPACE,
        capabilities: None,
        bounds_check_policies: Default::default(),
        zero_initialize_workgroup_memory: spv::ZeroInitializeWorkgroupMemoryMode::Polyfill,
        force_loop_bounding: false,
        binding_map: Default::default(),
        debug_info: None,
    };

    // Generate SPIR-V binary
    let spirv_binary = spv::write_vec(module, module_info, &options, None)
        .map_err(|e| format!("SPIR-V generation error: {:?}", e))?;

    // Write binary file
    let binary_bytes: Vec<u8> = spirv_binary
        .iter()
        .flat_map(|word| word.to_le_bytes())
        .collect();

    fs::write(output_path, binary_bytes)
        .map_err(|e| format!("Failed to write {}: {}", output_path.display(), e))?;

    // Write metadata file
    let meta_content = format!(
        "{}\nSPIR-V binary file\nWords: {}\nBytes: {}\n",
        header_comment,
        spirv_binary.len(),
        spirv_binary.len() * 4
    );

    fs::write(meta_path, meta_content)
        .map_err(|e| format!("Failed to write {}: {}", meta_path.display(), e))?;

    Ok(())
}


