<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU 3D World from 2D Map</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            // Map definition (1 = wall, 0 = floor, 5-8 = starting position with direction)
            // 5=North, 6=East, 7=South, 8=West
            const mapWidth = 10;
            const mapHeight = 10;
            const map = [
                [1,1,1,1,1,1,1,1,1,1],
                [1,6,0,0,0,0,0,0,0,1],
                [1,0,1,0,1,0,1,0,0,1],
                [1,0,1,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,1],
                [1,0,1,1,0,0,1,0,0,1],
                [1,0,0,0,0,1,0,0,1,1],
                [1,0,1,0,0,0,0,0,0,1],
                [1,0,0,0,1,0,0,1,0,1],
                [1,1,1,1,1,1,1,1,1,1]
            ];

            // Find starting position and direction
            let startX = 1.5, startZ = 1.5, startYaw = 0;
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    const cell = map[z][x];
                    if (cell >= 5 && cell <= 8) {
                        startX = x + 0.5;
                        startZ = z + 0.5;
                        // Shader: forward = (cos(yaw), 0, sin(yaw)) when pitch=0
                        // yaw=0: forward=(1,0,0) = +X = East
                        // yaw=π/2: forward=(0,0,1) = +Z = South
                        // yaw=π: forward=(-1,0,0) = -X = West
                        // yaw=-π/2: forward=(0,0,-1) = -Z = North
                        if (cell === 5) startYaw = -Math.PI / 2;    // North (-Z)
                        else if (cell === 6) startYaw = 0;          // East (+X)
                        else if (cell === 7) startYaw = Math.PI / 2; // South (+Z)
                        else if (cell === 8) startYaw = Math.PI;    // West (-X)
                        map[z][x] = 0; // Clear the marker
                        console.log(`Starting at (${startX}, ${startZ}) facing ${cell===5?'North':cell===6?'East':cell===7?'South':'West'} with yaw=${startYaw}`);
                    }
                }
            }

            const mapData = new Uint8Array(mapWidth * mapHeight);
            for (let z = 0; z < mapHeight; z++) {
                for (let x = 0; x < mapWidth; x++) {
                    mapData[z * mapWidth + x] = map[z][x];
                }
            }

            // Create map texture
            const mapTexture = device.createTexture({
                size: [mapWidth, mapHeight, 1],
                format: 'r8uint',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
            });
            device.queue.writeTexture(
                { texture: mapTexture },
                mapData,
                { bytesPerRow: mapWidth },
                { width: mapWidth, height: mapHeight }
            );
            const mapView = mapTexture.createView();

            // Load textures (using public URLs; replace if needed)
            async function createTextureFromUrl(device, url, label) {
                const response = await fetch(url);
                const imageBitmap = await createImageBitmap(await response.blob());
                const texture = device.createTexture({
                    label,
                    size: [imageBitmap.width, imageBitmap.height, 1],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
                });
                device.queue.copyExternalImageToTexture(
                    { source: imageBitmap },
                    { texture },
                    [imageBitmap.width, imageBitmap.height, 1]
                );
                return texture;
            }

            const wallTexture = await createTextureFromUrl(device, 'https://threejs.org/examples/textures/brick_diffuse.jpg', 'wall');
            const floorTexture = await createTextureFromUrl(device, 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg', 'floor');
            const ceilingTexture = await createTextureFromUrl(device, 'https://threejs.org/examples/textures/lava/cloud.png', 'ceiling'); // Placeholder; replace for better ceiling

            const wallView = wallTexture.createView();
            const floorView = floorTexture.createView();
            const ceilingView = ceilingTexture.createView();

            const sampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear'
            });

            // Quad vertices
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                -1.0,  1.0,
                 1.0, -1.0,
                 1.0,  1.0,
            ]);
            const vertexBuffer = device.createBuffer({
                label: 'vertex buffer',
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
            vertexBuffer.unmap();

            // Uniform buffer (80 bytes to match WGSL alignment requirements)
            const uniformBuffer = device.createBuffer({
                label: 'uniform buffer',
                size: 80, // Aligned size for uniform buffer
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            // Shaders
            const vsSource = `
                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                };

                @vertex
                fn vertex_main(@location(0) position: vec2<f32>) -> VertexOutput {
                    var output: VertexOutput;
                    output.position = vec4<f32>(position, 0.0, 1.0);
                    return output;
                }
            `;

            const fsSource = `
                struct Uniforms {
                    viewWidth: f32,
                    viewHeight: f32,
                    padding1: f32,
                    padding2: f32,
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    padding3: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    time: f32,
                    mapWidth: f32,
                    mapHeight: f32,
                    wallHeight: f32,
                    padding4: f32,
                };

                struct WallHit {
                    t: f32,
                    isXSide: bool,
                };

                @group(0) @binding(0) var<uniform> u: Uniforms;
                @group(0) @binding(1) var mapTex: texture_2d<u32>;
                @group(0) @binding(2) var wallTex: texture_2d<f32>;
                @group(0) @binding(3) var s: sampler;
                @group(0) @binding(4) var floorTex: texture_2d<f32>;
                @group(0) @binding(5) var ceilingTex: texture_2d<f32>;

                fn raycastWalls(pos: vec3<f32>, dir: vec3<f32>) -> WallHit {
                    let eps = 1e-6;
                    let dirX = select(dir.x, eps, abs(dir.x) < eps);
                    let dirZ = select(dir.z, eps, abs(dir.z) < eps);
                    var mapX: i32 = i32(floor(pos.x));
                    var mapZ: i32 = i32(floor(pos.z));
                    let deltaDistX = 1.0 / abs(dirX);
                    let deltaDistZ = 1.0 / abs(dirZ);
                    let stepX: i32 = select(i32(-1), i32(1), dirX > 0.0);
                    let stepZ: i32 = select(i32(-1), i32(1), dirZ > 0.0);
                    var sideDistX: f32;
                    if (dirX > 0.0) {
                        sideDistX = (f32(mapX + 1) - pos.x) / dirX;
                    } else {
                        sideDistX = (pos.x - f32(mapX)) / (-dirX);
                    }
                    var sideDistZ: f32;
                    if (dirZ > 0.0) {
                        sideDistZ = (f32(mapZ + 1) - pos.z) / dirZ;
                    } else {
                        sideDistZ = (pos.z - f32(mapZ)) / (-dirZ);
                    }
                    var t_hit = 1e30;
                    var isXSide = false;
                    loop {
                        let t_current = min(sideDistX, sideDistZ);
                        isXSide = sideDistX < sideDistZ;
                        if (isXSide) {
                            sideDistX += deltaDistX;
                            mapX += stepX;
                        } else {
                            sideDistZ += deltaDistZ;
                            mapZ += stepZ;
                        }
                        let texSize = vec2<i32>(i32(u.mapWidth), i32(u.mapHeight));
                        if (mapX < 0 || mapX >= texSize.x || mapZ < 0 || mapZ >= texSize.y) {
                            break;
                        }
                        let cell = textureLoad(mapTex, vec2<i32>(mapX, mapZ), 0).r;
                        if (cell > 0u) {
                            t_hit = t_current;
                            break;
                        }
                    }
                    var result: WallHit;
                    result.t = t_hit;
                    result.isXSide = isXSide;
                    return result;
                }

                @fragment
                fn fragment_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
                    let aspect = u.viewWidth / u.viewHeight;
                    let tanHalfFov = tan(u.fov * 0.5);
                    let ndcX = 2.0 * fragCoord.x / u.viewWidth - 1.0;
                    let ndcY = 1.0 - 2.0 * fragCoord.y / u.viewHeight;
                    let h = ndcX * tanHalfFov * aspect;
                    let v = ndcY * tanHalfFov;

                    let cy = cos(u.yaw);
                    let sy = sin(u.yaw);
                    let cp = cos(u.pitch);
                    let sp = sin(u.pitch);

                    let forward = vec3<f32>(cy * cp, sp, sy * cp);
                    let right = vec3<f32>(-sy, 0.0, cy);
                    let up = vec3<f32>(-sp * cy, cp, -sp * sy);

                    let rayDir = normalize(forward + right * h + up * v);

                    let cameraPos = vec3<f32>(u.cameraPosX, u.cameraPosY, u.cameraPosZ);

                    // Floor: only hit if ray is going down (rayDir.y < 0)
                    let t_floor = select((0.0 - cameraPos.y) / rayDir.y, 1e30, rayDir.y >= 0.0);
                    // Ceiling: only hit if ray is going up (rayDir.y > 0)
                    let t_ceiling = select((u.wallHeight - cameraPos.y) / rayDir.y, 1e30, rayDir.y <= 0.0);
                    let wallHit = raycastWalls(cameraPos, rayDir);
                    let t_wall = wallHit.t;

                    let minT = min(t_wall, min(t_floor, t_ceiling));
                    if (minT > 100.0) {
                        return vec4<f32>(0.5, 0.7, 1.0, 1.0); // sky
                    }

                    let hitPos = cameraPos + rayDir * minT;
                    var texU: f32;
                    var texV: f32;
                    var isWall = false;
                    var isFloor = false;
                    var isCeiling = false;

                    if (minT == t_wall && t_wall < 1e29) {
                        // Wall hit
                        isWall = true;
                        if (wallHit.isXSide) {
                            texU = fract(hitPos.z);
                        } else {
                            texU = fract(hitPos.x);
                        }
                        texV = hitPos.y / u.wallHeight;
                    } else if (minT == t_floor) {
                        // Floor hit
                        isFloor = true;
                        texU = fract(hitPos.x);
                        texV = fract(hitPos.z);
                    } else {
                        // Ceiling hit
                        isCeiling = true;
                        texU = fract(hitPos.x);
                        texV = fract(hitPos.z);
                    }

                    // Use solid colors with checkerboard pattern
                    var baseColor: vec4<f32>;
                    if (isWall) {
                        baseColor = vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red for walls
                    } else if (isFloor) {
                        baseColor = vec4<f32>(0.0, 0.0, 1.0, 1.0); // Blue for floor
                    } else {
                        baseColor = vec4<f32>(1.0, 1.0, 0.0, 1.0); // Yellow for ceiling
                    }
                    
                    // Add checkerboard pattern
                    let checker = (i32(floor(texU * 4.0)) + i32(floor(texV * 4.0))) & 1;
                    let checkerFactor = select(0.7, 1.0, checker == 0);
                    var color = baseColor * checkerFactor;
                    
                    // Simple distance fog
                    let factor = exp2(-minT * 0.05);
                    color.r *= factor;
                    color.g *= factor;
                    color.b *= factor;
                    
                    // Draw crosshair
                    let centerX = u.viewWidth * 0.5;
                    let centerY = u.viewHeight * 0.5;
                    let crosshairSize = 10.0;
                    let crosshairThickness = 2.0;
                    let dx = abs(fragCoord.x - centerX);
                    let dy = abs(fragCoord.y - centerY);
                    
                    if ((dx < crosshairThickness && dy < crosshairSize) || 
                        (dy < crosshairThickness && dx < crosshairSize)) {
                        // Crosshair color: white with black outline for visibility
                        if (dx < 1.0 || dy < 1.0) {
                            color = vec4<f32>(1.0, 1.0, 1.0, 1.0);
                        } else {
                            color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
                        }
                    }
                    
                    return color;
                }
            `;

            const vsModule = device.createShaderModule({ code: vsSource });
            const fsModule = device.createShaderModule({ code: fsSource });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'uint' } },
                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                    { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
                    { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                    { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
                ]
            });

            const pipeline = device.createRenderPipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                vertex: {
                    module: vsModule,
                    entryPoint: 'vertex_main',
                    buffers: [{
                        arrayStride: 8,
                        attributes: [{
                            shaderLocation: 0,
                            offset: 0,
                            format: 'float32x2'
                        }]
                    }]
                },
                fragment: {
                    module: fsModule,
                    entryPoint: 'fragment_main',
                    targets: [{ format }]
                },
                primitive: {
                    topology: 'triangle-list'
                }
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: uniformBuffer } },
                    { binding: 1, resource: mapView },
                    { binding: 2, resource: wallView },
                    { binding: 3, resource: sampler },
                    { binding: 4, resource: floorView },
                    { binding: 5, resource: ceilingView },
                ]
            });

            // Camera and controls
            let cameraPos = { x: startX, y: 1.0, z: startZ };
            let yaw = startYaw;
            let pitch = 0.0;
            const fov = Math.PI / 3;
            const wallHeight = 2.0;
            const moveSpeed = 0.1;
            const keys = {};
            let mapArray = map; // For JS collision

            document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function onMouseMove(e) {
                yaw += e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, pitch));
            }

            function updateCamera() {
                let dx = 0;
                let dz = 0;
                const sinYaw = Math.sin(yaw);
                const cosYaw = Math.cos(yaw);
                // Forward direction is (cos(yaw), sin(yaw)) in XZ plane
                // Right direction is (sin(yaw), -cos(yaw)) in XZ plane
                if (keys['w']) {
                    dx += cosYaw * moveSpeed;
                    dz += sinYaw * moveSpeed;
                }
                if (keys['s']) {
                    dx -= cosYaw * moveSpeed;
                    dz -= sinYaw * moveSpeed;
                }
                if (keys['a']) {
                    dx += sinYaw * moveSpeed;
                    dz -= cosYaw * moveSpeed;
                }
                if (keys['d']) {
                    dx -= sinYaw * moveSpeed;
                    dz += cosYaw * moveSpeed;
                }

                const newX = cameraPos.x + dx;
                const newZ = cameraPos.z + dz;
                const mapX = Math.floor(newX);
                const mapZ = Math.floor(newZ);
                if (mapX >= 0 && mapX < mapWidth && mapZ >= 0 && mapZ < mapHeight && mapArray[mapZ][mapX] === 0) {
                    cameraPos.x = newX;
                    cameraPos.z = newZ;
                }
            }

            // Render loop
            let frameCount = 0;
            function render() {
                updateCamera();

                // Debug log first frame and whenever pitch changes
                if (frameCount < 5 || Math.abs(pitch) > 0.01) {
                    console.log(`Frame ${frameCount}: pos=(${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)}), yaw=${yaw.toFixed(3)}, pitch=${pitch.toFixed(3)}`);
                    if (frameCount === 0) {
                        console.log(`Map at [1,1]=${map[1][1]}, [1,2]=${map[1][2]}, [2,1]=${map[2][1]}`);
                    }
                }
                frameCount++;

                // Pack data with proper alignment for WGSL uniforms
                // WGSL alignment: vec3<f32> has size=12 but alignment=16
                // Layout:
                // [0-3]: viewWidth, [4-7]: viewHeight, [8-11]: padding, [12-15]: padding
                // [16-27]: cameraPos (vec3), [28-31]: padding
                // [32+]: yaw, pitch, fov, time, mapWidth, mapHeight, wallHeight
                const data = new Float32Array(20); // 80 bytes
                data[0] = canvas.width;
                data[1] = canvas.height;
                // data[2], data[3] = padding
                data[4] = cameraPos.x;
                data[5] = cameraPos.y;
                data[6] = cameraPos.z;
                // data[7] = padding
                data[8] = yaw;
                data[9] = pitch;
                data[10] = fov;
                data[11] = performance.now() / 1000;
                data[12] = mapWidth;
                data[13] = mapHeight;
                data[14] = wallHeight;
                // data[15-19] = padding

                if (frameCount === 1) {
                    console.log(`data[8]=yaw=${data[8].toFixed(3)}, data[9]=pitch=${data[9].toFixed(3)}, data[10]=fov=${data[10].toFixed(3)}`);
                }

                device.queue.writeBuffer(uniformBuffer, 0, data);

                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }]
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.draw(6);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(render);
            }

            render();

            // Resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        init();
    </script>
</body>
</html>
