<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MouseCircle - SDL3 GPU via WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
import { createWasmSDLHost, createVirtualFileSystem } from './js/sdl_wasm_host.js';

let wasmMemory = null;
const stdoutDecoder = new TextDecoder();
const fileEncoder = new TextEncoder();

async function fetchTextWithBust(path, cacheBust) {
    const response = await fetch(`${path}?v=${cacheBust}`);
    if (!response.ok) {
        throw new Error(`Failed to load ${path}: ${response.status}`);
    }
    return await response.text();
}

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = 640;
            canvas.height = 480;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            const cacheBust = Date.now();
            const shaderEntries = [
                ['sceneVertex', 'shaders/mousecircle_scene_vertex.wgsl'],
                ['sceneFragment', 'shaders/mousecircle_scene_fragment.wgsl'],
                ['overlayVertex', 'shaders/mousecircle_overlay_vertex.wgsl'],
                ['overlayFragment', 'shaders/mousecircle_overlay_fragment.wgsl'],
                ['sceneVertexMSL', 'shaders/mousecircle_scene_vertex.msl'],
                ['sceneFragmentMSL', 'shaders/mousecircle_scene_fragment.msl'],
                ['overlayVertexMSL', 'shaders/mousecircle_overlay_vertex.msl'],
                ['overlayFragmentMSL', 'shaders/mousecircle_overlay_fragment.msl'],
            ];

            const shaderText = {};
            await Promise.all(shaderEntries.map(async ([key, path]) => {
                shaderText[key] = await fetchTextWithBust(path, cacheBust);
            }));

            const shaderSources = {
                sceneVertex: shaderText.sceneVertex,
                sceneFragment: shaderText.sceneFragment,
                overlayVertex: shaderText.overlayVertex,
                overlayFragment: shaderText.overlayFragment,
            };

            const wasiFs = createVirtualFileSystem(new Map([
                ['shaders/mousecircle_scene_vertex.msl', fileEncoder.encode(shaderText.sceneVertexMSL)],
                ['shaders/mousecircle_scene_fragment.msl', fileEncoder.encode(shaderText.sceneFragmentMSL)],
                ['shaders/mousecircle_overlay_vertex.msl', fileEncoder.encode(shaderText.overlayVertexMSL)],
                ['shaders/mousecircle_overlay_fragment.msl', fileEncoder.encode(shaderText.overlayFragmentMSL)],
            ]));


            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const sdlHost = createWasmSDLHost(device, canvas, shaderSources);

            // Load WASM module
            const wasmResponse = await fetch(`mousecircle.wasm?v=${cacheBust}`);
            const wasmBytes = await wasmResponse.arrayBuffer();

            const wasiImports = {
                fd_write: (fd, iovs, iovs_len, nwritten) => {
                    if (!wasmMemory) {
                        return 0;
                    }
                    let written = 0;
                    const view = new DataView(wasmMemory.buffer);
                    for (let i = 0; i < iovs_len; i++) {
                        const ptr = view.getUint32(iovs + i * 8, true);
                        const len = view.getUint32(iovs + i * 8 + 4, true);
                        const bytes = new Uint8Array(wasmMemory.buffer, ptr, len);
                        console.log(stdoutDecoder.decode(bytes));
                        written += len;
                    }
                    view.setUint32(nwritten, written, true);
                    return 0;
                },
                proc_exit: (code) => {
                    console.log('WASM exited with code:', code);
                },
                path_open: (...args) => wasiFs.path_open(...args),
                fd_read: (...args) => wasiFs.fd_read(...args),
                fd_seek: (...args) => wasiFs.fd_seek(...args),
                fd_close: (...args) => wasiFs.fd_close(...args),
                fd_tell: (...args) => wasiFs.fd_tell(...args),
                args_sizes_get: (...args) => wasiFs.args_sizes_get(...args),
                args_get: (...args) => wasiFs.args_get(...args),
            };

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                sdl: sdlHost.imports,
                wasi_snapshot_preview1: wasiImports,
            });

            const wasmInstance = wasmModule.instance;
            wasmMemory = wasmInstance.exports.memory;
            sdlHost.setMemory(wasmMemory);
            wasiFs.setMemory(wasmMemory);

            // Call main
            const app_init = wasmInstance.exports.app_init;
            const app_iterate = wasmInstance.exports.app_iterate;
            const app_quit = wasmInstance.exports.app_quit;

            console.log('app_init()');
            const initResult = app_init();
            if (initResult < 0) {
                console.error('app_init() failed');
                return;
            }
            if (initResult > 0) {
                console.log('app_init() completed immediately');
                app_quit();
                return;
            }

            let animationFrameId = null;
            function frame() {
                const iterateResult = app_iterate();
                if (iterateResult === 0) {
                    animationFrameId = requestAnimationFrame(frame);
                } else {
                    if (iterateResult < 0) {
                        console.error('app_iterate() failed');
                    }
                    app_quit();
                }
            }

            animationFrameId = requestAnimationFrame(frame);
        }

        init();
    </script>
</body>
</html>
