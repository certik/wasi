<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MouseCircle - SDL3 GPU via WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        // WGSL Shaders (converted from MSL in MouseCircle_standalone.c)
        const vertexShaderWGSL = `
struct VertexInput {
    @location(0) position: vec3f,
    @location(1) color: vec3f,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) color: vec3f,
    @location(1) world_pos: vec3f,
};

struct Uniforms {
    mvp: mat4x4f,
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@vertex
fn main(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    output.position = uniforms.mvp * vec4f(input.position, 1.0);
    output.color = input.color;
    output.world_pos = input.position;
    return output;
}
`;

        const fragmentShaderWGSL = `
struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) color: vec3f,
    @location(1) world_pos: vec3f,
};

@fragment
fn main(input: VertexOutput) -> @location(0) vec4f {
    // Small checkerboard pattern based on world position
    let checker_size = 0.25;
    let scaled = input.world_pos / checker_size;
    let check = i32(floor(scaled.x) + floor(scaled.y) + floor(scaled.z));
    let checker = select(1.0, 0.8, (check & 1) != 0);

    return vec4f(input.color * checker, 1.0);
}
`;

        function createWasmSDLHost(adapter, device, canvas) {
            let memory = null;
            let nextHandle = 1;
            const decoder = new TextDecoder('utf-8');
            const encoder = new TextEncoder();

            const context = canvas.getContext('webgpu');

            // SDL object storage
            const devices = new Map();
            const windows = new Map();
            const shaders = new Map();
            const pipelines = new Map();
            const commandBuffers = new Map();
            const renderPasses = new Map();
            const textures = new Map();
            const buffers = new Map();
            const transferBuffers = new Map();

            // Mouse state
            let mouseX = 0;
            let mouseY = 0;
            let mouseLocked = false;

            // Event queue
            const eventQueue = [];

            // Error handling
            let lastError = "";

            function setError(msg) {
                lastError = msg;
                console.error('[SDL Error]', msg);
            }

            function readString(ptr, length) {
                if (!ptr || length === 0) return '';
                const bytes = new Uint8Array(memory.buffer, ptr, length);
                return decoder.decode(bytes);
            }

            function writeString(ptr, maxLen, str) {
                const bytes = encoder.encode(str);
                const len = Math.min(bytes.length, maxLen - 1);
                const dst = new Uint8Array(memory.buffer, ptr, maxLen);
                dst.set(bytes.subarray(0, len));
                dst[len] = 0; // null terminator
            }

            // Set up event listeners
            canvas.addEventListener('mousemove', (e) => {
                if (mouseLocked) {
                    // Relative mouse motion for FPS controls
                    eventQueue.push({
                        type: 'mousemotion',
                        xrel: e.movementX,
                        yrel: e.movementY
                    });
                } else {
                    // Absolute mouse position
                    const rect = canvas.getBoundingClientRect();
                    const cssX = e.clientX - rect.left;
                    const cssY = e.clientY - rect.top;
                    mouseX = (cssX / rect.width) * canvas.width;
                    mouseY = (cssY / rect.height) * canvas.height;
                }
            });

            // Map JS key codes to SDL key codes
            function jsKeyToSDLKey(key) {
                const keyMap = {
                    'KeyW': 0x77,       // SDLK_W ('w')
                    'KeyA': 0x61,       // SDLK_A ('a')
                    'KeyS': 0x73,       // SDLK_S ('s')
                    'KeyD': 0x64,       // SDLK_D ('d')
                    'Space': 0x20,      // SDLK_SPACE
                    'ShiftLeft': 0xE1,  // SDLK_LSHIFT
                    'ControlLeft': 0xE0,// SDLK_LCTRL
                    'Escape': 0x1B,     // SDLK_ESCAPE
                    'KeyQ': 0x71,       // SDLK_Q ('q')
                };
                return keyMap[key] || 0;
            }

            window.addEventListener('keydown', (e) => {
                const sdlKey = jsKeyToSDLKey(e.code);
                if (sdlKey) {
                    eventQueue.push({
                        type: 'keydown',
                        key: sdlKey
                    });
                }
            });

            window.addEventListener('keyup', (e) => {
                const sdlKey = jsKeyToSDLKey(e.code);
                if (sdlKey) {
                    eventQueue.push({
                        type: 'keyup',
                        key: sdlKey
                    });
                }
            });

            // Handle pointer lock
            document.addEventListener('pointerlockchange', () => {
                mouseLocked = document.pointerLockElement === canvas;
            });

            window.addEventListener('beforeunload', () => {
                eventQueue.push({ type: 'quit' });
            });

            const imports = {
                init(flags) {
                    console.log('[SDL] Init with flags:', flags);
                    return 1; // success
                },

                quit() {
                    console.log('[SDL] Quit');
                },

                create_gpu_device(shader_format, debug) {
                    console.log('[SDL] CreateGPUDevice, format:', shader_format, 'debug:', debug);
                    const handle = nextHandle++;
                    devices.set(handle, device);
                    return handle;
                },

                destroy_gpu_device(deviceHandle) {
                    console.log('[SDL] DestroyGPUDevice:', deviceHandle);
                    devices.delete(deviceHandle);
                },

                create_window(title_ptr, title_len, w, h, flags) {
                    const title = readString(title_ptr, title_len);
                    console.log('[SDL] CreateWindow:', title, w, 'x', h, 'flags:', flags);

                    canvas.width = w;
                    canvas.height = h;

                    const handle = nextHandle++;
                    windows.set(handle, { canvas, width: w, height: h });
                    return handle;
                },

                destroy_window(windowHandle) {
                    console.log('[SDL] DestroyWindow:', windowHandle);
                    windows.delete(windowHandle);
                },

                claim_window_for_gpu_device(deviceHandle, windowHandle) {
                    console.log('[SDL] ClaimWindowForGPUDevice:', deviceHandle, windowHandle);

                    const format = navigator.gpu.getPreferredCanvasFormat();
                    context.configure({
                        device,
                        format,
                        usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    });

                    return 1; // success
                },

                release_window_from_gpu_device(deviceHandle, windowHandle) {
                    console.log('[SDL] ReleaseWindowFromGPUDevice:', deviceHandle, windowHandle);
                },

                get_window_size_in_pixels(windowHandle, w_ptr, h_ptr) {
                    const win = windows.get(windowHandle);
                    if (win && memory) {
                        const view = new DataView(memory.buffer);
                        if (w_ptr) view.setInt32(w_ptr, win.width, true);
                        if (h_ptr) view.setInt32(h_ptr, win.height, true);
                    }
                },

                create_gpu_shader(deviceHandle, info_ptr) {
                    if (!memory) return 0;

                    const dv = new DataView(memory.buffer);
                    const code_ptr = dv.getUint32(info_ptr, true);
                    const code_size = dv.getUint32(info_ptr + 4, true);
                    const entrypoint_ptr = dv.getUint32(info_ptr + 8, true);
                    const format = dv.getUint32(info_ptr + 12, true);
                    const stage = dv.getUint32(info_ptr + 16, true);

                    // For our simple case, we use hardcoded WGSL shaders
                    // SDL_GPU_SHADERSTAGE_VERTEX = 0, SDL_GPU_SHADERSTAGE_FRAGMENT = 1
                    const shaderCode = (stage === 0) ? vertexShaderWGSL : fragmentShaderWGSL;

                    console.log('[SDL] CreateGPUShader, stage:', stage);

                    try {
                        const shaderModule = device.createShaderModule({ code: shaderCode });
                        const handle = nextHandle++;
                        shaders.set(handle, shaderModule);
                        console.log('[SDL] CreateGPUShader, handle:', handle);
                        return handle;
                    } catch (e) {
                        setError('Failed to create shader: ' + e.message);
                        return 0;
                    }
                },

                release_gpu_shader(deviceHandle, shaderHandle) {
                    console.log('[SDL] ReleaseGPUShader:', shaderHandle);
                    shaders.delete(shaderHandle);
                },

                get_gpu_swapchain_texture_format(deviceHandle, windowHandle) {
                    const format = navigator.gpu.getPreferredCanvasFormat();
                    console.log('[SDL] GetGPUSwapchainTextureFormat:', format);

                    // Map WebGPU format to SDL format enum
                    const formatMap = {
                        'bgra8unorm': 0x13, // SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM
                        'rgba8unorm': 0x0F, // SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM
                    };

                    return formatMap[format] || 0x13;
                },

                create_gpu_graphics_pipeline(deviceHandle, info_ptr) {
                    if (!memory) return 0;

                    const dv = new DataView(memory.buffer);

                    // Read pipeline create info
                    const vertexShaderHandle = dv.getUint32(info_ptr + 0, true);
                    const fragmentShaderHandle = dv.getUint32(info_ptr + 4, true);
                    const vertexInputStatePtr = dv.getUint32(info_ptr + 8, true);
                    const primitiveType = dv.getUint32(info_ptr + 12, true);
                    const depthStencilStatePtr = dv.getUint32(info_ptr + 20, true);
                    const targetInfoPtr = dv.getUint32(info_ptr + 32, true);

                    console.log('[SDL] CreateGPUGraphicsPipeline');
                    console.log('[SDL]   vertexShaderHandle = ', vertexShaderHandle);
                    console.log('[SDL]   fragmentShaderHandle = ', fragmentShaderHandle);

                    const vertexShader = shaders.get(vertexShaderHandle);
                    const fragmentShader = shaders.get(fragmentShaderHandle);

                    if (!vertexShader || !fragmentShader) {
                        setError('Invalid shader handles');
                        return 0;
                    }

                    // Read vertex input state
                    let vertexBuffers = [];
                    if (vertexInputStatePtr !== 0) {
                        const numVertexBuffers = dv.getUint32(vertexInputStatePtr + 4, true);
                        const numVertexAttributes = dv.getUint32(vertexInputStatePtr + 12, true);

                        if (numVertexBuffers > 0 && numVertexAttributes > 0) {
                            const vertexBufferDescPtr = dv.getUint32(vertexInputStatePtr + 0, true);
                            const vertexAttributePtr = dv.getUint32(vertexInputStatePtr + 8, true);

                            // Read first vertex buffer description (simplified for single buffer)
                            const pitch = dv.getUint32(vertexBufferDescPtr + 4, true);

                            // Read vertex attributes
                            const attributes = [];
                            for (let i = 0; i < numVertexAttributes; i++) {
                                const attrOffset = vertexAttributePtr + i * 16;
                                const location = dv.getUint32(attrOffset + 0, true);
                                const format = dv.getUint32(attrOffset + 8, true);
                                const offset = dv.getUint32(attrOffset + 12, true);

                                // Map SDL format to WebGPU format
                                const formatMap = {
                                    5: 'float32x3',  // SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3
                                };

                                attributes.push({
                                    shaderLocation: location,
                                    offset: offset,
                                    format: formatMap[format] || 'float32x3'
                                });
                            }

                            vertexBuffers = [{
                                arrayStride: pitch,
                                attributes: attributes
                            }];
                        }
                    }

                    // Read depth stencil state
                    let depthStencil = undefined;
                    if (depthStencilStatePtr !== 0) {
                        const enableDepthTest = dv.getUint8(depthStencilStatePtr + 0);
                        const enableDepthWrite = dv.getUint8(depthStencilStatePtr + 1);
                        const compareOp = dv.getUint32(depthStencilStatePtr + 4, true);

                        if (enableDepthTest) {
                            const compareOpMap = {
                                2: 'less',  // SDL_GPU_COMPAREOP_LESS
                            };

                            depthStencil = {
                                format: 'depth16unorm',
                                depthWriteEnabled: enableDepthWrite !== 0,
                                depthCompare: compareOpMap[compareOp] || 'less'
                            };
                        }
                    }

                    // Read target info for depth format
                    let hasDepthStencil = false;
                    if (targetInfoPtr !== 0) {
                        hasDepthStencil = dv.getUint8(targetInfoPtr + 20) !== 0;
                    }

                    try {
                        const pipelineLayout = device.createPipelineLayout({
                            bindGroupLayouts: [
                                device.createBindGroupLayout({
                                    entries: [{
                                        binding: 0,
                                        visibility: GPUShaderStage.VERTEX,
                                        buffer: { type: 'uniform' }
                                    }]
                                })
                            ]
                        });

                        const pipelineDesc = {
                            layout: pipelineLayout,
                            vertex: {
                                module: vertexShader,
                                entryPoint: 'main',
                                buffers: vertexBuffers
                            },
                            fragment: {
                                module: fragmentShader,
                                entryPoint: 'main',
                                targets: [{
                                    format: navigator.gpu.getPreferredCanvasFormat(),
                                }],
                            },
                            primitive: {
                                topology: 'triangle-list',
                            },
                        };

                        if (depthStencil) {
                            pipelineDesc.depthStencil = depthStencil;
                        }

                        const pipeline = device.createRenderPipeline(pipelineDesc);

                        const handle = nextHandle++;
                        pipelines.set(handle, { pipeline, layout: pipelineLayout });
                        return handle;
                    } catch (e) {
                        setError('Failed to create pipeline: ' + e.message);
                        console.error(e);
                        return 0;
                    }
                },

                release_gpu_graphics_pipeline(deviceHandle, pipelineHandle) {
                    console.log('[SDL] ReleaseGPUGraphicsPipeline:', pipelineHandle);
                    pipelines.delete(pipelineHandle);
                },

                acquire_gpu_command_buffer(deviceHandle) {
                    const encoder = device.createCommandEncoder();
                    const handle = nextHandle++;
                    commandBuffers.set(handle, { encoder, uniformBuffer: null, bindGroup: null });
                    console.log('[SDL] AcquireGPUCommandBuffer, handle:', handle);
                    return handle;
                },

                wait_and_acquire_gpu_swapchain_texture(cmdbufHandle, windowHandle, texture_out_ptr, w_ptr, h_ptr) {
                    const texture = context.getCurrentTexture();
                    const textureHandle = nextHandle++;
                    textures.set(textureHandle, texture);

                    if (memory && texture_out_ptr) {
                        const dv = new DataView(memory.buffer);
                        dv.setUint32(texture_out_ptr, textureHandle, true);
                    }

                    const win = windows.get(windowHandle);
                    if (win && memory) {
                        const dv = new DataView(memory.buffer);
                        if (w_ptr) dv.setUint32(w_ptr, win.width, true);
                        if (h_ptr) dv.setUint32(h_ptr, win.height, true);
                    }

                    return 1; // success
                },

                begin_gpu_render_pass(cmdbufHandle, color_targets_ptr, num_color_targets, depth_stencil_ptr) {
                    if (!memory) return 0;

                    const cmdbuf = commandBuffers.get(cmdbufHandle);
                    if (!cmdbuf) {
                        console.error('[SDL] begin_gpu_render_pass: invalid cmdbuf handle', cmdbufHandle);
                        return 0;
                    }

                    const dv = new DataView(memory.buffer);

                    // Read color target info (assuming single target for now)
                    const textureHandle = dv.getUint32(color_targets_ptr, true);
                    const clear_r = dv.getFloat32(color_targets_ptr + 4, true);
                    const clear_g = dv.getFloat32(color_targets_ptr + 8, true);
                    const clear_b = dv.getFloat32(color_targets_ptr + 12, true);
                    const clear_a = dv.getFloat32(color_targets_ptr + 16, true);
                    const load_op = dv.getUint32(color_targets_ptr + 20, true);
                    const store_op = dv.getUint32(color_targets_ptr + 24, true);

                    const texture = textures.get(textureHandle);
                    if (!texture) return 0;

                    const renderPassDesc = {
                        colorAttachments: [{
                            view: texture.createView(),
                            loadOp: load_op === 0 ? 'clear' : 'load',
                            storeOp: store_op === 0 ? 'store' : 'discard',
                            clearValue: { r: clear_r, g: clear_g, b: clear_b, a: clear_a },
                        }],
                    };

                    // Read depth stencil target if provided
                    if (depth_stencil_ptr !== 0) {
                        const depthTextureHandle = dv.getUint32(depth_stencil_ptr, true);
                        const depth_clear = dv.getFloat32(depth_stencil_ptr + 4, true);
                        const depth_load_op = dv.getUint32(depth_stencil_ptr + 8, true);
                        const depth_store_op = dv.getUint32(depth_stencil_ptr + 12, true);

                        const depthTexture = textures.get(depthTextureHandle);
                        if (depthTexture) {
                            renderPassDesc.depthStencilAttachment = {
                                view: depthTexture.createView(),
                                depthLoadOp: depth_load_op === 0 ? 'clear' : 'load',
                                depthStoreOp: depth_store_op === 0 ? 'store' : 'discard',
                                depthClearValue: depth_clear,
                            };
                        }
                    }

                    const renderPass = cmdbuf.encoder.beginRenderPass(renderPassDesc);

                    const handle = nextHandle++;
                    renderPasses.set(handle, renderPass);
                    return handle;
                },

                end_gpu_render_pass(passHandle) {
                    console.log('[SDL] EndGPURenderPass, handle:', passHandle);
                    const pass = renderPasses.get(passHandle);
                    if (pass) {
                        pass.end();
                        renderPasses.delete(passHandle);
                        console.log('[SDL] Render pass ended');
                    } else {
                        console.error('[SDL] end_gpu_render_pass: invalid handle', passHandle);
                    }
                },

                bind_gpu_graphics_pipeline(passHandle, pipelineHandle) {
                    console.log('[SDL] BindGPUGraphicsPipeline, pass:', passHandle, 'pipeline:', pipelineHandle);
                    const pass = renderPasses.get(passHandle);
                    const pipelineInfo = pipelines.get(pipelineHandle);

                    if (pass && pipelineInfo) {
                        pass.setPipeline(pipelineInfo.pipeline);
                        console.log('[SDL] Pipeline set');
                    } else {
                        console.error('[SDL] bind_gpu_graphics_pipeline: invalid handles', { pass: !!pass, pipeline: !!pipelineInfo });
                    }
                },

                push_gpu_vertex_uniform_data(cmdbufHandle, slot, data_ptr, length) {
                    if (!memory) return;

                    const cmdbuf = commandBuffers.get(cmdbufHandle);
                    if (!cmdbuf) {
                        console.error('[SDL] push_gpu_vertex_uniform_data: invalid cmdbuf', cmdbufHandle);
                        return;
                    }

                    // Read uniform data from WASM memory (MVP matrix: 16 floats)
                    const uniformData = new Float32Array(memory.buffer, data_ptr, length / 4);

                    // Create or update uniform buffer
                    if (!cmdbuf.uniformBuffer) {
                        cmdbuf.uniformBuffer = device.createBuffer({
                            size: 64, // mat4x4 = 16 floats = 64 bytes
                            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                        });
                    }

                    device.queue.writeBuffer(cmdbuf.uniformBuffer, 0, uniformData);

                    // Create bind group if not exists
                    if (!cmdbuf.bindGroup) {
                        const firstPipeline = Array.from(pipelines.values())[0];
                        if (firstPipeline) {
                            const bindGroupLayout = firstPipeline.pipeline.getBindGroupLayout(0);
                            cmdbuf.bindGroup = device.createBindGroup({
                                layout: bindGroupLayout,
                                entries: [{
                                    binding: 0,
                                    resource: { buffer: cmdbuf.uniformBuffer }
                                }]
                            });
                        }
                    }
                },

                create_gpu_buffer(deviceHandle, info_ptr) {
                    if (!memory) return 0;
                    const dv = new DataView(memory.buffer);
                    const usage = dv.getUint32(info_ptr, true);
                    const size = dv.getUint32(info_ptr + 4, true);

                    const usageMap = {
                        1: GPUBufferUsage.VERTEX,  // SDL_GPU_BUFFERUSAGE_VERTEX
                        2: GPUBufferUsage.INDEX,   // SDL_GPU_BUFFERUSAGE_INDEX
                    };

                    const buffer = device.createBuffer({
                        size: size,
                        usage: usageMap[usage] | GPUBufferUsage.COPY_DST
                    });

                    const handle = nextHandle++;
                    buffers.set(handle, buffer);
                    console.log('[SDL] CreateGPUBuffer, handle:', handle, 'size:', size);
                    return handle;
                },

                release_gpu_buffer(deviceHandle, bufferHandle) {
                    console.log('[SDL] ReleaseGPUBuffer:', bufferHandle);
                    const buffer = buffers.get(bufferHandle);
                    if (buffer) {
                        buffer.destroy();
                        buffers.delete(bufferHandle);
                    }
                },

                create_gpu_transfer_buffer(deviceHandle, info_ptr) {
                    if (!memory) return 0;
                    const dv = new DataView(memory.buffer);
                    const usage = dv.getUint32(info_ptr, true);
                    const size = dv.getUint32(info_ptr + 4, true);

                    // Transfer buffers are mapped on CPU
                    const buffer = device.createBuffer({
                        size: size,
                        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
                    });

                    const handle = nextHandle++;
                    transferBuffers.set(handle, { buffer, mappedData: null, size });
                    console.log('[SDL] CreateGPUTransferBuffer, handle:', handle, 'size:', size);
                    return handle;
                },

                release_gpu_transfer_buffer(deviceHandle, bufferHandle) {
                    console.log('[SDL] ReleaseGPUTransferBuffer:', bufferHandle);
                    const transferBuf = transferBuffers.get(bufferHandle);
                    if (transferBuf) {
                        transferBuf.buffer.destroy();
                        transferBuffers.delete(bufferHandle);
                    }
                },

                map_gpu_transfer_buffer(deviceHandle, bufferHandle, cycle) {
                    if (!memory) return 0;
                    const transferBuf = transferBuffers.get(bufferHandle);
                    if (!transferBuf) return 0;

                    // Allocate space in WASM memory by growing if needed
                    // For simplicity, use a fixed region at the end of heap
                    const heapBase = 65536; // Start after first 64KB
                    const ptr = heapBase + bufferHandle * 8192; // Give each buffer 8KB offset

                    // Store the pointer so we can read from it later
                    transferBuf.mappedPtr = ptr;

                    console.log('[SDL] MapGPUTransferBuffer, handle:', bufferHandle, 'ptr:', ptr);
                    return ptr;
                },

                unmap_gpu_transfer_buffer(deviceHandle, bufferHandle) {
                    const transferBuf = transferBuffers.get(bufferHandle);
                    if (!transferBuf || !transferBuf.mappedPtr) return;

                    // Read the data from WASM memory into our transfer buffer
                    if (memory) {
                        const data = new Uint8Array(memory.buffer, transferBuf.mappedPtr, transferBuf.size);
                        transferBuf.mappedData = data.slice().buffer; // Copy the data
                        console.log('[SDL] UnmapGPUTransferBuffer, size:', transferBuf.size);
                    }
                },

                begin_gpu_copy_pass(cmdbufHandle) {
                    const cmdbuf = commandBuffers.get(cmdbufHandle);
                    if (!cmdbuf) return 0;

                    // WebGPU doesn't have explicit copy passes like SDL GPU
                    // We'll handle copies directly in upload_to_gpu_buffer
                    const handle = nextHandle++;
                    cmdbuf.copyPassHandle = handle;
                    return handle;
                },

                upload_to_gpu_buffer(copyPassHandle, source_ptr, dest_ptr, cycle) {
                    if (!memory) return;
                    const dv = new DataView(memory.buffer);

                    // Read source (transfer buffer location)
                    const transferBufferHandle = dv.getUint32(source_ptr, true);
                    const sourceOffset = dv.getUint32(source_ptr + 4, true);

                    // Read destination (buffer region)
                    const destBufferHandle = dv.getUint32(dest_ptr, true);
                    const destOffset = dv.getUint32(dest_ptr + 4, true);
                    const size = dv.getUint32(dest_ptr + 8, true);

                    const transferBuf = transferBuffers.get(transferBufferHandle);
                    const destBuffer = buffers.get(destBufferHandle);

                    if (transferBuf && destBuffer && transferBuf.mappedData) {
                        // Write mapped data directly to GPU buffer
                        device.queue.writeBuffer(destBuffer, destOffset, transferBuf.mappedData, sourceOffset, size);
                        console.log('[SDL] UploadToGPUBuffer, size:', size);
                    }
                },

                end_gpu_copy_pass(copyPassHandle) {
                    console.log('[SDL] EndGPUCopyPass, handle:', copyPassHandle);
                    // Nothing to do for WebGPU
                },

                bind_gpu_vertex_buffers(passHandle, first_slot, bindings_ptr, num_bindings) {
                    if (!memory) return;
                    const dv = new DataView(memory.buffer);
                    const pass = renderPasses.get(passHandle);
                    if (!pass) return;

                    for (let i = 0; i < num_bindings; i++) {
                        const bindingOffset = bindings_ptr + i * 8;
                        const bufferHandle = dv.getUint32(bindingOffset, true);
                        const offset = dv.getUint32(bindingOffset + 4, true);

                        const buffer = buffers.get(bufferHandle);
                        if (buffer) {
                            pass.setVertexBuffer(first_slot + i, buffer, offset);
                            console.log('[SDL] BindGPUVertexBuffer, slot:', first_slot + i);
                        }
                    }
                },

                bind_gpu_index_buffer(passHandle, binding_ptr, index_element_size) {
                    if (!memory) return;
                    const dv = new DataView(memory.buffer);
                    const pass = renderPasses.get(passHandle);
                    if (!pass) return;

                    const bufferHandle = dv.getUint32(binding_ptr, true);
                    const offset = dv.getUint32(binding_ptr + 4, true);

                    const buffer = buffers.get(bufferHandle);
                    if (buffer) {
                        const format = index_element_size === 1 ? 'uint32' : 'uint16';
                        pass.setIndexBuffer(buffer, format, offset);
                        console.log('[SDL] BindGPUIndexBuffer, format:', format);
                    }
                },

                draw_gpu_indexed_primitives(passHandle, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance) {
                    console.log('[SDL] DrawGPUIndexedPrimitives, indices:', indexCount);
                    const pass = renderPasses.get(passHandle);
                    if (!pass) return;

                    // Set bind group before drawing
                    const cmdbufEntry = Array.from(commandBuffers.values()).find(cb => cb.bindGroup);
                    if (cmdbufEntry && cmdbufEntry.bindGroup) {
                        pass.setBindGroup(0, cmdbufEntry.bindGroup);
                    }

                    pass.drawIndexed(indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
                },

                create_gpu_texture(deviceHandle, info_ptr) {
                    if (!memory) return 0;
                    const dv = new DataView(memory.buffer);
                    const usage = dv.getUint32(info_ptr, true);
                    const format = dv.getUint32(info_ptr + 4, true);
                    const width = dv.getUint32(info_ptr + 8, true);
                    const height = dv.getUint32(info_ptr + 12, true);

                    const usageMap = {
                        4: GPUTextureUsage.RENDER_ATTACHMENT,  // SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET
                    };

                    const formatMap = {
                        0x51: 'depth16unorm',  // SDL_GPU_TEXTUREFORMAT_D16_UNORM
                    };

                    const texture = device.createTexture({
                        size: { width, height },
                        format: formatMap[format] || 'depth16unorm',
                        usage: usageMap[usage] || GPUTextureUsage.RENDER_ATTACHMENT
                    });

                    const handle = nextHandle++;
                    textures.set(handle, texture);
                    console.log('[SDL] CreateGPUTexture, handle:', handle, 'size:', width, 'x', height);
                    return handle;
                },

                release_gpu_texture(deviceHandle, textureHandle) {
                    console.log('[SDL] ReleaseGPUTexture:', textureHandle);
                    const texture = textures.get(textureHandle);
                    if (texture) {
                        texture.destroy();
                        textures.delete(textureHandle);
                    }
                },

                set_window_relative_mouse_mode(windowHandle, enabled) {
                    console.log('[SDL] SetWindowRelativeMouseMode:', enabled);
                    if (enabled) {
                        canvas.requestPointerLock();
                    } else {
                        document.exitPointerLock();
                    }
                    return 1;
                },

                draw_gpu_primitives(passHandle, vertexCount, instanceCount, firstVertex, firstInstance) {
                    console.log('[SDL] DrawGPUPrimitives, pass:', passHandle, 'verts:', vertexCount);
                    const pass = renderPasses.get(passHandle);
                    if (!pass) return;

                    const cmdbufEntry = Array.from(commandBuffers.values()).find(cb => cb.bindGroup);
                    if (cmdbufEntry && cmdbufEntry.bindGroup) {
                        pass.setBindGroup(0, cmdbufEntry.bindGroup);
                    }

                    pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);
                },

                submit_gpu_command_buffer(cmdbufHandle) {
                    console.log('[SDL] SubmitGPUCommandBuffer, handle:', cmdbufHandle);
                    const cmdbuf = commandBuffers.get(cmdbufHandle);
                    if (cmdbuf) {
                        const commandBuffer = cmdbuf.encoder.finish();
                        device.queue.submit([commandBuffer]);
                        commandBuffers.delete(cmdbufHandle);
                        console.log('[SDL] Command buffer submitted');
                    } else {
                        console.error('[SDL] submit_gpu_command_buffer: invalid handle', cmdbufHandle);
                    }
                },

                poll_event(event_ptr) {
                    if (eventQueue.length === 0) return 0;

                    const event = eventQueue.shift();

                    if (memory && event_ptr) {
                        const dv = new DataView(memory.buffer);

                        if (event.type === 'quit') {
                            dv.setUint32(event_ptr, 0x100, true); // SDL_EVENT_QUIT
                        } else if (event.type === 'keydown') {
                            dv.setUint32(event_ptr, 0x300, true); // SDL_EVENT_KEY_DOWN
                            dv.setUint32(event_ptr + 16, event.key, true); // keycode at offset 16
                        } else if (event.type === 'keyup') {
                            dv.setUint32(event_ptr, 0x301, true); // SDL_EVENT_KEY_UP
                            dv.setUint32(event_ptr + 16, event.key, true); // keycode at offset 16
                        } else if (event.type === 'mousemotion') {
                            dv.setUint32(event_ptr, 0x400, true); // SDL_EVENT_MOUSE_MOTION
                            dv.setFloat32(event_ptr + 16, event.xrel, true); // xrel at offset 16
                            dv.setFloat32(event_ptr + 20, event.yrel, true); // yrel at offset 20
                        }
                    }

                    return 1;
                },

                get_mouse_state(x_ptr, y_ptr) {
                    if (memory) {
                        const dv = new DataView(memory.buffer);
                        if (x_ptr) dv.setFloat32(x_ptr, mouseX, true);
                        if (y_ptr) dv.setFloat32(y_ptr, mouseY, true);
                    }
                    return 0; // button state
                },

                get_error(buffer_ptr, buffer_size) {
                    if (memory && buffer_ptr && buffer_size > 0) {
                        writeString(buffer_ptr, buffer_size, lastError);
                    }
                    return buffer_ptr;
                },

                log(msg_ptr, msg_len) {
                    if (memory) {
                        const msg = readString(msg_ptr, msg_len);
                        console.log('[SDL Log]', msg);
                    }
                },
            };

            return {
                imports,
                setMemory(mem) {
                    memory = mem;
                },
            };
        }

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = 640;
            canvas.height = 480;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const sdlHost = createWasmSDLHost(adapter, device, canvas);

            // Load WASM module
            const wasmResponse = await fetch('mousecircle.wasm?v=' + Date.now());
            const wasmBytes = await wasmResponse.arrayBuffer();

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                sdl: sdlHost.imports,
                wasi_snapshot_preview1: {
                    fd_write: (fd, iovs, iovs_len, nwritten) => {
                        let written = 0;
                        const view = new DataView(memory.buffer);
                        const decoder = new TextDecoder();
                        for (let i = 0; i < iovs_len; i++) {
                            const ptr = view.getUint32(iovs + i * 8, true);
                            const len = view.getUint32(iovs + i * 8 + 4, true);
                            const bytes = new Uint8Array(memory.buffer, ptr, len);
                            console.log(decoder.decode(bytes));
                            written += len;
                        }
                        view.setUint32(nwritten, written, true);
                        return 0;
                    },
                    proc_exit: (code) => {
                        console.log('WASM exited with code:', code);
                    },
                },
            });

            const wasmInstance = wasmModule.instance;
            const memory = wasmInstance.exports.memory;
            sdlHost.setMemory(memory);

            // Call main
            const app_init = wasmInstance.exports.app_init;
            const app_iterate = wasmInstance.exports.app_iterate;
            const app_quit = wasmInstance.exports.app_quit;

            console.log('app_init()');
            const initResult = app_init();
            if (initResult < 0) {
                console.error('app_init() failed');
                return;
            }
            if (initResult > 0) {
                console.log('app_init() completed immediately');
                app_quit();
                return;
            }

            let animationFrameId = null;
            function frame() {
                const iterateResult = app_iterate();
                if (iterateResult === 0) {
                    animationFrameId = requestAnimationFrame(frame);
                } else {
                    if (iterateResult < 0) {
                        console.error('app_iterate() failed');
                    }
                    app_quit();
                }
            }

            animationFrameId = requestAnimationFrame(frame);
        }

        init();
    </script>
</body>
</html>
