<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MouseCircle - SDL3 GPU via WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="module">
import { createWasmSDLHost } from './sdl/wasm/SDL_wasm_host.js';
import { createFetchingVirtualFileSystem } from './sdl/wasm/SDL_wasm_vfs.js';
import { fetchBundle } from './sdl/wasm/SDL_wasm_bundle.js';

let wasmMemory = null;
const stdoutDecoder = new TextDecoder();
const FLOOR_TEXTURE_PATH = 'assets/WoodFloor007_1K-JPG_Color.jpg';
const REQUIRED_IMAGE_ASSETS = [FLOOR_TEXTURE_PATH];

function mimeTypeForPath(path) {
    const lower = path.toLowerCase();
    if (lower.endsWith('.png')) return 'image/png';
    if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
    if (lower.endsWith('.webp')) return 'image/webp';
    throw new Error(`Unsupported image type for ${path}`);
}

function loadImageElementFromBlob(blob) {
    return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = () => {
            URL.revokeObjectURL(url);
            resolve(img);
        };
        img.onerror = (err) => {
            URL.revokeObjectURL(url);
            reject(err);
        };
        img.src = url;
    });
}

async function decodeImageAsset(path, bytes) {
    const mimeType = mimeTypeForPath(path);
    const blob = new Blob([bytes], { type: mimeType });
    let source;
    if (typeof createImageBitmap === 'function') {
        source = await createImageBitmap(blob);
    } else {
        source = await loadImageElementFromBlob(blob);
    }

    const width = source.width || source.naturalWidth;
    const height = source.height || source.naturalHeight;
    let canvas;
    if (typeof OffscreenCanvas !== 'undefined') {
        canvas = new OffscreenCanvas(width, height);
    } else {
        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
    }
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        if (source.close) {
            source.close();
        }
        throw new Error('Failed to obtain 2D context for image decoding');
    }
    ctx.drawImage(source, 0, 0);
    const imageData = ctx.getImageData(0, 0, width, height);
    if (source.close) {
        source.close();
    }
    return {
        width,
        height,
        pixels: new Uint8Array(imageData.data.buffer.slice(0)),
    };
}

async function prepareImageAssets(bundleMap) {
    const assets = new Map();
    for (const path of REQUIRED_IMAGE_ASSETS) {
        const bytes = bundleMap.get(path);
        if (!bytes) {
            throw new Error(`Required asset missing from bundle: ${path}`);
        }
        const decoded = await decodeImageAsset(path, bytes);
        assets.set(path, decoded);
        console.log(`[Init] Decoded asset ${path}: ${decoded.width}x${decoded.height}`);
    }
    return assets;
}

        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = 640;
            canvas.height = 480;

            if (!navigator.gpu) {
                alert('WebGPU not supported.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Create virtual filesystem
            const wasiFs = createFetchingVirtualFileSystem();

            // Load shader bundle for instant filesystem access
            let assetImages = new Map();
            try {
                const cacheBust = Date.now();
                const bundleMap = await fetchBundle(`shaders.bundle?v=${cacheBust}`);
                wasiFs.preloadFromBundle(bundleMap);

                // Decode required image assets so the WASM module can request them synchronously
                assetImages = await prepareImageAssets(bundleMap);
            } catch (err) {
                console.error('[Init] Failed to load shader bundle:', err);
                alert('Failed to load shaders. Check console for details.');
                return;
            }

            device.addEventListener('uncapturederror', (event) => {
                console.error('[WebGPU] Uncaptured error:', event.error);
            });

            const sdlHost = createWasmSDLHost(device, canvas, assetImages);

            // Load WASM module
            const cacheBust = Date.now();
            const wasmResponse = await fetch(`game.wasm?v=${cacheBust}`);
            const wasmBytes = await wasmResponse.arrayBuffer();

            const wasiImports = {
                fd_write: (fd, iovs, iovs_len, nwritten) => {
                    if (!wasmMemory) {
                        return 0;
                    }
                    let written = 0;
                    const view = new DataView(wasmMemory.buffer);
                    for (let i = 0; i < iovs_len; i++) {
                        const ptr = view.getUint32(iovs + i * 8, true);
                        const len = view.getUint32(iovs + i * 8 + 4, true);
                        const bytes = new Uint8Array(wasmMemory.buffer, ptr, len);
                        console.log(stdoutDecoder.decode(bytes));
                        written += len;
                    }
                    view.setUint32(nwritten, written, true);
                    return 0;
                },
                proc_exit: (code) => {
                    console.log('WASM exited with code:', code);
                    if (code != 0) {
                        throw new Error("WASM exited with non-zero exit code");
                    }
                },
                path_open: (...args) => wasiFs.path_open(...args),
                fd_read: (...args) => wasiFs.fd_read(...args),
                fd_seek: (...args) => wasiFs.fd_seek(...args),
                fd_close: (...args) => wasiFs.fd_close(...args),
                fd_tell: (...args) => wasiFs.fd_tell(...args),
                args_sizes_get: (...args) => wasiFs.args_sizes_get(...args),
                args_get: (...args) => wasiFs.args_get(...args),
            };

            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                sdl: sdlHost.imports,
                wasi_snapshot_preview1: wasiImports,
            });

            const wasmInstance = wasmModule.instance;
            wasmMemory = wasmInstance.exports.memory;
            sdlHost.setMemory(wasmMemory);
            wasiFs.setMemory(wasmMemory);

            // Pass buddy allocator functions to SDL host for GPU buffer allocation
            if (wasmInstance.exports.wasm_buddy_alloc && wasmInstance.exports.wasm_buddy_free) {
                sdlHost.setBuddyAllocFunctions(
                    wasmInstance.exports.wasm_buddy_alloc,
                    wasmInstance.exports.wasm_buddy_free
                );
                console.log('[Init] Buddy allocator functions bound');
            } else {
                console.error('[Init] Missing buddy allocator exports!');
            }

            // Call main
            const app_init = wasmInstance.exports.app_init;
            const app_iterate = wasmInstance.exports.app_iterate;
            const app_quit = wasmInstance.exports.app_quit;

            console.log('app_init()');
            const initResult = app_init();
            if (initResult < 0) {
                console.error('app_init() failed');
                return;
            }

            if (initResult > 0) {
                console.log('app_init() completed immediately');
                app_quit();
                return;
            }

            let animationFrameId = null;
            function frame() {
                const iterateResult = app_iterate();
                if (iterateResult === 0) {
                    animationFrameId = requestAnimationFrame(frame);
                } else {
                    if (iterateResult < 0) {
                        console.error('app_iterate() failed');
                    }
                    app_quit();

                    // Clean up on quit
                    document.exitPointerLock();
                    canvas.style.display = 'none';
                    console.log('Game ended. Canvas hidden and pointer released.');
                }
            }

            animationFrameId = requestAnimationFrame(frame);
        }

        init();
    </script>
</body>
</html>
