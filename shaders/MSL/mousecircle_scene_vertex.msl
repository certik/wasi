// AUTO-GENERATED from WGSL/mousecircle_scene_vertex.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

// language: metal1.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct Material {
    float metalness;
    float roughness;
    float ior;
    float emissiveIntensity;
};
struct type_4 {
    metal::float4 inner[16];
};
struct type_5 {
    Material inner[7];
};
struct SceneUniforms {
    metal::float4x4 mvp;
    metal::float4 cameraPos;
    metal::float4 fogColor;
    type_4 staticLights;
    type_4 staticLightColors;
    metal::float4 staticLightParams;
    metal::float4 flashlightPos;
    metal::float4 flashlightDir;
    metal::float4 flashlightParams;
    metal::float4 screenParams;
    type_5 materials;
};
struct VertexInput {
    metal::packed_float3 position;
    float surfaceType;
    metal::float2 uv;
    char _pad3[8];
    metal::float3 normal;
};
struct VertexOutput {
    metal::float4 position;
    float surfaceType;
    char _pad2[4];
    metal::float2 uv;
    metal::float3 normal;
    metal::float3 worldPos;
};
constant uint MAX_STATIC_LIGHTS = 16u;
constant uint MATERIAL_COUNT = 7u;
constant float DEBUG_EXTRUDE_DISTANCE = 1.0;

struct main_Input {
    metal::float3 position [[attribute(0)]];
    float surfaceType [[attribute(1)]];
    metal::float2 uv [[attribute(2)]];
    metal::float3 normal [[attribute(3)]];
};
struct main_Output {
    metal::float4 position [[position]];
    float surfaceType [[user(loc0), center_perspective]];
    metal::float2 uv [[user(loc1), center_perspective]];
    metal::float3 normal [[user(loc2), center_perspective]];
    metal::float3 worldPos [[user(loc3), center_perspective]];
};
vertex main_Output main_(
  main_Input varyings [[stage_in]]
, constant SceneUniforms& uniforms [[buffer(0)]]
) {
    const VertexInput input = { varyings.position, varyings.surfaceType, varyings.uv, {}, varyings.normal };
    VertexOutput output = {};
    metal::float3 world_pos = {};
    world_pos = input.position;
    if ((input.surfaceType > 0.5) && (input.surfaceType < 1.5)) {
        metal::float2 base_tile = metal::floor(input.uv);
        metal::float2 local_uv = metal::fract(input.uv);
        bool tile_matches = (base_tile.x == 0.0) && (base_tile.y == 0.0);
        if ((tile_matches && (local_uv.x <= 0.2)) && (local_uv.y <= 0.2)) {
            metal::float3 normal_dir = metal::normalize(input.normal);
            metal::float3 _e34 = world_pos;
            world_pos = _e34 + (normal_dir * DEBUG_EXTRUDE_DISTANCE);
        }
    }
    metal::float3 _e36 = world_pos;
    metal::float4 world = metal::float4(_e36, 1.0);
    metal::float4x4 _e42 = uniforms.mvp;
    output.position = _e42 * world;
    output.surfaceType = input.surfaceType;
    output.uv = input.uv;
    output.normal = input.normal;
    metal::float3 _e51 = world_pos;
    output.worldPos = _e51;
    VertexOutput _e52 = output;
    const auto _tmp = _e52;
    return main_Output { _tmp.position, _tmp.surfaceType, _tmp.uv, _tmp.normal, _tmp.worldPos };
}
