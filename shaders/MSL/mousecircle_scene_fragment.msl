// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

// language: metal1.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct Material {
    float metalness;
    float roughness;
    float ior;
    float emissiveIntensity;
};
struct type_4 {
    metal::float4 inner[16];
};
struct type_5 {
    Material inner[7];
};
struct SceneUniforms {
    metal::float4x4 mvp;
    metal::float4 cameraPos;
    metal::float4 fogColor;
    type_4 staticLights;
    type_4 staticLightColors;
    metal::float4 staticLightParams;
    metal::float4 flashlightPos;
    metal::float4 flashlightDir;
    metal::float4 flashlightParams;
    metal::float4 screenParams;
    type_5 materials;
};
struct FragmentInput {
    float surfaceType;
    char _pad1[4];
    metal::float2 uv;
    metal::float3 normal;
    metal::float3 worldPos;
};
struct FlashlightResult {
    float screenIntensity;
    char _pad1[12];
    metal::float3 shading;
};
constant uint MAX_STATIC_LIGHTS = 16u;
constant uint MATERIAL_COUNT = 7u;
constant float PI = 3.1415927;

float checker(
    metal::float2 uv_1
) {
    metal::float2 scaled = metal::floor(uv_1 * 4.0);
    float v_2 = metal::fmod(scaled.x + scaled.y, 2.0);
    return (v_2 < 0.5) ? 1.0 : 0.7;
}

metal::float3 fresnel_schlick(
    float cos_theta,
    metal::float3 f0_
) {
    float clamped = metal::clamp(1.0 - cos_theta, 0.0, 1.0);
    return f0_ + ((metal::float3(1.0) - f0_) * metal::pow(clamped, 5.0));
}

float distribution_ggx(
    metal::float3 n_1,
    metal::float3 h,
    float roughness_1
) {
    float a = roughness_1 * roughness_1;
    float a2_ = a * a;
    float n_dot_h = metal::max(metal::dot(n_1, h), 0.0);
    float n_dot_h2_ = n_dot_h * n_dot_h;
    float denom = (n_dot_h2_ * (a2_ - 1.0)) + 1.0;
    return a2_ / ((PI * denom) * denom);
}

float geometry_schlick_ggx(
    float n_dot_v,
    float roughness_2
) {
    float r = roughness_2 + 1.0;
    float k = (r * r) / 8.0;
    return n_dot_v / ((n_dot_v * (1.0 - k)) + k);
}

float geometry_smith(
    metal::float3 n_2,
    metal::float3 v,
    metal::float3 l,
    float roughness_3
) {
    float n_dot_v_1 = metal::max(metal::dot(n_2, v), 0.0);
    float n_dot_l = metal::max(metal::dot(n_2, l), 0.0);
    float _e10 = geometry_schlick_ggx(n_dot_v_1, roughness_3);
    float _e11 = geometry_schlick_ggx(n_dot_l, roughness_3);
    return _e10 * _e11;
}

metal::float3 cook_torrance_brdf(
    metal::float3 n_3,
    metal::float3 v_1,
    metal::float3 l_1,
    metal::float3 albedo,
    float metallic_1,
    float roughness_4,
    metal::float3 f0_1,
    metal::float3 light_color,
    float light_intensity
) {
    metal::float3 h_1 = metal::normalize(v_1 + l_1);
    float n_dot_v_2 = metal::max(metal::dot(n_3, v_1), 0.0001);
    float n_dot_l_1 = metal::max(metal::dot(n_3, l_1), 0.0001);
    float h_dot_v = metal::max(metal::dot(h_1, v_1), 0.0);
    metal::float3 _e20 = fresnel_schlick(h_dot_v, f0_1);
    float _e21 = distribution_ggx(n_3, h_1, roughness_4);
    float _e22 = geometry_smith(n_3, v_1, l_1, roughness_4);
    metal::float3 specular = ((_e21 * _e22) * _e20) / metal::float3((4.0 * n_dot_v_2) * n_dot_l_1);
    metal::float3 kd = (metal::float3(1.0) - _e20) * (1.0 - metallic_1);
    metal::float3 diffuse = albedo / metal::float3(3.1415927);
    return ((((kd * diffuse) + specular) * light_color) * light_intensity) * n_dot_l_1;
}

int naga_f2i32(float value) {
    return static_cast<int>(metal::clamp(value, -2147483600.0, 2147483500.0));
}

metal::float3 compute_static_lighting(
    metal::float3 normal,
    metal::float3 world_pos,
    metal::float3 view_dir_1,
    metal::float3 albedo_1,
    float metallic_2,
    float roughness_5,
    metal::float3 f0_2,
    constant SceneUniforms& uniforms
) {
    metal::float3 total = metal::float3(0.0);
    int i = 0;
    float range_falloff = {};
    float _e10 = uniforms.staticLightParams.x;
    int light_count = metal::clamp(naga_f2i32(_e10), 0, 16);
    float range = uniforms.staticLightParams.y;
    if ((range <= 0.0) || (light_count == 0)) {
        return metal::float3(0.0);
    }
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            int _e84 = i;
            i = as_type<int>(as_type<uint>(_e84) + as_type<uint>(1));
        }
        loop_init = false;
        int _e31 = i;
        if (_e31 < light_count) {
        } else {
            break;
        }
        {
            int _e35 = i;
            metal::float4 light_data = uniforms.staticLights.inner[static_cast<uint>(_e35)];
            metal::float3 to_light = light_data.xyz - world_pos;
            float dist = metal::length(to_light);
            if (dist <= 0.0001) {
                continue;
            }
            metal::float3 dir = to_light / metal::float3(dist);
            float ndotl = metal::max(metal::dot(normal, dir), 0.0);
            if (ndotl <= 0.0) {
                continue;
            }
            range_falloff = 1.0;
            if (range > 0.0) {
                if (dist > range) {
                    continue;
                }
                range_falloff = metal::clamp(1.0 - (dist / range), 0.0, 1.0);
            }
            float inv = 1.0 / ((1.0 + (0.09 * dist)) + ((0.032 * dist) * dist));
            float _e72 = range_falloff;
            float attenuation = inv * _e72;
            int _e76 = i;
            metal::float4 _e79 = uniforms.staticLightColors.inner[static_cast<uint>(_e76)];
            metal::float3 light_color_1 = _e79.xyz;
            metal::float3 _e81 = cook_torrance_brdf(normal, view_dir_1, dir, albedo_1, metallic_2, roughness_5, f0_2, light_color_1, attenuation);
            metal::float3 _e82 = total;
            total = _e82 + _e81;
        }
    }
    metal::float3 _e87 = total;
    return _e87;
}

FlashlightResult compute_flashlight(
    metal::float3 normal_1,
    metal::float3 world_pos_1,
    metal::float4 frag_coord_1,
    metal::float3 view_dir_2,
    metal::float3 albedo_2,
    float metallic_3,
    float roughness_6,
    metal::float3 f0_3,
    constant SceneUniforms& uniforms
) {
    FlashlightResult result = FlashlightResult {0.0, {}, metal::float3(0.0)};
    float beam = {};
    float _e16 = uniforms.flashlightParams.x;
    if (_e16 < 0.5) {
        FlashlightResult _e19 = result;
        return _e19;
    }
    float width = uniforms.screenParams.x;
    float height = uniforms.screenParams.y;
    float min_dim = uniforms.screenParams.z;
    if (((width <= 0.0) || (height <= 0.0)) || (min_dim <= 0.0)) {
        FlashlightResult _e40 = result;
        return _e40;
    }
    metal::float2 pixel = frag_coord_1.xy;
    metal::float2 center = metal::float2(width * 0.5, height * 0.5);
    metal::float2 delta = (pixel - center) / metal::float2(min_dim);
    float radius = uniforms.flashlightParams.w;
    if (radius <= 0.0) {
        FlashlightResult _e56 = result;
        return _e56;
    }
    float dist_1 = metal::length(delta);
    if (dist_1 > radius) {
        FlashlightResult _e59 = result;
        return _e59;
    }
    float falloff = metal::clamp(dist_1 / radius, 0.0, 1.0);
    float _e70 = uniforms.flashlightParams.y;
    float base_intensity = ((1.0 - (falloff * falloff)) * _e70) * 0.35;
    result.screenIntensity = base_intensity;
    float _e78 = uniforms.flashlightDir.w;
    if (_e78 <= 0.0) {
        FlashlightResult _e81 = result;
        return _e81;
    }
    metal::float4 _e84 = uniforms.flashlightPos;
    metal::float3 to_fragment = world_pos_1 - _e84.xyz;
    metal::float4 _e89 = uniforms.flashlightDir;
    float dist_along_axis = metal::dot(to_fragment, _e89.xyz);
    float _e97 = uniforms.flashlightPos.w;
    if ((dist_along_axis <= 0.0) || (dist_along_axis > _e97)) {
        FlashlightResult _e100 = result;
        return _e100;
    }
    metal::float3 dir_norm = metal::normalize(to_fragment);
    metal::float4 _e104 = uniforms.flashlightDir;
    float spot = metal::dot(dir_norm, _e104.xyz);
    float cutoff = uniforms.flashlightDir.w;
    if (spot <= cutoff) {
        FlashlightResult _e112 = result;
        return _e112;
    }
    float focus = metal::pow((spot - cutoff) / metal::max(1.0 - cutoff, 0.001), 2.0);
    metal::float4 _e123 = uniforms.flashlightDir;
    float ndotl_1 = metal::max(metal::dot(normal_1, _e123.xyz), 0.0);
    float _e131 = uniforms.flashlightPos.w;
    float distance_atten = metal::clamp(1.0 - (dist_along_axis / _e131), 0.0, 1.0);
    float _e143 = uniforms.flashlightParams.y;
    beam = base_intensity + ((((focus * ndotl_1) * distance_atten) * _e143) * 0.5);
    float _e149 = beam;
    float _e153 = uniforms.flashlightParams.y;
    beam = metal::min(_e149, _e153 * 0.7);
    float _e158 = beam;
    result.screenIntensity = _e158;
    metal::float3 light_color_2 = metal::float3(1.0, 0.95, 0.85);
    float _e166 = uniforms.flashlightParams.y;
    float physical_intensity = (distance_atten * _e166) * focus;
    metal::float3 _e170 = cook_torrance_brdf(normal_1, view_dir_2, dir_norm, albedo_2, metallic_3, roughness_6, f0_3, light_color_2, physical_intensity);
    result.shading = _e170;
    FlashlightResult _e171 = result;
    return _e171;
}

uint naga_f2u32(float value) {
    return static_cast<uint>(metal::clamp(value, 0.0, 4294967000.0));
}

uint compute_material_index(
    float surface_type
) {
    float rounded = metal::floor(surface_type + 0.5);
    float clamped_1 = metal::clamp(rounded, 0.0, 6.0);
    return naga_f2u32(clamped_1);
}

metal::float2 parallax_occlusion(
    metal::float2 uv_2,
    metal::float3 view_ts,
    metal::float3 _normal,
    float height_scale,
    int steps,
    metal::texture2d<float, metal::access::sample> heightTexture,
    metal::sampler sharedSampler
) {
    float current_depth = 0.0;
    metal::float2 current_uv = {};
    float prev_depth_map = 0.0;
    metal::float2 prev_uv = {};
    int i_1 = 0;
    int num_steps = metal::max(steps, 1);
    float layer_depth = 1.0 / static_cast<float>(num_steps);
    metal::float3 view_dir_3 = metal::normalize(view_ts);
    if (metal::abs(view_dir_3.z) < 0.001) {
        return uv_2;
    }
    metal::float2 offset_dir = (view_dir_3.xy / metal::float2(view_dir_3.z)) * height_scale;
    current_uv = uv_2;
    prev_uv = uv_2;
    bool loop_init_1 = true;
    while(true) {
        if (!loop_init_1) {
            int _e61 = i_1;
            i_1 = as_type<int>(as_type<uint>(_e61) + as_type<uint>(1));
        }
        loop_init_1 = false;
        int _e28 = i_1;
        if (_e28 < num_steps) {
        } else {
            break;
        }
        {
            metal::float2 _e31 = current_uv;
            current_uv = _e31 - (offset_dir * layer_depth);
            metal::float2 _e35 = current_uv;
            metal::float4 _e36 = heightTexture.sample(sharedSampler, _e35);
            float depth_map = _e36.x;
            float _e38 = current_depth;
            if (_e38 >= depth_map) {
                float _e40 = prev_depth_map;
                float _e41 = current_depth;
                float _e44 = current_depth;
                metal::float2 delta_1 = metal::float2((_e40 - _e41) + layer_depth, depth_map - _e44);
                float denom_1 = metal::max(delta_1.x - delta_1.y, 0.0001);
                float weight = delta_1.x / denom_1;
                metal::float2 _e54 = prev_uv;
                return _e54 - (offset_dir * (weight * layer_depth));
            }
            metal::float2 _e58 = current_uv;
            prev_uv = _e58;
            prev_depth_map = depth_map;
            float _e59 = current_depth;
            current_depth = _e59 + layer_depth;
        }
    }
    metal::float2 _e64 = current_uv;
    return _e64;
}

metal::float3x3 build_tbn(
    metal::float3 normal_2
) {
    metal::float3 up = metal::float3(0.0, 1.0, 0.0);
    if (metal::abs(normal_2.y) > 0.9) {
        up = metal::float3(0.0, 0.0, 1.0);
    }
    metal::float3 _e14 = up;
    metal::float3 tangent = metal::normalize(metal::cross(_e14, normal_2));
    metal::float3 bitangent = metal::cross(normal_2, tangent);
    return metal::float3x3(tangent, bitangent, normal_2);
}

struct main_Input {
    float surfaceType [[user(loc0), center_perspective]];
    metal::float2 uv [[user(loc1), center_perspective]];
    metal::float3 normal [[user(loc2), center_perspective]];
    metal::float3 worldPos [[user(loc3), center_perspective]];
};
struct main_Output {
    metal::float4 member [[color(0)]];
};
fragment main_Output main_(
  main_Input varyings [[stage_in]]
, metal::float4 frag_coord [[position]]
, metal::texture2d<float, metal::access::sample> floorTexture [[texture(0)]]
, metal::texture2d<float, metal::access::sample> wallTexture [[texture(1)]]
, metal::texture2d<float, metal::access::sample> ceilingTexture [[texture(2)]]
, metal::texture2d<float, metal::access::sample> sphereTexture [[texture(3)]]
, metal::texture2d<float, metal::access::sample> bookTexture [[texture(4)]]
, metal::texture2d<float, metal::access::sample> chairTexture [[texture(5)]]
, metal::texture2d<float, metal::access::sample> debugAlbedoTexture [[texture(6)]]
, metal::texture2d<float, metal::access::sample> normalTexture [[texture(7)]]
, metal::texture2d<float, metal::access::sample> metallicRoughnessTexture [[texture(8)]]
, metal::texture2d<float, metal::access::sample> emissiveTexture [[texture(9)]]
, metal::texture2d<float, metal::access::sample> heightTexture [[texture(10)]]
, metal::sampler sharedSampler [[sampler(0)]]
, constant SceneUniforms& uniforms [[buffer(0)]]
) {
    const FragmentInput input = { varyings.surfaceType, {}, varyings.uv, varyings.normal, varyings.worldPos };
    metal::float3 sampledAlbedo = {};
    metal::float3 sampledNormal = {};
    metal::float2 sampledMR = {};
    metal::float3 sampledEmissive = {};
    metal::float3 baseColor = {};
    metal::float3 n = {};
    metal::float3 view_dir = {};
    float metallic = {};
    float roughness = {};
    metal::float3 emissive = metal::float3(0.0);
    metal::float2 uv = {};
    metal::float3 color = {};
    metal::float4 floorColor = floorTexture.sample(sharedSampler, input.uv);
    metal::float4 wallColor = wallTexture.sample(sharedSampler, input.uv);
    metal::float4 ceilingColor = ceilingTexture.sample(sharedSampler, input.uv);
    metal::float4 sphereColor = sphereTexture.sample(sharedSampler, input.uv);
    metal::float4 bookColor = bookTexture.sample(sharedSampler, input.uv);
    metal::float4 chairColor = chairTexture.sample(sharedSampler, input.uv);
    metal::float4 _e29 = debugAlbedoTexture.sample(sharedSampler, input.uv);
    sampledAlbedo = _e29.xyz;
    metal::float4 _e35 = normalTexture.sample(sharedSampler, input.uv);
    sampledNormal = (_e35.xyz * 2.0) - metal::float3(1.0);
    metal::float4 _e46 = metallicRoughnessTexture.sample(sharedSampler, input.uv);
    sampledMR = _e46.xy;
    metal::float4 _e52 = emissiveTexture.sample(sharedSampler, input.uv);
    sampledEmissive = _e52.xyz;
    if (input.surfaceType < 0.5) {
        baseColor = floorColor.xyz;
    } else {
        if (input.surfaceType < 1.5) {
            metal::float3 _e63 = sampledAlbedo;
            baseColor = _e63;
        } else {
            if (input.surfaceType < 2.5) {
                baseColor = ceilingColor.xyz;
            } else {
                if (input.surfaceType < 3.5) {
                    float _e76 = checker(input.uv);
                    baseColor = metal::float3(0.7, 0.5, 0.3) * _e76;
                } else {
                    if (input.surfaceType < 4.5) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if (input.surfaceType < 5.5) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    n = metal::normalize(input.normal);
    uint _e93 = compute_material_index(input.surfaceType);
    Material material = uniforms.materials.inner[_e93];
    metal::float4 _e98 = uniforms.cameraPos;
    view_dir = _e98.xyz - input.worldPos;
    metal::float3 _e103 = view_dir;
    float view_len = metal::length(_e103);
    if (view_len > 0.0001) {
        metal::float3 _e107 = view_dir;
        view_dir = _e107 / metal::float3(view_len);
    } else {
        view_dir = metal::float3(0.0, 0.0, 1.0);
    }
    bool use_pbr_debug = (input.surfaceType > 0.5) && (input.surfaceType < 1.5);
    metallic = material.metalness;
    roughness = metal::max(material.roughness, 0.04);
    if (use_pbr_debug) {
        metal::float3 _e130 = n;
        metal::float3x3 _e131 = build_tbn(_e130);
        metal::float3 _e133 = view_dir;
        metal::float3 view_ts_1 = metal::transpose(_e131) * _e133;
        uv = input.uv * 8.0;
        metal::float4 _e141 = uniforms.cameraPos;
        if (metal::distance(_e141.xyz, input.worldPos) < 15.0) {
            metal::float2 _e147 = uv;
            metal::float3 _e148 = n;
            metal::float2 _e151 = parallax_occlusion(_e147, view_ts_1, _e148, 0.35, 72, heightTexture, sharedSampler);
            uv = _e151;
        }
        metal::float2 _e154 = uv;
        metal::float4 _e155 = debugAlbedoTexture.sample(sharedSampler, _e154);
        sampledAlbedo = _e155.xyz;
        metal::float2 _e159 = uv;
        metal::float4 _e160 = normalTexture.sample(sharedSampler, _e159);
        sampledNormal = (_e160.xyz * 2.0) - metal::float3(1.0);
        metal::float2 _e169 = uv;
        metal::float4 _e170 = metallicRoughnessTexture.sample(sharedSampler, _e169);
        sampledMR = _e170.xy;
        metal::float2 _e174 = uv;
        metal::float4 _e175 = emissiveTexture.sample(sharedSampler, _e174);
        sampledEmissive = _e175.xyz;
        metal::float3 _e177 = sampledAlbedo;
        baseColor = _e177;
        metal::float3 _e178 = sampledNormal;
        n = metal::normalize(_e131 * _e178);
        float _e182 = sampledMR.x;
        metallic = metal::clamp(_e182 * material.metalness, 0.0, 1.0);
        float _e189 = sampledMR.y;
        roughness = metal::clamp(_e189 * material.roughness, 0.04, 1.0);
        metal::float3 _e195 = sampledEmissive;
        emissive = _e195 * material.emissiveIntensity;
    } else {
        metallic = material.metalness;
        roughness = metal::max(material.roughness, 0.04);
        emissive = metal::float3(0.0);
    }
    float _e207 = uniforms.screenParams.w;
    if (_e207 > 0.5) {
        metal::float3 _e210 = n;
        metal::float3 mapped = (_e210 * 0.5) + metal::float3(0.5);
        return main_Output { metal::float4(mapped, 1.0) };
    }
    float dielectric_ior = metal::max(material.ior, 1.0);
    float dielectric_f0_ = metal::pow((dielectric_ior - 1.0) / (dielectric_ior + 1.0), 2.0);
    metal::float3 base_reflectance = metal::float3(dielectric_f0_);
    metal::float3 _e229 = baseColor;
    float _e230 = metallic;
    metal::float3 f0_4 = metal::mix(base_reflectance, _e229, metal::float3(_e230));
    metal::float3 _e233 = n;
    metal::float3 _e235 = view_dir;
    metal::float3 _e236 = baseColor;
    float _e237 = metallic;
    float _e238 = roughness;
    metal::float3 _e239 = compute_static_lighting(_e233, input.worldPos, _e235, _e236, _e237, _e238, f0_4, uniforms);
    metal::float3 _e240 = n;
    metal::float3 _e242 = view_dir;
    metal::float3 _e243 = baseColor;
    float _e244 = metallic;
    float _e245 = roughness;
    FlashlightResult _e246 = compute_flashlight(_e240, input.worldPos, frag_coord, _e242, _e243, _e244, _e245, f0_4, uniforms);
    float ambient = uniforms.staticLightParams.z;
    metal::float4 _e254 = uniforms.cameraPos;
    float fogFactor = metal::exp(-(metal::distance(input.worldPos, _e254.xyz)) * 0.08);
    metal::float3 _e261 = baseColor;
    color = _e261 * (ambient + _e246.screenIntensity);
    metal::float3 _e266 = color;
    color = _e266 + _e239;
    metal::float3 _e269 = color;
    color = _e269 + _e246.shading;
    metal::float3 _e271 = emissive;
    metal::float3 _e272 = color;
    color = _e272 + _e271;
    metal::float3 _e274 = color;
    metal::float3 _e275 = color;
    color = _e274 / (_e275 + metal::float3(1.0));
    metal::float3 _e280 = color;
    color = metal::pow(_e280, metal::float3(0.45454547));
    metal::float4 _e286 = uniforms.fogColor;
    metal::float3 _e288 = color;
    color = metal::mix(_e286.xyz, _e288, fogFactor);
    metal::float3 _e290 = color;
    return main_Output { metal::float4(_e290, 1.0) };
}
