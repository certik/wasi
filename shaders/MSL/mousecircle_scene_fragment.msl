// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

// language: metal1.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct type_4 {
    metal::float4 inner[16];
};
struct type_5 {
    metal::float4 inner[3];
};
struct SceneUniforms {
    metal::float4x4 mvp;
    metal::float4 cameraPos;
    metal::float4 fogColor;
    type_4 staticLights;
    type_4 staticLightColors;
    metal::float4 staticLightParams;
    metal::float4 flashlightPos;
    metal::float4 flashlightDir;
    metal::float4 flashlightParams;
    metal::float4 screenParams;
    type_5 radianceCascadeOrigins;
    metal::float4 radianceCascadeSpacing;
    metal::float4 giParams;
};
struct FragmentInput {
    float surfaceType;
    char _pad1[4];
    metal::float2 uv;
    metal::float3 normal;
    metal::float3 worldPos;
};
struct FlashlightContribution {
    float diffuse;
    float specular;
};
struct StaticLightContribution {
    metal::float3 diffuse;
    metal::float3 specular;
};
struct MaterialProperties {
    float shininess;
    float specularStrength;
};
constant uint MAX_STATIC_LIGHTS = 16u;
constant uint RADIANCE_CASCADE_COUNT = 3u;
constant float RADIANCE_DIM = 32.0;

float checker(
    metal::float2 uv
) {
    metal::float2 scaled = metal::floor(uv * 4.0);
    float v = metal::fmod(scaled.x + scaled.y, 2.0);
    return (v < 0.5) ? 1.0 : 0.7;
}

MaterialProperties get_material_properties(
    float surface_type
) {
    if (surface_type < 0.5) {
        return MaterialProperties {12.0, 0.15};
    } else {
        if (surface_type < 1.5) {
            return MaterialProperties {18.0, 0.2};
        } else {
            if (surface_type < 2.5) {
                return MaterialProperties {14.0, 0.18};
            } else {
                if (surface_type < 3.5) {
                    return MaterialProperties {28.0, 0.35};
                } else {
                    if (surface_type < 4.5) {
                        return MaterialProperties {48.0, 0.8};
                    } else {
                        if (surface_type < 5.5) {
                            return MaterialProperties {36.0, 0.4};
                        } else {
                            if (surface_type < 6.5) {
                                return MaterialProperties {30.0, 0.5};
                            }
                        }
                    }
                }
            }
        }
    }
    return MaterialProperties {22.0, 0.35};
}

int naga_f2i32(float value) {
    return static_cast<int>(metal::clamp(value, -2147483600.0, 2147483500.0));
}

StaticLightContribution compute_static_lighting(
    metal::float3 normal,
    metal::float3 world_pos,
    metal::float3 view_dir_1,
    MaterialProperties material,
    constant SceneUniforms& uniforms
) {
    metal::float3 total_diffuse = metal::float3(0.0);
    metal::float3 total_specular = metal::float3(0.0);
    int i = 0;
    float range_falloff = {};
    float _e7 = uniforms.staticLightParams.x;
    int light_count = metal::clamp(naga_f2i32(_e7), 0, 16);
    float range = uniforms.staticLightParams.y;
    if ((range <= 0.0) || (light_count == 0)) {
        return StaticLightContribution {metal::float3(0.0), metal::float3(0.0)};
    }
    float shininess = metal::max(material.shininess, 1.0);
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            int _e105 = i;
            i = as_type<int>(as_type<uint>(_e105) + as_type<uint>(1));
        }
        loop_init = false;
        int _e37 = i;
        if (_e37 < light_count) {
        } else {
            break;
        }
        {
            int _e41 = i;
            metal::float4 light_data = uniforms.staticLights.inner[static_cast<uint>(_e41)];
            metal::float3 to_light = light_data.xyz - world_pos;
            float dist = metal::length(to_light);
            if (dist <= 0.0001) {
                continue;
            }
            metal::float3 dir = to_light / metal::float3(dist);
            float ndotl = metal::max(metal::dot(normal, dir), 0.0);
            if (ndotl <= 0.0) {
                continue;
            }
            range_falloff = 1.0;
            if (range > 0.0) {
                if (dist > range) {
                    continue;
                }
                range_falloff = metal::clamp(1.0 - (dist / range), 0.0, 1.0);
            }
            float inv = 1.0 / ((1.0 + (0.09 * dist)) + ((0.032 * dist) * dist));
            float _e78 = range_falloff;
            float attenuation = inv * _e78;
            metal::float3 H = metal::normalize(dir + view_dir_1);
            float spec = metal::pow(metal::max(metal::dot(normal, H), 0.0), shininess);
            int _e88 = i;
            metal::float4 _e91 = uniforms.staticLightColors.inner[static_cast<uint>(_e88)];
            metal::float3 light_color = _e91.xyz;
            metal::float3 _e95 = total_diffuse;
            total_diffuse = _e95 + ((ndotl * attenuation) * light_color);
            metal::float3 _e103 = total_specular;
            total_specular = _e103 + ((((material.specularStrength * spec) * attenuation) * light_color) * 0.5);
        }
    }
    metal::float3 _e108 = total_diffuse;
    metal::float3 _e109 = total_specular;
    return StaticLightContribution {_e108, _e109};
}

FlashlightContribution compute_flashlight(
    metal::float3 normal_1,
    metal::float3 world_pos_1,
    metal::float4 frag_coord_1,
    metal::float3 view_dir_2,
    MaterialProperties material_1,
    constant SceneUniforms& uniforms
) {
    float beam = {};
    float _e8 = uniforms.flashlightParams.x;
    if (_e8 < 0.5) {
        return FlashlightContribution {0.0, 0.0};
    }
    float width = uniforms.screenParams.x;
    float height = uniforms.screenParams.y;
    float min_dim = uniforms.screenParams.z;
    if (((width <= 0.0) || (height <= 0.0)) || (min_dim <= 0.0)) {
        return FlashlightContribution {0.0, 0.0};
    }
    metal::float2 pixel = frag_coord_1.xy;
    metal::float2 center = metal::float2(width * 0.5, height * 0.5);
    metal::float2 delta = (pixel - center) / metal::float2(min_dim);
    float radius = uniforms.flashlightParams.w;
    if (radius <= 0.0) {
        return FlashlightContribution {0.0, 0.0};
    }
    float dist_1 = metal::length(delta);
    if (dist_1 > radius) {
        return FlashlightContribution {0.0, 0.0};
    }
    float falloff = metal::clamp(dist_1 / radius, 0.0, 1.0);
    float _e70 = uniforms.flashlightParams.y;
    float base_intensity = ((1.0 - (falloff * falloff)) * _e70) * 0.35;
    float _e77 = uniforms.flashlightDir.w;
    if (_e77 <= 0.0) {
        return FlashlightContribution {base_intensity, 0.0};
    }
    metal::float4 _e84 = uniforms.flashlightPos;
    metal::float3 to_fragment = world_pos_1 - _e84.xyz;
    metal::float4 _e89 = uniforms.flashlightDir;
    float dist_along_axis = metal::dot(to_fragment, _e89.xyz);
    float _e97 = uniforms.flashlightPos.w;
    if ((dist_along_axis <= 0.0) || (dist_along_axis > _e97)) {
        return FlashlightContribution {base_intensity, 0.0};
    }
    metal::float3 dir_norm = metal::normalize(to_fragment);
    metal::float4 _e105 = uniforms.flashlightDir;
    float spot = metal::dot(dir_norm, _e105.xyz);
    float cutoff = uniforms.flashlightDir.w;
    if (spot <= cutoff) {
        return FlashlightContribution {base_intensity, 0.0};
    }
    float focus = metal::pow((spot - cutoff) / metal::max(1.0 - cutoff, 0.001), 2.0);
    metal::float4 _e125 = uniforms.flashlightDir;
    float ndotl_1 = metal::max(metal::dot(normal_1, _e125.xyz), 0.0);
    float _e133 = uniforms.flashlightPos.w;
    float distance_atten = metal::clamp(1.0 - (dist_along_axis / _e133), 0.0, 1.0);
    metal::float4 _e142 = uniforms.flashlightDir;
    metal::float3 half_dir = metal::normalize(_e142.xyz + view_dir_2);
    float spec_1 = metal::pow(metal::max(metal::dot(normal_1, half_dir), 0.0), metal::max(material_1.shininess, 1.0));
    float _e158 = uniforms.flashlightParams.y;
    beam = base_intensity + ((((focus * ndotl_1) * distance_atten) * _e158) * 0.5);
    float _e164 = beam;
    float _e168 = uniforms.flashlightParams.y;
    beam = metal::min(_e164, _e168 * 0.7);
    float _e179 = uniforms.flashlightParams.y;
    float specular = ((((spec_1 * focus) * distance_atten) * 0.15) * _e179) * material_1.specularStrength;
    float _e183 = beam;
    return FlashlightContribution {_e183, specular};
}

metal::float4 sample_radiance_texture(
    uint index,
    metal::uint2 coord,
    metal::texture2d<float, metal::access::sample> radianceCascade0_,
    metal::texture2d<float, metal::access::sample> radianceCascade1_,
    metal::texture2d<float, metal::access::sample> radianceCascade2_
) {
    if (index == 0u) {
        metal::float4 _e6 = radianceCascade0_.read(metal::uint2(coord), 0);
        return _e6;
    } else {
        if (index == 1u) {
            metal::float4 _e11 = radianceCascade1_.read(metal::uint2(coord), 0);
            return _e11;
        }
    }
    metal::float4 _e14 = radianceCascade2_.read(metal::uint2(coord), 0);
    return _e14;
}

metal::uint3 naga_f2u32(metal::float3 value) {
    return static_cast<metal::uint3>(metal::clamp(value, 0.0, 4294967000.0));
}

metal::float4 sample_radiance_cascade(
    uint index_1,
    metal::float3 world_pos_2,
    metal::texture2d<float, metal::access::sample> radianceCascade0_,
    metal::texture2d<float, metal::access::sample> radianceCascade1_,
    metal::texture2d<float, metal::access::sample> radianceCascade2_,
    constant SceneUniforms& uniforms
) {
    if (index_1 >= RADIANCE_CASCADE_COUNT) {
        return metal::float4(0.0);
    }
    metal::float4 origin = uniforms.radianceCascadeOrigins.inner[index_1];
    float spacing = origin.w;
    if (spacing <= 0.0) {
        return metal::float4(0.0);
    }
    metal::float3 local = (world_pos_2 - origin.xyz) / metal::float3(spacing);
    if (metal::any(local < metal::float3(0.0)) || metal::any(local > metal::float3(31.0))) {
        return metal::float4(0.0);
    }
    metal::uint3 p0_ = naga_f2u32(metal::clamp(local, metal::float3(0.0), metal::float3(31.0)));
    metal::uint3 p1_ = naga_f2u32(metal::clamp(static_cast<metal::float3>(p0_) + metal::float3(1.0), metal::float3(0.0), metal::float3(31.0)));
    metal::float3 t = metal::fract(local);
    uint to_flat = (p0_.z * 32u) + p0_.y;
    uint to_flat1_ = (p1_.z * 32u) + p1_.y;
    metal::float4 _e58 = sample_radiance_texture(index_1, metal::uint2(p0_.x, to_flat), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e61 = sample_radiance_texture(index_1, metal::uint2(p1_.x, to_flat), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e64 = sample_radiance_texture(index_1, metal::uint2(p0_.x, to_flat1_), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e67 = sample_radiance_texture(index_1, metal::uint2(p1_.x, to_flat1_), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e71 = sample_radiance_texture(index_1, metal::uint2(p0_.x, to_flat + 32u), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e75 = sample_radiance_texture(index_1, metal::uint2(p1_.x, to_flat + 32u), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e79 = sample_radiance_texture(index_1, metal::uint2(p0_.x, to_flat1_ + 32u), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 _e83 = sample_radiance_texture(index_1, metal::uint2(p1_.x, to_flat1_ + 32u), radianceCascade0_, radianceCascade1_, radianceCascade2_);
    metal::float4 c00_ = metal::mix(_e58, _e61, t.x);
    metal::float4 c10_ = metal::mix(_e64, _e67, t.x);
    metal::float4 c01_ = metal::mix(_e71, _e75, t.x);
    metal::float4 c11_ = metal::mix(_e79, _e83, t.x);
    metal::float4 c0_ = metal::mix(c00_, c10_, t.y);
    metal::float4 c1_ = metal::mix(c01_, c11_, t.y);
    return metal::mix(c0_, c1_, t.z);
}

metal::float3 sample_radiance(
    metal::float3 world_pos_3,
    metal::texture2d<float, metal::access::sample> radianceCascade0_,
    metal::texture2d<float, metal::access::sample> radianceCascade1_,
    metal::texture2d<float, metal::access::sample> radianceCascade2_,
    constant SceneUniforms& uniforms
) {
    metal::float3 accum = metal::float3(0.0);
    float weight = 0.0;
    float _e4 = uniforms.giParams.x;
    if (_e4 < 0.5) {
        return metal::float3(0.0);
    }
    metal::float4 _e15 = sample_radiance_cascade(0u, world_pos_3, radianceCascade0_, radianceCascade1_, radianceCascade2_, uniforms);
    if (_e15.w > 0.0) {
        metal::float3 _e22 = accum;
        accum = _e22 + (_e15.xyz * _e15.w);
        float _e25 = weight;
        weight = _e25 + _e15.w;
    }
    metal::float4 _e28 = sample_radiance_cascade(1u, world_pos_3, radianceCascade0_, radianceCascade1_, radianceCascade2_, uniforms);
    if (_e28.w > 0.0) {
        metal::float3 _e35 = accum;
        accum = _e35 + (_e28.xyz * _e28.w);
        float _e38 = weight;
        weight = _e38 + _e28.w;
    }
    metal::float4 _e41 = sample_radiance_cascade(2u, world_pos_3, radianceCascade0_, radianceCascade1_, radianceCascade2_, uniforms);
    if (_e41.w > 0.0) {
        metal::float3 _e48 = accum;
        accum = _e48 + (_e41.xyz * _e41.w);
        float _e51 = weight;
        weight = _e51 + _e41.w;
    }
    float _e53 = weight;
    if (_e53 > 0.0) {
        metal::float3 _e56 = accum;
        float _e57 = weight;
        return _e56 / metal::float3(_e57);
    }
    metal::float3 _e60 = accum;
    return _e60;
}

struct main_Input {
    float surfaceType [[user(loc0), center_perspective]];
    metal::float2 uv [[user(loc1), center_perspective]];
    metal::float3 normal [[user(loc2), center_perspective]];
    metal::float3 worldPos [[user(loc3), center_perspective]];
};
struct main_Output {
    metal::float4 member [[color(0)]];
};
fragment main_Output main_(
  main_Input varyings [[stage_in]]
, metal::float4 frag_coord [[position]]
, metal::texture2d<float, metal::access::sample> floorTexture [[texture(0)]]
, metal::texture2d<float, metal::access::sample> wallTexture [[texture(1)]]
, metal::texture2d<float, metal::access::sample> ceilingTexture [[texture(2)]]
, metal::texture2d<float, metal::access::sample> windowTexture [[texture(3)]]
, metal::texture2d<float, metal::access::sample> sphereTexture [[texture(4)]]
, metal::texture2d<float, metal::access::sample> bookTexture [[texture(5)]]
, metal::texture2d<float, metal::access::sample> chairTexture [[texture(6)]]
, metal::sampler sharedSampler [[sampler(0)]]
, metal::texture2d<float, metal::access::sample> radianceCascade0_ [[texture(7)]]
, metal::texture2d<float, metal::access::sample> radianceCascade1_ [[texture(8)]]
, metal::texture2d<float, metal::access::sample> radianceCascade2_ [[texture(9)]]
, constant SceneUniforms& uniforms [[buffer(0)]]
) {
    const FragmentInput input = { varyings.surfaceType, {}, varyings.uv, varyings.normal, varyings.worldPos };
    metal::float3 baseColor = {};
    metal::float3 view_dir = {};
    metal::float3 color = {};
    metal::float4 floorColor = floorTexture.sample(sharedSampler, input.uv);
    metal::float4 wallColor = wallTexture.sample(sharedSampler, input.uv);
    metal::float4 ceilingColor = ceilingTexture.sample(sharedSampler, input.uv);
    metal::float4 windowColor = windowTexture.sample(sharedSampler, input.uv);
    metal::float4 sphereColor = sphereTexture.sample(sharedSampler, input.uv);
    metal::float4 bookColor = bookTexture.sample(sharedSampler, input.uv);
    metal::float4 chairColor = chairTexture.sample(sharedSampler, input.uv);
    if (input.surfaceType < 0.5) {
        baseColor = floorColor.xyz;
    } else {
        if (input.surfaceType < 1.5) {
            baseColor = wallColor.xyz;
        } else {
            if (input.surfaceType < 2.5) {
                baseColor = ceilingColor.xyz;
            } else {
                if (input.surfaceType < 3.5) {
                    baseColor = windowColor.xyz;
                } else {
                    if (input.surfaceType < 4.5) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if (input.surfaceType < 5.5) {
                            baseColor = bookColor.xyz;
                        } else {
                            if (input.surfaceType < 6.5) {
                                baseColor = chairColor.xyz;
                            } else {
                                baseColor = metal::float3(0.95, 0.94, 0.88);
                            }
                        }
                    }
                }
            }
        }
    }
    metal::float3 n = metal::normalize(input.normal);
    MaterialProperties _e66 = get_material_properties(input.surfaceType);
    metal::float4 _e69 = uniforms.cameraPos;
    view_dir = _e69.xyz - input.worldPos;
    metal::float3 _e74 = view_dir;
    float view_len = metal::length(_e74);
    if (view_len > 0.0001) {
        metal::float3 _e78 = view_dir;
        view_dir = _e78 / metal::float3(view_len);
    } else {
        view_dir = metal::float3(0.0, 0.0, 1.0);
    }
    metal::float3 _e86 = view_dir;
    StaticLightContribution _e87 = compute_static_lighting(n, input.worldPos, _e86, _e66, uniforms);
    metal::float3 _e89 = view_dir;
    FlashlightContribution _e90 = compute_flashlight(n, input.worldPos, frag_coord, _e89, _e66, uniforms);
    float _e94 = uniforms.screenParams.w;
    if (_e94 > 0.5) {
        metal::float3 mapped = (metal::normalize(input.normal) * 0.5) + metal::float3(0.5);
        return main_Output { metal::float4(mapped, 1.0) };
    }
    float ambient = uniforms.staticLightParams.z;
    metal::float4 _e113 = uniforms.cameraPos;
    float fogFactor = metal::exp(-(metal::distance(input.worldPos, _e113.xyz)) * 0.08);
    metal::float3 _e120 = baseColor;
    color = _e120 * (ambient + _e90.diffuse);
    metal::float3 _e125 = baseColor;
    metal::float3 _e128 = color;
    color = _e128 + (_e125 * _e87.diffuse);
    metal::float3 _e130 = baseColor;
    metal::float3 _e132 = sample_radiance(input.worldPos, radianceCascade0_, radianceCascade1_, radianceCascade2_, uniforms);
    metal::float3 _e134 = color;
    color = _e134 + (_e130 * _e132);
    metal::float3 _e137 = color;
    color = _e137 + _e87.specular;
    metal::float3 _e145 = color;
    color = _e145 + (_e90.specular * metal::float3(1.0, 0.95, 0.85));
    metal::float4 _e149 = uniforms.fogColor;
    metal::float3 _e151 = color;
    color = metal::mix(_e149.xyz, _e151, fogFactor);
    metal::float3 _e153 = color;
    return main_Output { metal::float4(_e153, 1.0) };
}
