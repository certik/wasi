// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

// language: metal1.0
#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

struct type_4 {
    metal::float4 inner[16];
};
struct SceneUniforms {
    metal::float4x4 mvp;
    metal::float4 cameraPos;
    metal::float4 fogColor;
    type_4 staticLights;
    metal::float4 staticLightParams;
    metal::float4 flashlightPos;
    metal::float4 flashlightDir;
    metal::float4 flashlightParams;
};
struct VertexOutput {
    metal::float4 position;
    float surfaceType;
    char _pad2[4];
    metal::float2 uv;
    metal::float3 normal;
    metal::float3 worldPos;
};
constant uint MAX_STATIC_LIGHTS = 16u;

float checker(
    metal::float2 uv
) {
    metal::float2 scaled = metal::floor(uv * 4.0);
    float v = metal::fmod(scaled.x + scaled.y, 2.0);
    return (v < 0.5) ? 1.0 : 0.7;
}

int naga_f2i32(float value) {
    return static_cast<int>(metal::clamp(value, -2147483600.0, 2147483500.0));
}

float compute_static_lighting(
    metal::float3 normal,
    metal::float3 world_pos,
    constant SceneUniforms& uniforms
) {
    float total = 0.0;
    int i = 0;
    float _e5 = uniforms.staticLightParams.x;
    int light_count = metal::clamp(naga_f2i32(_e5), 0, 16);
    float range = uniforms.staticLightParams.y;
    if ((range <= 0.0) || (light_count == 0)) {
        return 0.0;
    }
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            int _e58 = i;
            i = as_type<int>(as_type<uint>(_e58) + as_type<uint>(1));
        }
        loop_init = false;
        int _e24 = i;
        if (_e24 < light_count) {
        } else {
            break;
        }
        {
            int _e28 = i;
            metal::float4 light = uniforms.staticLights.inner[static_cast<uint>(_e28)];
            metal::float3 to_light = light.xyz - world_pos;
            float dist = metal::length(to_light);
            if ((dist > 0.0001) && (dist < range)) {
                metal::float3 dir = to_light / metal::float3(dist);
                float ndotl = metal::max(metal::dot(normal, dir), 0.0);
                if (ndotl > 0.0) {
                    float attenuation = metal::pow(metal::max(1.0 - (dist / range), 0.0), 2.0);
                    float _e56 = total;
                    total = _e56 + ((ndotl * attenuation) * light.w);
                }
            }
        }
    }
    float _e61 = total;
    return _e61;
}

float compute_flashlight(
    metal::float3 normal_1,
    metal::float3 world_pos_1,
    constant SceneUniforms& uniforms
) {
    float focus = {};
    float _e5 = uniforms.flashlightParams.x;
    if (_e5 < 0.5) {
        return 0.0;
    }
    metal::float4 _e11 = uniforms.flashlightPos;
    metal::float3 light_vec = _e11.xyz - world_pos_1;
    float dist_1 = metal::length(light_vec);
    float _e20 = uniforms.flashlightPos.w;
    if ((dist_1 <= 0.0001) || (dist_1 > _e20)) {
        return 0.0;
    }
    metal::float3 dir_1 = light_vec / metal::float3(dist_1);
    float ndotl_1 = metal::max(metal::dot(normal_1, dir_1), 0.0);
    if (ndotl_1 <= 0.0) {
        return 0.0;
    }
    float cutoff = uniforms.flashlightDir.w;
    float _e39 = uniforms.flashlightParams.z;
    float softness = metal::clamp(_e39, 0.05, 0.95);
    float inner = metal::mix(cutoff, 1.0, softness);
    metal::float4 _e47 = uniforms.flashlightDir;
    float spot = metal::dot(dir_1, _e47.xyz);
    if (spot <= cutoff) {
        return 0.0;
    }
    float denom = metal::max(inner - cutoff, 0.001);
    focus = metal::clamp((spot - cutoff) / denom, 0.0, 1.0);
    float _e61 = focus;
    float _e62 = focus;
    focus = _e61 * _e62;
    float _e67 = uniforms.flashlightPos.w;
    float attenuation_1 = metal::pow(metal::max(1.0 - (dist_1 / _e67), 0.0), 2.0);
    float _e75 = focus;
    float _e81 = uniforms.flashlightParams.y;
    return ((ndotl_1 * _e75) * attenuation_1) * _e81;
}

struct main_Input {
    float surfaceType [[user(loc0), center_perspective]];
    metal::float2 uv [[user(loc1), center_perspective]];
    metal::float3 normal [[user(loc2), center_perspective]];
    metal::float3 worldPos [[user(loc3), center_perspective]];
};
struct main_Output {
    metal::float4 member [[color(0)]];
};
fragment main_Output main_(
  main_Input varyings [[stage_in]]
, metal::float4 position [[position]]
, metal::texture2d<float, metal::access::sample> floorTexture [[texture(0)]]
, metal::texture2d<float, metal::access::sample> wallTexture [[texture(1)]]
, metal::texture2d<float, metal::access::sample> ceilingTexture [[texture(2)]]
, metal::texture2d<float, metal::access::sample> sphereTexture [[texture(3)]]
, metal::texture2d<float, metal::access::sample> bookTexture [[texture(4)]]
, metal::texture2d<float, metal::access::sample> chairTexture [[texture(5)]]
, metal::sampler sharedSampler [[sampler(0)]]
, constant SceneUniforms& uniforms [[buffer(0)]]
) {
    const VertexOutput input = { position, varyings.surfaceType, {}, varyings.uv, varyings.normal, varyings.worldPos };
    metal::float3 baseColor = {};
    float lighting = {};
    metal::float3 color = {};
    metal::float4 floorColor = floorTexture.sample(sharedSampler, input.uv);
    metal::float4 wallColor = wallTexture.sample(sharedSampler, input.uv);
    metal::float4 ceilingColor = ceilingTexture.sample(sharedSampler, input.uv);
    metal::float4 sphereColor = sphereTexture.sample(sharedSampler, input.uv);
    metal::float4 bookColor = bookTexture.sample(sharedSampler, input.uv);
    metal::float4 chairColor = chairTexture.sample(sharedSampler, input.uv);
    if (input.surfaceType < 0.5) {
        baseColor = floorColor.xyz;
    } else {
        if (input.surfaceType < 1.5) {
            baseColor = wallColor.xyz;
        } else {
            if (input.surfaceType < 2.5) {
                baseColor = ceilingColor.xyz;
            } else {
                if (input.surfaceType < 3.5) {
                    float _e46 = checker(input.uv);
                    baseColor = metal::float3(0.7, 0.5, 0.3) * _e46;
                } else {
                    if (input.surfaceType < 4.5) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if (input.surfaceType < 5.5) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    metal::float3 n = metal::normalize(input.normal);
    float _e60 = compute_static_lighting(n, input.worldPos, uniforms);
    float _e62 = compute_flashlight(n, input.worldPos, uniforms);
    float ambient = uniforms.staticLightParams.z;
    lighting = (ambient + _e60) + _e62;
    float _e70 = lighting;
    lighting = metal::clamp(_e70, ambient, 6.0);
    metal::float4 _e76 = uniforms.cameraPos;
    float fogFactor = metal::exp(-(metal::distance(input.worldPos, _e76.xyz)) * 0.08);
    metal::float3 _e83 = baseColor;
    float _e84 = lighting;
    color = _e83 * _e84;
    metal::float4 _e89 = uniforms.fogColor;
    metal::float3 _e91 = color;
    color = metal::mix(_e89.xyz, _e91, fogFactor);
    metal::float3 _e93 = color;
    return main_Output { metal::float4(_e93, 1.0) };
}
