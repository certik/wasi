// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
};

struct VertexOutput {
    float4 position : SV_Position;
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
}
Texture2D<float4> floorTexture : register(t0, space2);
SamplerState floorSampler : register(s0, space2);
Texture2D<float4> wallTexture : register(t1, space2);
SamplerState wallSampler : register(s1, space2);
Texture2D<float4> ceilingTexture : register(t2, space2);
SamplerState ceilingSampler : register(s2, space2);
Texture2D<float4> sphereTexture : register(t3, space2);
SamplerState sphereSampler : register(s3, space2);
Texture2D<float4> bookTexture : register(t4, space2);
SamplerState bookSampler : register(s4, space2);
Texture2D<float4> chairTexture : register(t5, space2);
SamplerState chairSampler : register(s5, space2);

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_1 : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 position : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv)
{
    float2 scaled = floor((uv * 4.0));
    float v = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v < 0.5) ? 1.0 : 0.7);
}

float4 main_(FragmentInput_main fragmentinput_main) : SV_Target0
{
    VertexOutput input = { fragmentinput_main.position, fragmentinput_main.surfaceType, fragmentinput_main.uv_1, fragmentinput_main.normal, fragmentinput_main.worldPos };
    float3 baseColor = (float3)0;
    float diff = (float)0;
    float3 color = (float3)0;

    float4 floorColor = floorTexture.Sample(floorSampler, input.uv);
    float4 wallColor = wallTexture.Sample(wallSampler, input.uv);
    float4 ceilingColor = ceilingTexture.Sample(ceilingSampler, input.uv);
    float4 sphereColor = sphereTexture.Sample(sphereSampler, input.uv);
    float4 bookColor = bookTexture.Sample(bookSampler, input.uv);
    float4 chairColor = chairTexture.Sample(chairSampler, input.uv);
    if ((input.surfaceType < 0.5)) {
        baseColor = floorColor.xyz;
    } else {
        if ((input.surfaceType < 1.5)) {
            baseColor = wallColor.xyz;
        } else {
            if ((input.surfaceType < 2.5)) {
                baseColor = ceilingColor.xyz;
            } else {
                if ((input.surfaceType < 3.5)) {
                    const float _e46 = checker(input.uv);
                    baseColor = (float3(0.7, 0.5, 0.3) * _e46);
                } else {
                    if ((input.surfaceType < 4.5)) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if ((input.surfaceType < 5.5)) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    float3 n = normalize(input.normal);
    float3 lightDir = normalize(float3(0.35, 1.0, 0.45));
    diff = max(dot(n, lightDir), 0.15);
    if (((input.surfaceType >= 1.5) && (input.surfaceType < 2.5))) {
        diff = 1.0;
    }
    if (((input.surfaceType >= 3.5) && (input.surfaceType < 4.5))) {
        diff = 1.0;
    }
    float4 _e87 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e87.xyz)) * 0.08));
    float3 _e94 = baseColor;
    float _e95 = diff;
    color = (_e94 * _e95);
    float4 _e100 = fogColor;
    float3 _e102 = color;
    color = lerp(_e100.xyz, _e102, fogFactor);
    float3 _e104 = color;
    return float4(_e104, 1.0);
}