// AUTO-GENERATED from WGSL\mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
};

struct VertexOutput {
    float4 position : SV_Position;
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
}

Texture2D floorTexture : register(t0, space2);
SamplerState floorSampler : register(s0, space2);

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_1 : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 position : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv)
{
    float2 scaled = floor((uv * 4.0));
    float v = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v < 0.5) ? 1.0 : 0.7);
}

float4 main(FragmentInput_main fragmentinput_main) : SV_Target0
{
    VertexOutput input = { fragmentinput_main.position, fragmentinput_main.surfaceType, fragmentinput_main.uv_1, fragmentinput_main.normal, fragmentinput_main.worldPos };
    // Sample texture unconditionally (required for uniform control flow)
    float4 texColor = floorTexture.Sample(floorSampler, input.uv);
    
    float3 baseColor = (float3)0;
    float3 color = (float3)0;

    if ((input.surfaceType < 0.5)) {
        // Floor: use sampled texture
        baseColor = texColor.rgb;
    } else {
        if ((input.surfaceType < 1.5)) {
            baseColor = float3(0.9, 0.2, 0.2) * checker(input.uv);
        } else {
            if ((input.surfaceType < 2.5)) {
                baseColor = float3(0.9, 0.9, 0.2) * checker(input.uv);
            } else {
                baseColor = float3(0.7, 0.5, 0.3) * checker(input.uv);
            }
        }
    }
    float3 n = normalize(input.normal);
    float3 lightDir = normalize(float3(0.35, 1.0, 0.45));
    float diff = max(dot(n, lightDir), 0.15);
    float4 _e40 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e40.xyz)) * 0.08));
    color = baseColor * diff;
    float4 _e55 = fogColor;
    float3 _e57 = color;
    color = lerp(_e55.xyz, _e57, fogFactor);
    float3 _e59 = color;
    return float4(_e59, 1.0);
}
