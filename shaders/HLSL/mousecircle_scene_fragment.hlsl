// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
};

struct VertexOutput {
    float4 position : SV_Position;
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
}
Texture2D<float4> floorTexture : register(t0, space3);
SamplerState nagaSamplerHeap[2048]: register(s0, space0);
SamplerComparisonState nagaComparisonSamplerHeap[2048]: register(s0, space1);
StructuredBuffer<uint> nagaGroup1SamplerIndexArray : register(t1, space255);
static const SamplerState floorSampler = nagaSamplerHeap[nagaGroup1SamplerIndexArray[1]];
Texture2D<float4> wallTexture : register(t2, space3);
static const SamplerState wallSampler = nagaSamplerHeap[nagaGroup1SamplerIndexArray[3]];

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_1 : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 position : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv)
{
    float2 scaled = floor((uv * 4.0));
    float v = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v < 0.5) ? 1.0 : 0.7);
}

float4 main(FragmentInput_main fragmentinput_main) : SV_Target0
{
    VertexOutput input = { fragmentinput_main.position, fragmentinput_main.surfaceType, fragmentinput_main.uv_1, fragmentinput_main.normal, fragmentinput_main.worldPos };
    float3 baseColor = (float3)0;
    float3 color = (float3)0;

    float4 floorColor = floorTexture.Sample(floorSampler, input.uv);
    float4 wallColor = wallTexture.Sample(wallSampler, input.uv);
    if ((input.surfaceType < 0.5)) {
        baseColor = floorColor.xyz;
    } else {
        if ((input.surfaceType < 1.5)) {
            baseColor = wallColor.xyz;
        } else {
            if ((input.surfaceType < 2.5)) {
                const float _e26 = checker(input.uv);
                baseColor = (float3(0.9, 0.9, 0.2) * _e26);
            } else {
                const float _e33 = checker(input.uv);
                baseColor = (float3(0.7, 0.5, 0.3) * _e33);
            }
        }
    }
    float3 n = normalize(input.normal);
    float3 lightDir = normalize(float3(0.35, 1.0, 0.45));
    float diff = max(dot(n, lightDir), 0.15);
    float4 _e48 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e48.xyz)) * 0.08));
    float3 _e55 = baseColor;
    color = (_e55 * diff);
    float4 _e60 = fogColor;
    float3 _e62 = color;
    color = lerp(_e60.xyz, _e62, fogFactor);
    float3 _e64 = color;
    return float4(_e64, 1.0);
}
