// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
    float4 staticLights[16];
    float4 staticLightColors[16];
    float4 staticLightParams;
    float4 flashlightPos;
    float4 flashlightDir;
    float4 flashlightParams;
    float4 screenParams;
};

struct FragmentInput {
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

struct FlashlightContribution {
    float diffuse;
    float specular;
};

struct StaticLightContribution {
    float3 diffuse;
    int _pad1_0;
    float3 specular;
    int _end_pad_0;
};

struct MaterialProperties {
    float shininess;
    float specularStrength;
};

static const uint MAX_STATIC_LIGHTS = 16u;

Texture2D<float4> floorTexture : register(t0, space2);
Texture2D<float4> wallTexture : register(t1, space2);
Texture2D<float4> ceilingTexture : register(t2, space2);
Texture2D<float4> sphereTexture : register(t3, space2);
Texture2D<float4> bookTexture : register(t4, space2);
Texture2D<float4> chairTexture : register(t5, space2);
SamplerState sharedSampler : register(s0, space2);
cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
    float4 staticLights[16];
    float4 staticLightColors[16];
    float4 staticLightParams;
    float4 flashlightPos;
    float4 flashlightDir;
    float4 flashlightParams;
    float4 screenParams;
}

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_4 : TEXCOORD1;
    float3 normal_2 : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 frag_coord_2 : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv_1)
{
    float2 scaled = floor((uv_1 * 4.0));
    float v_1 = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v_1 < 0.5) ? 1.0 : 0.7);
}

float get_debug_height(float2 uv_2)
{
    if (((uv_2.x <= 0.2) && (uv_2.y <= 0.2))) {
        return 1.0;
    }
    return 0.0;
}

float2 parallax_occlusion(float2 uv_3, float3 v, float3 n, float height_scale, int steps)
{
    float current_depth = 0.0;
    float2 current_uv = (float2)0;
    float prev_depth_map = 0.0;
    float2 prev_uv = (float2)0;
    int i = int(0);

    float layer_depth = (1.0 / float(steps));
    float2 offset = ((v.xy / (v.z).xx) * height_scale);
    current_uv = uv_3;
    prev_uv = uv_3;
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            int _e49 = i;
            i = asint(asuint(_e49) + asuint(int(1)));
        }
        loop_init = false;
        int _e21 = i;
        if ((_e21 < steps)) {
        } else {
            break;
        }
        {
            float2 _e24 = current_uv;
            current_uv = (_e24 - (offset * layer_depth));
            float2 _e26 = current_uv;
            const float _e27 = get_debug_height(_e26);
            float _e28 = current_depth;
            if ((_e28 >= _e27)) {
                float _e30 = prev_depth_map;
                float _e31 = current_depth;
                float _e34 = current_depth;
                float2 delta = float2(((_e30 - _e31) + layer_depth), (_e27 - _e34));
                float2 _e37 = prev_uv;
                return (_e37 - (offset * ((delta.x / (delta.x - delta.y)) * layer_depth)));
            }
            float2 _e46 = current_uv;
            prev_uv = _e46;
            prev_depth_map = _e27;
            float _e47 = current_depth;
            current_depth = (_e47 + layer_depth);
        }
    }
    return uv_3;
}

MaterialProperties ConstructMaterialProperties(float arg0, float arg1) {
    MaterialProperties ret = (MaterialProperties)0;
    ret.shininess = arg0;
    ret.specularStrength = arg1;
    return ret;
}

MaterialProperties get_material_properties(float surface_type)
{
    if ((surface_type < 0.5)) {
        const MaterialProperties materialproperties = ConstructMaterialProperties(12.0, 0.15);
        return materialproperties;
    } else {
        if ((surface_type < 1.5)) {
            const MaterialProperties materialproperties_1 = ConstructMaterialProperties(18.0, 0.2);
            return materialproperties_1;
        } else {
            if ((surface_type < 2.5)) {
                const MaterialProperties materialproperties_2 = ConstructMaterialProperties(14.0, 0.18);
                return materialproperties_2;
            } else {
                if ((surface_type < 3.5)) {
                    const MaterialProperties materialproperties_3 = ConstructMaterialProperties(28.0, 0.35);
                    return materialproperties_3;
                } else {
                    if ((surface_type < 4.5)) {
                        const MaterialProperties materialproperties_4 = ConstructMaterialProperties(48.0, 0.8);
                        return materialproperties_4;
                    } else {
                        if ((surface_type < 5.5)) {
                            const MaterialProperties materialproperties_5 = ConstructMaterialProperties(36.0, 0.4);
                            return materialproperties_5;
                        }
                    }
                }
            }
        }
    }
    const MaterialProperties materialproperties_6 = ConstructMaterialProperties(30.0, 0.5);
    return materialproperties_6;
}

StaticLightContribution ConstructStaticLightContribution(float3 arg0, float3 arg1) {
    StaticLightContribution ret = (StaticLightContribution)0;
    ret.diffuse = arg0;
    ret.specular = arg1;
    return ret;
}

int naga_f2i32(float value) {
    return int(clamp(value, -2147483600.0, 2147483500.0));
}

StaticLightContribution compute_static_lighting(float3 normal, float3 world_pos, float3 view_dir_1, MaterialProperties material)
{
    float3 total_diffuse = (0.0).xxx;
    float3 total_specular = (0.0).xxx;
    int i_1 = int(0);
    float range_falloff = (float)0;

    float _e7 = staticLightParams.x;
    int light_count = clamp(naga_f2i32(_e7), int(0), int(16));
    float range = staticLightParams.y;
    if (((range <= 0.0) || (light_count == int(0)))) {
        const StaticLightContribution staticlightcontribution = ConstructStaticLightContribution((0.0).xxx, (0.0).xxx);
        return staticlightcontribution;
    }
    float shininess = max(material.shininess, 1.0);
    bool loop_init_1 = true;
    while(true) {
        if (!loop_init_1) {
            int _e105 = i_1;
            i_1 = asint(asuint(_e105) + asuint(int(1)));
        }
        loop_init_1 = false;
        int _e37 = i_1;
        if ((_e37 < light_count)) {
        } else {
            break;
        }
        {
            int _e41 = i_1;
            float4 light_data = staticLights[min(uint(uint(_e41)), 15u)];
            float3 to_light = (light_data.xyz - world_pos);
            float dist = length(to_light);
            if ((dist <= 0.0001)) {
                continue;
            }
            float3 dir = (to_light / (dist).xxx);
            float ndotl = max(dot(normal, dir), 0.0);
            if ((ndotl <= 0.0)) {
                continue;
            }
            range_falloff = 1.0;
            if ((range > 0.0)) {
                if ((dist > range)) {
                    continue;
                }
                range_falloff = clamp((1.0 - (dist / range)), 0.0, 1.0);
            }
            float inv = (1.0 / ((1.0 + (0.09 * dist)) + ((0.032 * dist) * dist)));
            float _e78 = range_falloff;
            float attenuation = (inv * _e78);
            float3 H = normalize((dir + view_dir_1));
            float spec = pow(max(dot(normal, H), 0.0), shininess);
            int _e88 = i_1;
            float4 _e91 = staticLightColors[min(uint(uint(_e88)), 15u)];
            float3 light_color = _e91.xyz;
            float3 _e95 = total_diffuse;
            total_diffuse = (_e95 + ((ndotl * attenuation) * light_color));
            float3 _e103 = total_specular;
            total_specular = (_e103 + ((((material.specularStrength * spec) * attenuation) * light_color) * 0.5));
        }
    }
    float3 _e108 = total_diffuse;
    float3 _e109 = total_specular;
    const StaticLightContribution staticlightcontribution_1 = ConstructStaticLightContribution(_e108, _e109);
    return staticlightcontribution_1;
}

FlashlightContribution ConstructFlashlightContribution(float arg0, float arg1) {
    FlashlightContribution ret = (FlashlightContribution)0;
    ret.diffuse = arg0;
    ret.specular = arg1;
    return ret;
}

FlashlightContribution compute_flashlight(float3 normal_1, float3 world_pos_1, float4 frag_coord_1, float3 view_dir_2, MaterialProperties material_1)
{
    float beam = (float)0;

    float _e8 = flashlightParams.x;
    if ((_e8 < 0.5)) {
        const FlashlightContribution flashlightcontribution = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution;
    }
    float width = screenParams.x;
    float height = screenParams.y;
    float min_dim = screenParams.z;
    if ((((width <= 0.0) || (height <= 0.0)) || (min_dim <= 0.0))) {
        const FlashlightContribution flashlightcontribution_1 = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution_1;
    }
    float2 pixel = frag_coord_1.xy;
    float2 center_ = float2((width * 0.5), (height * 0.5));
    float2 delta_1 = ((pixel - center_) / (min_dim).xx);
    float radius = flashlightParams.w;
    if ((radius <= 0.0)) {
        const FlashlightContribution flashlightcontribution_2 = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution_2;
    }
    float dist_1 = length(delta_1);
    if ((dist_1 > radius)) {
        const FlashlightContribution flashlightcontribution_3 = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution_3;
    }
    float falloff = clamp((dist_1 / radius), 0.0, 1.0);
    float _e70 = flashlightParams.y;
    float base_intensity = (((1.0 - (falloff * falloff)) * _e70) * 0.35);
    float _e77 = flashlightDir.w;
    if ((_e77 <= 0.0)) {
        const FlashlightContribution flashlightcontribution_4 = ConstructFlashlightContribution(base_intensity, 0.0);
        return flashlightcontribution_4;
    }
    float4 _e84 = flashlightPos;
    float3 to_fragment = (world_pos_1 - _e84.xyz);
    float4 _e89 = flashlightDir;
    float dist_along_axis = dot(to_fragment, _e89.xyz);
    float _e97 = flashlightPos.w;
    if (((dist_along_axis <= 0.0) || (dist_along_axis > _e97))) {
        const FlashlightContribution flashlightcontribution_5 = ConstructFlashlightContribution(base_intensity, 0.0);
        return flashlightcontribution_5;
    }
    float3 dir_norm = normalize(to_fragment);
    float4 _e105 = flashlightDir;
    float spot = dot(dir_norm, _e105.xyz);
    float cutoff = flashlightDir.w;
    if ((spot <= cutoff)) {
        const FlashlightContribution flashlightcontribution_6 = ConstructFlashlightContribution(base_intensity, 0.0);
        return flashlightcontribution_6;
    }
    float focus = pow(((spot - cutoff) / max((1.0 - cutoff), 0.001)), 2.0);
    float4 _e125 = flashlightDir;
    float ndotl_1 = max(dot(normal_1, _e125.xyz), 0.0);
    float _e133 = flashlightPos.w;
    float distance_atten = clamp((1.0 - (dist_along_axis / _e133)), 0.0, 1.0);
    float4 _e142 = flashlightDir;
    float3 half_dir = normalize((_e142.xyz + view_dir_2));
    float spec_1 = pow(max(dot(normal_1, half_dir), 0.0), max(material_1.shininess, 1.0));
    float _e158 = flashlightParams.y;
    beam = (base_intensity + ((((focus * ndotl_1) * distance_atten) * _e158) * 0.5));
    float _e164 = beam;
    float _e168 = flashlightParams.y;
    beam = min(_e164, (_e168 * 0.7));
    float _e179 = flashlightParams.y;
    float specular = (((((spec_1 * focus) * distance_atten) * 0.15) * _e179) * material_1.specularStrength);
    float _e183 = beam;
    const FlashlightContribution flashlightcontribution_7 = ConstructFlashlightContribution(_e183, specular);
    return flashlightcontribution_7;
}

float4 main_(FragmentInput_main fragmentinput_main) : SV_Target0
{
    FragmentInput input = { fragmentinput_main.surfaceType, fragmentinput_main.uv_4, fragmentinput_main.normal_2, fragmentinput_main.worldPos };
    float4 frag_coord = fragmentinput_main.frag_coord_2;
    float3 view_dir = (float3)0;
    float2 uv = (float2)0;
    float3 baseColor = (float3)0;
    float3 color = (float3)0;

    float3 n_1 = normalize(input.normal);
    float4 _e6 = cameraPos;
    view_dir = (_e6.xyz - input.worldPos);
    float3 _e11 = view_dir;
    float view_len = length(_e11);
    if ((view_len > 0.0001)) {
        float3 _e15 = view_dir;
        view_dir = (_e15 / (view_len).xxx);
    } else {
        view_dir = float3(0.0, 0.0, 1.0);
    }
    uv = input.uv;
    if (((input.surfaceType >= 0.5) && (input.surfaceType < 1.5))) {
        float4 _e33 = cameraPos;
        if ((distance(_e33.xyz, input.worldPos) < 5.0)) {
            float3 _e40 = view_dir;
            const float2 _e43 = parallax_occlusion(input.uv, _e40, n_1, 0.05, int(32));
            uv = _e43;
        }
    }
    float4 floorColor = floorTexture.Sample(sharedSampler, input.uv);
    float2 _e50 = uv;
    float4 wallColor = wallTexture.Sample(sharedSampler, _e50);
    float4 ceilingColor = ceilingTexture.Sample(sharedSampler, input.uv);
    float4 sphereColor = sphereTexture.Sample(sharedSampler, input.uv);
    float4 bookColor = bookTexture.Sample(sharedSampler, input.uv);
    float4 chairColor = chairTexture.Sample(sharedSampler, input.uv);
    if ((input.surfaceType < 0.5)) {
        baseColor = floorColor.xyz;
    } else {
        if ((input.surfaceType < 1.5)) {
            baseColor = wallColor.xyz;
        } else {
            if ((input.surfaceType < 2.5)) {
                baseColor = ceilingColor.xyz;
            } else {
                if ((input.surfaceType < 3.5)) {
                    const float _e89 = checker(input.uv);
                    baseColor = (float3(0.7, 0.5, 0.3) * _e89);
                } else {
                    if ((input.surfaceType < 4.5)) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if ((input.surfaceType < 5.5)) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    const MaterialProperties _e101 = get_material_properties(input.surfaceType);
    float3 _e103 = view_dir;
    const StaticLightContribution _e104 = compute_static_lighting(n_1, input.worldPos, _e103, _e101);
    float3 _e106 = view_dir;
    const FlashlightContribution _e107 = compute_flashlight(n_1, input.worldPos, frag_coord, _e106, _e101);
    float _e111 = screenParams.w;
    if ((_e111 > 0.5)) {
        float3 mapped = ((normalize(input.normal) * 0.5) + (0.5).xxx);
        return float4(mapped, 1.0);
    }
    float ambient = staticLightParams.z;
    float4 _e130 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e130.xyz)) * 0.08));
    float3 _e137 = baseColor;
    color = (_e137 * (ambient + _e107.diffuse));
    float3 _e142 = baseColor;
    float3 _e145 = color;
    color = (_e145 + (_e142 * _e104.diffuse));
    float3 _e148 = color;
    color = (_e148 + _e104.specular);
    float3 _e156 = color;
    color = (_e156 + (_e107.specular * float3(1.0, 0.95, 0.85)));
    float4 _e160 = fogColor;
    float3 _e162 = color;
    color = lerp(_e160.xyz, _e162, fogFactor);
    float3 _e164 = color;
    return float4(_e164, 1.0);
}