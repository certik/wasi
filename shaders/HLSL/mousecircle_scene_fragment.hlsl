// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
};

struct VertexOutput {
    float4 position : SV_Position;
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

Texture2D<float4> floorTexture : register(t0, space2);
Texture2D<float4> wallTexture : register(t1, space2);
Texture2D<float4> ceilingTexture : register(t2, space2);
Texture2D<float4> sphereTexture : register(t3, space2);
Texture2D<float4> bookTexture : register(t4, space2);
Texture2D<float4> chairTexture : register(t5, space2);
SamplerState sharedSampler : register(s0, space2);
cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
}

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_1 : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 position : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv)
{
    float2 scaled = floor((uv * 4.0));
    float v = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v < 0.5) ? 1.0 : 0.7);
}

float4 main_(FragmentInput_main fragmentinput_main) : SV_Target0
{
    VertexOutput input = { fragmentinput_main.position, fragmentinput_main.surfaceType, fragmentinput_main.uv_1, fragmentinput_main.normal, fragmentinput_main.worldPos };
    float3 baseColor = (float3)0;
    float diff = (float)0;
    float3 color = (float3)0;

    float4 floorColor = floorTexture.Sample(sharedSampler, input.uv);
    float4 wallColor = wallTexture.Sample(sharedSampler, input.uv);
    float4 ceilingColor = ceilingTexture.Sample(sharedSampler, input.uv);
    float4 sphereColor = sphereTexture.Sample(sharedSampler, input.uv);
    float4 bookColor = bookTexture.Sample(sharedSampler, input.uv);
    float4 chairColor = chairTexture.Sample(sharedSampler, input.uv);
    if ((input.surfaceType < 0.5)) {
        baseColor = floorColor.xyz;
    } else {
        if ((input.surfaceType < 1.5)) {
            baseColor = wallColor.xyz;
        } else {
            if ((input.surfaceType < 2.5)) {
                baseColor = ceilingColor.xyz;
            } else {
                if ((input.surfaceType < 3.5)) {
                    const float _e46 = checker(input.uv);
                    baseColor = (float3(0.7, 0.5, 0.3) * _e46);
                } else {
                    if ((input.surfaceType < 4.5)) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if ((input.surfaceType < 5.5)) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    float3 n = normalize(input.normal);
    float3 lightDir = normalize(float3(0.35, 1.0, 0.45));
    diff = max(dot(n, lightDir), 0.15);
    if (((input.surfaceType >= 1.5) && (input.surfaceType < 2.5))) {
        diff = 1.0;
    }
    float4 _e79 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e79.xyz)) * 0.08));
    float3 _e86 = baseColor;
    float _e87 = diff;
    color = (_e86 * _e87);
    float4 _e92 = fogColor;
    float3 _e94 = color;
    color = lerp(_e92.xyz, _e94, fogFactor);
    float3 _e96 = color;
    return float4(_e96, 1.0);
}