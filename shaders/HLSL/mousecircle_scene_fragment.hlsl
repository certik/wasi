// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 cameraDir;
    float4 fogColor;
    float4 staticLights[16];
    float4 staticLightColors[16];
    float4 staticLightParams;
    float4 flashlightPos;
    float4 flashlightDir;
    float4 flashlightParams;
    float4 screenParams;
};

struct FragmentInput {
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

struct FlashlightContribution {
    float diffuse;
    float specular;
};

struct StaticLightContribution {
    float3 diffuse;
    int _pad1_0;
    float3 specular;
    int _end_pad_0;
};

struct MaterialProperties {
    float shininess;
    float specularStrength;
};

static const uint MAX_STATIC_LIGHTS = 16u;

Texture2D<float4> floorTexture : register(t0, space2);
Texture2D<float4> wallTexture : register(t1, space2);
Texture2D<float4> ceilingTexture : register(t2, space2);
Texture2D<float4> sphereTexture : register(t3, space2);
Texture2D<float4> bookTexture : register(t4, space2);
Texture2D<float4> chairTexture : register(t5, space2);
SamplerState sharedSampler : register(s0, space2);
cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 cameraDir;
    float4 fogColor;
    float4 staticLights[16];
    float4 staticLightColors[16];
    float4 staticLightParams;
    float4 flashlightPos;
    float4 flashlightDir;
    float4 flashlightParams;
    float4 screenParams;
}

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_4 : TEXCOORD1;
    float3 normal_2 : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 frag_coord_2 : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv_1)
{
    float2 scaled = floor((uv_1 * 4.0));
    float v = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v < 0.5) ? 1.0 : 0.7);
}

float get_debug_height(float2 uv_2)
{
    if (((((uv_2.x >= 0.4) && (uv_2.x <= 0.6)) && (uv_2.y >= 0.4)) && (uv_2.y <= 0.6))) {
        float2 center_ = float2(0.5, 0.5);
        float dist = length((uv_2 - center_));
        return clamp((1.0 - (dist / 0.141)), 0.0, 1.0);
    }
    return 0.0;
}

float2 parallax_occlusion(float2 uv_3, float3 view_tangent, float height_scale, int steps)
{
    float current_depth = 0.0;
    float2 current_uv = (float2)0;
    float2 prev_uv = (float2)0;
    float prev_depth_map = (float)0;
    int i = int(0);

    float layer_depth = (1.0 / float(steps));
    float2 parallax_dir = ((-(view_tangent.xy) / (max(abs(view_tangent.z), 0.01)).xx) * height_scale);
    current_uv = uv_3;
    prev_uv = uv_3;
    const float _e20 = get_debug_height(uv_3);
    prev_depth_map = _e20;
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            int _e47 = i;
            i = asint(asuint(_e47) + asuint(int(1)));
        }
        loop_init = false;
        int _e24 = i;
        if ((_e24 < steps)) {
        } else {
            break;
        }
        {
            float _e26 = current_depth;
            current_depth = (_e26 + layer_depth);
            float2 _e29 = current_uv;
            current_uv = (_e29 + (parallax_dir * layer_depth));
            float2 _e31 = current_uv;
            const float _e32 = get_debug_height(_e31);
            float _e33 = current_depth;
            if ((_e33 >= _e32)) {
                float _e35 = current_depth;
                float after_depth = (_e32 - _e35);
                float _e37 = prev_depth_map;
                float _e38 = current_depth;
                float before_depth = (_e37 - (_e38 - layer_depth));
                float weight = (after_depth / (after_depth - before_depth));
                float2 _e43 = current_uv;
                float2 _e44 = prev_uv;
                return lerp(_e43, _e44, weight);
            }
            float2 _e46 = current_uv;
            prev_uv = _e46;
            prev_depth_map = _e32;
        }
    }
    float2 _e50 = current_uv;
    return _e50;
}

MaterialProperties ConstructMaterialProperties(float arg0, float arg1) {
    MaterialProperties ret = (MaterialProperties)0;
    ret.shininess = arg0;
    ret.specularStrength = arg1;
    return ret;
}

MaterialProperties get_material_properties(float surface_type)
{
    if ((surface_type < 0.5)) {
        const MaterialProperties materialproperties = ConstructMaterialProperties(12.0, 0.15);
        return materialproperties;
    } else {
        if ((surface_type < 1.5)) {
            const MaterialProperties materialproperties_1 = ConstructMaterialProperties(18.0, 0.2);
            return materialproperties_1;
        } else {
            if ((surface_type < 2.5)) {
                const MaterialProperties materialproperties_2 = ConstructMaterialProperties(14.0, 0.18);
                return materialproperties_2;
            } else {
                if ((surface_type < 3.5)) {
                    const MaterialProperties materialproperties_3 = ConstructMaterialProperties(28.0, 0.35);
                    return materialproperties_3;
                } else {
                    if ((surface_type < 4.5)) {
                        const MaterialProperties materialproperties_4 = ConstructMaterialProperties(48.0, 0.8);
                        return materialproperties_4;
                    } else {
                        if ((surface_type < 5.5)) {
                            const MaterialProperties materialproperties_5 = ConstructMaterialProperties(36.0, 0.4);
                            return materialproperties_5;
                        }
                    }
                }
            }
        }
    }
    const MaterialProperties materialproperties_6 = ConstructMaterialProperties(30.0, 0.5);
    return materialproperties_6;
}

StaticLightContribution ConstructStaticLightContribution(float3 arg0, float3 arg1) {
    StaticLightContribution ret = (StaticLightContribution)0;
    ret.diffuse = arg0;
    ret.specular = arg1;
    return ret;
}

int naga_f2i32(float value) {
    return int(clamp(value, -2147483600.0, 2147483500.0));
}

StaticLightContribution compute_static_lighting(float3 normal, float3 world_pos, float3 view_dir_1, MaterialProperties material)
{
    float3 total_diffuse = (0.0).xxx;
    float3 total_specular = (0.0).xxx;
    int i_1 = int(0);
    float range_falloff = (float)0;

    float _e7 = staticLightParams.x;
    int light_count = clamp(naga_f2i32(_e7), int(0), int(16));
    float range = staticLightParams.y;
    if (((range <= 0.0) || (light_count == int(0)))) {
        const StaticLightContribution staticlightcontribution = ConstructStaticLightContribution((0.0).xxx, (0.0).xxx);
        return staticlightcontribution;
    }
    float shininess = max(material.shininess, 1.0);
    bool loop_init_1 = true;
    while(true) {
        if (!loop_init_1) {
            int _e105 = i_1;
            i_1 = asint(asuint(_e105) + asuint(int(1)));
        }
        loop_init_1 = false;
        int _e37 = i_1;
        if ((_e37 < light_count)) {
        } else {
            break;
        }
        {
            int _e41 = i_1;
            float4 light_data = staticLights[min(uint(uint(_e41)), 15u)];
            float3 to_light = (light_data.xyz - world_pos);
            float dist_1 = length(to_light);
            if ((dist_1 <= 0.0001)) {
                continue;
            }
            float3 dir = (to_light / (dist_1).xxx);
            float ndotl = max(dot(normal, dir), 0.0);
            if ((ndotl <= 0.0)) {
                continue;
            }
            range_falloff = 1.0;
            if ((range > 0.0)) {
                if ((dist_1 > range)) {
                    continue;
                }
                range_falloff = clamp((1.0 - (dist_1 / range)), 0.0, 1.0);
            }
            float inv = (1.0 / ((1.0 + (0.09 * dist_1)) + ((0.032 * dist_1) * dist_1)));
            float _e78 = range_falloff;
            float attenuation = (inv * _e78);
            float3 H = normalize((dir + view_dir_1));
            float spec = pow(max(dot(normal, H), 0.0), shininess);
            int _e88 = i_1;
            float4 _e91 = staticLightColors[min(uint(uint(_e88)), 15u)];
            float3 light_color = _e91.xyz;
            float3 _e95 = total_diffuse;
            total_diffuse = (_e95 + ((ndotl * attenuation) * light_color));
            float3 _e103 = total_specular;
            total_specular = (_e103 + ((((material.specularStrength * spec) * attenuation) * light_color) * 0.5));
        }
    }
    float3 _e108 = total_diffuse;
    float3 _e109 = total_specular;
    const StaticLightContribution staticlightcontribution_1 = ConstructStaticLightContribution(_e108, _e109);
    return staticlightcontribution_1;
}

FlashlightContribution ConstructFlashlightContribution(float arg0, float arg1) {
    FlashlightContribution ret = (FlashlightContribution)0;
    ret.diffuse = arg0;
    ret.specular = arg1;
    return ret;
}

FlashlightContribution compute_flashlight(float3 normal_1, float3 world_pos_1, float4 frag_coord_1, float3 view_dir_2, MaterialProperties material_1)
{
    float beam = (float)0;

    float _e8 = flashlightParams.x;
    if ((_e8 < 0.5)) {
        const FlashlightContribution flashlightcontribution = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution;
    }
    float width = screenParams.x;
    float height = screenParams.y;
    float min_dim = screenParams.z;
    if ((((width <= 0.0) || (height <= 0.0)) || (min_dim <= 0.0))) {
        const FlashlightContribution flashlightcontribution_1 = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution_1;
    }
    float2 pixel = frag_coord_1.xy;
    float2 center_1 = float2((width * 0.5), (height * 0.5));
    float2 delta = ((pixel - center_1) / (min_dim).xx);
    float radius = flashlightParams.w;
    if ((radius <= 0.0)) {
        const FlashlightContribution flashlightcontribution_2 = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution_2;
    }
    float dist_2 = length(delta);
    if ((dist_2 > radius)) {
        const FlashlightContribution flashlightcontribution_3 = ConstructFlashlightContribution(0.0, 0.0);
        return flashlightcontribution_3;
    }
    float falloff = clamp((dist_2 / radius), 0.0, 1.0);
    float _e70 = flashlightParams.y;
    float base_intensity = (((1.0 - (falloff * falloff)) * _e70) * 0.35);
    float _e77 = flashlightDir.w;
    if ((_e77 <= 0.0)) {
        const FlashlightContribution flashlightcontribution_4 = ConstructFlashlightContribution(base_intensity, 0.0);
        return flashlightcontribution_4;
    }
    float4 _e84 = flashlightPos;
    float3 to_fragment = (world_pos_1 - _e84.xyz);
    float4 _e89 = flashlightDir;
    float dist_along_axis = dot(to_fragment, _e89.xyz);
    float _e97 = flashlightPos.w;
    if (((dist_along_axis <= 0.0) || (dist_along_axis > _e97))) {
        const FlashlightContribution flashlightcontribution_5 = ConstructFlashlightContribution(base_intensity, 0.0);
        return flashlightcontribution_5;
    }
    float3 dir_norm = normalize(to_fragment);
    float4 _e105 = flashlightDir;
    float spot = dot(dir_norm, _e105.xyz);
    float cutoff = flashlightDir.w;
    if ((spot <= cutoff)) {
        const FlashlightContribution flashlightcontribution_6 = ConstructFlashlightContribution(base_intensity, 0.0);
        return flashlightcontribution_6;
    }
    float focus = pow(((spot - cutoff) / max((1.0 - cutoff), 0.001)), 2.0);
    float4 _e125 = flashlightDir;
    float ndotl_1 = max(dot(normal_1, _e125.xyz), 0.0);
    float _e133 = flashlightPos.w;
    float distance_atten = clamp((1.0 - (dist_along_axis / _e133)), 0.0, 1.0);
    float4 _e142 = flashlightDir;
    float3 half_dir = normalize((_e142.xyz + view_dir_2));
    float spec_1 = pow(max(dot(normal_1, half_dir), 0.0), max(material_1.shininess, 1.0));
    float _e158 = flashlightParams.y;
    beam = (base_intensity + ((((focus * ndotl_1) * distance_atten) * _e158) * 0.5));
    float _e164 = beam;
    float _e168 = flashlightParams.y;
    beam = min(_e164, (_e168 * 0.7));
    float _e179 = flashlightParams.y;
    float specular = (((((spec_1 * focus) * distance_atten) * 0.15) * _e179) * material_1.specularStrength);
    float _e183 = beam;
    const FlashlightContribution flashlightcontribution_7 = ConstructFlashlightContribution(_e183, specular);
    return flashlightcontribution_7;
}

float4 main_(FragmentInput_main fragmentinput_main) : SV_Target0
{
    FragmentInput input = { fragmentinput_main.surfaceType, fragmentinput_main.uv_4, fragmentinput_main.normal_2, fragmentinput_main.worldPos };
    float4 frag_coord = fragmentinput_main.frag_coord_2;
    float3 n = (float3)0;
    float3 view_dir = (float3)0;
    float3 tangent = (float3)0;
    float2 uv = (float2)0;
    float3 baseColor = (float3)0;
    float3 color = (float3)0;

    n = normalize(input.normal);
    float4 _e7 = cameraPos;
    view_dir = (_e7.xyz - input.worldPos);
    float3 _e12 = view_dir;
    float view_len = length(_e12);
    if ((view_len > 0.0001)) {
        float3 _e16 = view_dir;
        view_dir = (_e16 / (view_len).xxx);
    } else {
        view_dir = float3(0.0, 0.0, 1.0);
    }
    float3 _e23 = n;
    float3 _e24 = view_dir;
    if ((dot(_e23, _e24) < 0.0)) {
        float3 _e28 = n;
        n = -(_e28);
    }
    float4 _e32 = cameraDir;
    float3 cam_dir = _e32.xyz;
    float3 bitangent = float3(0.0, 1.0, 0.0);
    float3 _e38 = n;
    tangent = normalize(cross(bitangent, _e38));
    float _e43 = n.z;
    float _e46 = n.x;
    if ((abs(_e43) > abs(_e46))) {
        float _e50 = n.z;
        if ((_e50 < 0.0)) {
            float3 _e53 = tangent;
            tangent = -(_e53);
        }
    } else {
        float _e56 = n.x;
        if ((_e56 > 0.0)) {
            float3 _e59 = tangent;
            tangent = -(_e59);
        }
    }
    float3 _e61 = tangent;
    float3 _e64 = n;
    float3 cam_tangent = float3(dot(cam_dir, _e61), dot(cam_dir, bitangent), dot(cam_dir, _e64));
    uv = input.uv;
    if (((input.surfaceType >= 0.5) && (input.surfaceType < 1.5))) {
        const float2 _e79 = parallax_occlusion(input.uv, cam_tangent, 0.15, int(32));
        uv = _e79;
    }
    float4 floorColor = floorTexture.Sample(sharedSampler, input.uv);
    float2 _e86 = uv;
    float4 wallColor = wallTexture.Sample(sharedSampler, _e86);
    float4 ceilingColor = ceilingTexture.Sample(sharedSampler, input.uv);
    float4 sphereColor = sphereTexture.Sample(sharedSampler, input.uv);
    float4 bookColor = bookTexture.Sample(sharedSampler, input.uv);
    float4 chairColor = chairTexture.Sample(sharedSampler, input.uv);
    if ((input.surfaceType < 0.5)) {
        baseColor = floorColor.xyz;
    } else {
        if ((input.surfaceType < 1.5)) {
            baseColor = wallColor.xyz;
            float _e116 = staticLightParams.w;
            if ((_e116 > 0.5)) {
                if (((((input.uv.x >= 0.4) && (input.uv.x <= 0.6)) && (input.uv.y >= 0.4)) && (input.uv.y <= 0.6))) {
                    float _e139 = n.x;
                    float _e145 = n.y;
                    float _e151 = n.z;
                    baseColor = float3(((_e139 * 0.5) + 0.5), ((_e145 * 0.5) + 0.5), ((_e151 * 0.5) + 0.5));
                    float _e159 = uv.x;
                    float grid_x = frac((_e159 / 0.05));
                    float _e163 = uv.y;
                    float grid_y = frac((_e163 / 0.05));
                    if (((grid_x < 0.1) || (grid_y < 0.1))) {
                        baseColor = float3(1.0, 1.0, 0.0);
                    }
                    if (((((input.uv.x < (0.4 + 0.01)) || (input.uv.x > (0.6 - 0.01))) || (input.uv.y < (0.4 + 0.01))) || (input.uv.y > (0.6 - 0.01)))) {
                        baseColor = float3(1.0, 0.0, 0.0);
                    }
                }
            }
        } else {
            if ((input.surfaceType < 2.5)) {
                baseColor = ceilingColor.xyz;
            } else {
                if ((input.surfaceType < 3.5)) {
                    const float _e215 = checker(input.uv);
                    baseColor = (float3(0.7, 0.5, 0.3) * _e215);
                } else {
                    if ((input.surfaceType < 4.5)) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if ((input.surfaceType < 5.5)) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    const MaterialProperties _e227 = get_material_properties(input.surfaceType);
    float3 _e228 = n;
    float3 _e230 = view_dir;
    const StaticLightContribution _e231 = compute_static_lighting(_e228, input.worldPos, _e230, _e227);
    float3 _e232 = n;
    float3 _e234 = view_dir;
    const FlashlightContribution _e235 = compute_flashlight(_e232, input.worldPos, frag_coord, _e234, _e227);
    float _e239 = screenParams.w;
    if ((_e239 > 0.5)) {
        float3 mapped = ((normalize(input.normal) * 0.5) + (0.5).xxx);
        return float4(mapped, 1.0);
    }
    float ambient = staticLightParams.z;
    float4 _e258 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e258.xyz)) * 0.08));
    float3 _e265 = baseColor;
    color = (_e265 * (ambient + _e235.diffuse));
    float3 _e270 = baseColor;
    float3 _e273 = color;
    color = (_e273 + (_e270 * _e231.diffuse));
    float3 _e276 = color;
    color = (_e276 + _e231.specular);
    float3 _e284 = color;
    color = (_e284 + (_e235.specular * float3(1.0, 0.95, 0.85)));
    float4 _e288 = fogColor;
    float3 _e290 = color;
    color = lerp(_e288.xyz, _e290, fogFactor);
    float3 _e292 = color;
    return float4(_e292, 1.0);
}