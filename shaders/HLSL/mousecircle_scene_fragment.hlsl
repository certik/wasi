// AUTO-GENERATED from WGSL/mousecircle_scene_fragment.wgsl
// Generated by: shader_compiler (Naga 0.1.0)
// DO NOT EDIT - Modify the source WGSL file instead

struct Material {
    float metalness;
    float roughness;
    float ior;
    float emissiveIntensity;
};

struct SceneUniforms {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
    float4 staticLights[16];
    float4 staticLightColors[16];
    float4 staticLightParams;
    float4 flashlightPos;
    float4 flashlightDir;
    float4 flashlightParams;
    float4 screenParams;
    Material materials[7];
};

struct FragmentInput {
    float surfaceType : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 normal : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
};

struct FlashlightResult {
    float screenIntensity;
    int _pad1_0;
    int _pad1_1;
    int _pad1_2;
    float3 shading;
    int _end_pad_0;
};

static const uint MAX_STATIC_LIGHTS = 16u;
static const uint MATERIAL_COUNT = 7u;
static const float PI = 3.1415927;

Texture2D<float4> floorTexture : register(t0, space2);
Texture2D<float4> wallTexture : register(t1, space2);
Texture2D<float4> ceilingTexture : register(t2, space2);
Texture2D<float4> sphereTexture : register(t3, space2);
Texture2D<float4> bookTexture : register(t4, space2);
Texture2D<float4> chairTexture : register(t5, space2);
Texture2D<float4> debugAlbedoTexture : register(t6, space2);
Texture2D<float4> normalTexture : register(t7, space2);
Texture2D<float4> metallicRoughnessTexture : register(t8, space2);
Texture2D<float4> emissiveTexture : register(t9, space2);
Texture2D<float4> heightTexture : register(t10, space2);
SamplerState sharedSampler : register(s0, space2);
cbuffer SceneUniforms : register(b0, space3) {
    row_major float4x4 mvp;
    float4 cameraPos;
    float4 fogColor;
    float4 staticLights[16];
    float4 staticLightColors[16];
    float4 staticLightParams;
    float4 flashlightPos;
    float4 flashlightDir;
    float4 flashlightParams;
    float4 screenParams;
    Material materials[7];
}

struct FragmentInput_main {
    float surfaceType : TEXCOORD0;
    float2 uv_3 : TEXCOORD1;
    float3 normal_3 : TEXCOORD2;
    float3 worldPos : TEXCOORD3;
    float4 frag_coord_2 : SV_Position;
};

float naga_mod(float lhs, float rhs) {
    return lhs - rhs * trunc(lhs / rhs);
}

float checker(float2 uv_1)
{
    float2 scaled = floor((uv_1 * 4.0));
    float v_2 = naga_mod((scaled.x + scaled.y), 2.0);
    return ((v_2 < 0.5) ? 1.0 : 0.7);
}

float3 fresnel_schlick(float cos_theta, float3 f0_)
{
    float clamped = clamp((1.0 - cos_theta), 0.0, 1.0);
    return (f0_ + (((1.0).xxx - f0_) * pow(clamped, 5.0)));
}

float distribution_ggx(float3 n_1, float3 h, float roughness_1)
{
    float a = (roughness_1 * roughness_1);
    float a2_ = (a * a);
    float n_dot_h = max(dot(n_1, h), 0.0);
    float n_dot_h2_ = (n_dot_h * n_dot_h);
    float denom = ((n_dot_h2_ * (a2_ - 1.0)) + 1.0);
    return (a2_ / ((PI * denom) * denom));
}

float geometry_schlick_ggx(float n_dot_v, float roughness_2)
{
    float r = (roughness_2 + 1.0);
    float k = ((r * r) / 8.0);
    return (n_dot_v / ((n_dot_v * (1.0 - k)) + k));
}

float geometry_smith(float3 n_2, float3 v, float3 l, float roughness_3)
{
    float n_dot_v_1 = max(dot(n_2, v), 0.0);
    float n_dot_l = max(dot(n_2, l), 0.0);
    const float _e10 = geometry_schlick_ggx(n_dot_v_1, roughness_3);
    const float _e11 = geometry_schlick_ggx(n_dot_l, roughness_3);
    return (_e10 * _e11);
}

float3 cook_torrance_brdf(float3 n_3, float3 v_1, float3 l_1, float3 albedo, float metallic_1, float roughness_4, float3 f0_1, float3 light_color, float light_intensity)
{
    float3 h_1 = normalize((v_1 + l_1));
    float n_dot_v_2 = max(dot(n_3, v_1), 0.0001);
    float n_dot_l_1 = max(dot(n_3, l_1), 0.0001);
    float h_dot_v = max(dot(h_1, v_1), 0.0);
    const float3 _e20 = fresnel_schlick(h_dot_v, f0_1);
    const float _e21 = distribution_ggx(n_3, h_1, roughness_4);
    const float _e22 = geometry_smith(n_3, v_1, l_1, roughness_4);
    float3 specular = (((_e21 * _e22) * _e20) / (((4.0 * n_dot_v_2) * n_dot_l_1)).xxx);
    float3 kd = (((1.0).xxx - _e20) * (1.0 - metallic_1));
    float3 diffuse = (albedo / (3.1415927).xxx);
    return (((((kd * diffuse) + specular) * light_color) * light_intensity) * n_dot_l_1);
}

int naga_f2i32(float value) {
    return int(clamp(value, -2147483600.0, 2147483500.0));
}

float3 compute_static_lighting(float3 normal, float3 world_pos, float3 view_dir_1, float3 albedo_1, float metallic_2, float roughness_5, float3 f0_2)
{
    float3 total = (0.0).xxx;
    int i = int(0);
    float range_falloff = (float)0;

    float _e10 = staticLightParams.x;
    int light_count = clamp(naga_f2i32(_e10), int(0), int(16));
    float range = staticLightParams.y;
    if (((range <= 0.0) || (light_count == int(0)))) {
        return (0.0).xxx;
    }
    bool loop_init = true;
    while(true) {
        if (!loop_init) {
            int _e84 = i;
            i = asint(asuint(_e84) + asuint(int(1)));
        }
        loop_init = false;
        int _e31 = i;
        if ((_e31 < light_count)) {
        } else {
            break;
        }
        {
            int _e35 = i;
            float4 light_data = staticLights[min(uint(uint(_e35)), 15u)];
            float3 to_light = (light_data.xyz - world_pos);
            float dist = length(to_light);
            if ((dist <= 0.0001)) {
                continue;
            }
            float3 dir = (to_light / (dist).xxx);
            float ndotl = max(dot(normal, dir), 0.0);
            if ((ndotl <= 0.0)) {
                continue;
            }
            range_falloff = 1.0;
            if ((range > 0.0)) {
                if ((dist > range)) {
                    continue;
                }
                range_falloff = clamp((1.0 - (dist / range)), 0.0, 1.0);
            }
            float inv = (1.0 / ((1.0 + (0.09 * dist)) + ((0.032 * dist) * dist)));
            float _e72 = range_falloff;
            float attenuation = (inv * _e72);
            int _e76 = i;
            float4 _e79 = staticLightColors[min(uint(uint(_e76)), 15u)];
            float3 light_color_1 = _e79.xyz;
            const float3 _e81 = cook_torrance_brdf(normal, view_dir_1, dir, albedo_1, metallic_2, roughness_5, f0_2, light_color_1, attenuation);
            float3 _e82 = total;
            total = (_e82 + _e81);
        }
    }
    float3 _e87 = total;
    return _e87;
}

FlashlightResult ConstructFlashlightResult(float arg0, float3 arg1) {
    FlashlightResult ret = (FlashlightResult)0;
    ret.screenIntensity = arg0;
    ret.shading = arg1;
    return ret;
}

FlashlightResult compute_flashlight(float3 normal_1, float3 world_pos_1, float4 frag_coord_1, float3 view_dir_2, float3 albedo_2, float metallic_3, float roughness_6, float3 f0_3)
{
    FlashlightResult result = ConstructFlashlightResult(0.0, (0.0).xxx);
    float beam = (float)0;

    float _e16 = flashlightParams.x;
    if ((_e16 < 0.5)) {
        FlashlightResult _e19 = result;
        const FlashlightResult flashlightresult = _e19;
        return flashlightresult;
    }
    float width = screenParams.x;
    float height = screenParams.y;
    float min_dim = screenParams.z;
    if ((((width <= 0.0) || (height <= 0.0)) || (min_dim <= 0.0))) {
        FlashlightResult _e40 = result;
        const FlashlightResult flashlightresult_1 = _e40;
        return flashlightresult_1;
    }
    float2 pixel = frag_coord_1.xy;
    float2 center_ = float2((width * 0.5), (height * 0.5));
    float2 delta = ((pixel - center_) / (min_dim).xx);
    float radius = flashlightParams.w;
    if ((radius <= 0.0)) {
        FlashlightResult _e56 = result;
        const FlashlightResult flashlightresult_2 = _e56;
        return flashlightresult_2;
    }
    float dist_1 = length(delta);
    if ((dist_1 > radius)) {
        FlashlightResult _e59 = result;
        const FlashlightResult flashlightresult_3 = _e59;
        return flashlightresult_3;
    }
    float falloff = clamp((dist_1 / radius), 0.0, 1.0);
    float _e70 = flashlightParams.y;
    float base_intensity = (((1.0 - (falloff * falloff)) * _e70) * 0.35);
    result.screenIntensity = base_intensity;
    float _e78 = flashlightDir.w;
    if ((_e78 <= 0.0)) {
        FlashlightResult _e81 = result;
        const FlashlightResult flashlightresult_4 = _e81;
        return flashlightresult_4;
    }
    float4 _e84 = flashlightPos;
    float3 to_fragment = (world_pos_1 - _e84.xyz);
    float4 _e89 = flashlightDir;
    float dist_along_axis = dot(to_fragment, _e89.xyz);
    float _e97 = flashlightPos.w;
    if (((dist_along_axis <= 0.0) || (dist_along_axis > _e97))) {
        FlashlightResult _e100 = result;
        const FlashlightResult flashlightresult_5 = _e100;
        return flashlightresult_5;
    }
    float3 dir_norm = normalize(to_fragment);
    float4 _e104 = flashlightDir;
    float spot = dot(dir_norm, _e104.xyz);
    float cutoff = flashlightDir.w;
    if ((spot <= cutoff)) {
        FlashlightResult _e112 = result;
        const FlashlightResult flashlightresult_6 = _e112;
        return flashlightresult_6;
    }
    float focus = pow(((spot - cutoff) / max((1.0 - cutoff), 0.001)), 2.0);
    float4 _e123 = flashlightDir;
    float ndotl_1 = max(dot(normal_1, _e123.xyz), 0.0);
    float _e131 = flashlightPos.w;
    float distance_atten = clamp((1.0 - (dist_along_axis / _e131)), 0.0, 1.0);
    float _e143 = flashlightParams.y;
    beam = (base_intensity + ((((focus * ndotl_1) * distance_atten) * _e143) * 0.5));
    float _e149 = beam;
    float _e153 = flashlightParams.y;
    beam = min(_e149, (_e153 * 0.7));
    float _e158 = beam;
    result.screenIntensity = _e158;
    float3 light_color_2 = float3(1.0, 0.95, 0.85);
    float _e166 = flashlightParams.y;
    float physical_intensity = ((distance_atten * _e166) * focus);
    const float3 _e170 = cook_torrance_brdf(normal_1, view_dir_2, dir_norm, albedo_2, metallic_3, roughness_6, f0_3, light_color_2, physical_intensity);
    result.shading = _e170;
    FlashlightResult _e171 = result;
    const FlashlightResult flashlightresult_7 = _e171;
    return flashlightresult_7;
}

uint naga_f2u32(float value) {
    return uint(clamp(value, 0.0, 4294967000.0));
}

uint compute_material_index(float surface_type)
{
    float rounded = floor((surface_type + 0.5));
    float clamped_1 = clamp(rounded, 0.0, 6.0);
    return naga_f2u32(clamped_1);
}

float2 parallax_occlusion(float2 uv_2, float3 view_ts, float3 _normal, float height_scale, int steps)
{
    float current_depth = 0.0;
    float2 current_uv = (float2)0;
    float prev_depth_map = 0.0;
    float2 prev_uv = (float2)0;
    int i_1 = int(0);

    int num_steps = max(steps, int(1));
    float layer_depth = (1.0 / float(num_steps));
    float3 view_dir_3 = normalize(view_ts);
    if ((abs(view_dir_3.z) < 0.001)) {
        return uv_2;
    }
    float2 offset_dir = ((view_dir_3.xy / (view_dir_3.z).xx) * height_scale);
    current_uv = uv_2;
    prev_uv = uv_2;
    bool loop_init_1 = true;
    while(true) {
        if (!loop_init_1) {
            int _e61 = i_1;
            i_1 = asint(asuint(_e61) + asuint(int(1)));
        }
        loop_init_1 = false;
        int _e28 = i_1;
        if ((_e28 < num_steps)) {
        } else {
            break;
        }
        {
            float2 _e31 = current_uv;
            current_uv = (_e31 - (offset_dir * layer_depth));
            float2 _e35 = current_uv;
            float4 _e36 = heightTexture.Sample(sharedSampler, _e35);
            float depth_map = _e36.x;
            float _e38 = current_depth;
            if ((_e38 >= depth_map)) {
                float _e40 = prev_depth_map;
                float _e41 = current_depth;
                float _e44 = current_depth;
                float2 delta_1 = float2(((_e40 - _e41) + layer_depth), (depth_map - _e44));
                float denom_1 = max((delta_1.x - delta_1.y), 0.0001);
                float weight = (delta_1.x / denom_1);
                float2 _e54 = prev_uv;
                return (_e54 - (offset_dir * (weight * layer_depth)));
            }
            float2 _e58 = current_uv;
            prev_uv = _e58;
            prev_depth_map = depth_map;
            float _e59 = current_depth;
            current_depth = (_e59 + layer_depth);
        }
    }
    return uv_2;
}

float3x3 build_tbn(float3 normal_2)
{
    float3 up = float3(0.0, 1.0, 0.0);

    if ((abs(normal_2.y) > 0.9)) {
        up = float3(0.0, 0.0, 1.0);
    }
    float3 _e14 = up;
    float3 tangent = normalize(cross(_e14, normal_2));
    float3 bitangent = cross(normal_2, tangent);
    return float3x3(tangent, bitangent, normal_2);
}

float4 main_(FragmentInput_main fragmentinput_main) : SV_Target0
{
    FragmentInput input = { fragmentinput_main.surfaceType, fragmentinput_main.uv_3, fragmentinput_main.normal_3, fragmentinput_main.worldPos };
    float4 frag_coord = fragmentinput_main.frag_coord_2;
    float3 sampledAlbedo = (float3)0;
    float3 sampledNormal = (float3)0;
    float2 sampledMR = (float2)0;
    float3 sampledEmissive = (float3)0;
    float3 baseColor = (float3)0;
    float3 n = (float3)0;
    float3 view_dir = (float3)0;
    float metallic = (float)0;
    float roughness = (float)0;
    float3 emissive = (0.0).xxx;
    float2 uv = (float2)0;
    float3 color = (float3)0;

    float4 floorColor = floorTexture.Sample(sharedSampler, input.uv);
    float4 wallColor = wallTexture.Sample(sharedSampler, input.uv);
    float4 ceilingColor = ceilingTexture.Sample(sharedSampler, input.uv);
    float4 sphereColor = sphereTexture.Sample(sharedSampler, input.uv);
    float4 bookColor = bookTexture.Sample(sharedSampler, input.uv);
    float4 chairColor = chairTexture.Sample(sharedSampler, input.uv);
    float4 _e29 = debugAlbedoTexture.Sample(sharedSampler, input.uv);
    sampledAlbedo = _e29.xyz;
    float4 _e35 = normalTexture.Sample(sharedSampler, input.uv);
    sampledNormal = ((_e35.xyz * 2.0) - (1.0).xxx);
    float4 _e46 = metallicRoughnessTexture.Sample(sharedSampler, input.uv);
    sampledMR = _e46.xy;
    float4 _e52 = emissiveTexture.Sample(sharedSampler, input.uv);
    sampledEmissive = _e52.xyz;
    if ((input.surfaceType < 0.5)) {
        baseColor = floorColor.xyz;
    } else {
        if ((input.surfaceType < 1.5)) {
            float3 _e63 = sampledAlbedo;
            baseColor = _e63;
        } else {
            if ((input.surfaceType < 2.5)) {
                baseColor = ceilingColor.xyz;
            } else {
                if ((input.surfaceType < 3.5)) {
                    const float _e76 = checker(input.uv);
                    baseColor = (float3(0.7, 0.5, 0.3) * _e76);
                } else {
                    if ((input.surfaceType < 4.5)) {
                        baseColor = sphereColor.xyz;
                    } else {
                        if ((input.surfaceType < 5.5)) {
                            baseColor = bookColor.xyz;
                        } else {
                            baseColor = chairColor.xyz;
                        }
                    }
                }
            }
        }
    }
    n = normalize(input.normal);
    const uint _e93 = compute_material_index(input.surfaceType);
    Material material = materials[min(uint(_e93), 6u)];
    float4 _e98 = cameraPos;
    view_dir = (_e98.xyz - input.worldPos);
    float3 _e103 = view_dir;
    float view_len = length(_e103);
    if ((view_len > 0.0001)) {
        float3 _e107 = view_dir;
        view_dir = (_e107 / (view_len).xxx);
    } else {
        view_dir = float3(0.0, 0.0, 1.0);
    }
    bool use_pbr_debug = ((input.surfaceType > 0.5) && (input.surfaceType < 1.5));
    metallic = material.metalness;
    roughness = max(material.roughness, 0.04);
    if (use_pbr_debug) {
        float3 _e130 = n;
        const float3x3 _e131 = build_tbn(_e130);
        float3 _e133 = view_dir;
        float3 view_ts_1 = mul(_e133, transpose(_e131));
        uv = (input.uv * 8.0);
        float4 _e141 = cameraPos;
        if ((distance(_e141.xyz, input.worldPos) < 15.0)) {
            float2 _e147 = uv;
            float3 _e148 = n;
            const float2 _e151 = parallax_occlusion(_e147, view_ts_1, _e148, 0.35, int(72));
            uv = _e151;
        }
        float2 _e154 = uv;
        float4 _e155 = debugAlbedoTexture.Sample(sharedSampler, _e154);
        sampledAlbedo = _e155.xyz;
        float2 _e159 = uv;
        float4 _e160 = normalTexture.Sample(sharedSampler, _e159);
        sampledNormal = ((_e160.xyz * 2.0) - (1.0).xxx);
        float2 _e169 = uv;
        float4 _e170 = metallicRoughnessTexture.Sample(sharedSampler, _e169);
        sampledMR = _e170.xy;
        float2 _e174 = uv;
        float4 _e175 = emissiveTexture.Sample(sharedSampler, _e174);
        sampledEmissive = _e175.xyz;
        float3 _e177 = sampledAlbedo;
        baseColor = _e177;
        float3 _e178 = sampledNormal;
        n = normalize(mul(_e178, _e131));
        float _e182 = sampledMR.x;
        metallic = clamp((_e182 * material.metalness), 0.0, 1.0);
        float _e189 = sampledMR.y;
        roughness = clamp((_e189 * material.roughness), 0.04, 1.0);
        float3 _e195 = sampledEmissive;
        emissive = (_e195 * material.emissiveIntensity);
    } else {
        metallic = material.metalness;
        roughness = max(material.roughness, 0.04);
        emissive = (0.0).xxx;
    }
    float _e207 = screenParams.w;
    if ((_e207 > 0.5)) {
        float3 _e210 = n;
        float3 mapped = ((_e210 * 0.5) + (0.5).xxx);
        return float4(mapped, 1.0);
    }
    float dielectric_ior = max(material.ior, 1.0);
    float dielectric_f0_ = pow(((dielectric_ior - 1.0) / (dielectric_ior + 1.0)), 2.0);
    float3 base_reflectance = (dielectric_f0_).xxx;
    float3 _e229 = baseColor;
    float _e230 = metallic;
    float3 f0_4 = lerp(base_reflectance, _e229, (_e230).xxx);
    float3 _e233 = n;
    float3 _e235 = view_dir;
    float3 _e236 = baseColor;
    float _e237 = metallic;
    float _e238 = roughness;
    const float3 _e239 = compute_static_lighting(_e233, input.worldPos, _e235, _e236, _e237, _e238, f0_4);
    float3 _e240 = n;
    float3 _e242 = view_dir;
    float3 _e243 = baseColor;
    float _e244 = metallic;
    float _e245 = roughness;
    const FlashlightResult _e246 = compute_flashlight(_e240, input.worldPos, frag_coord, _e242, _e243, _e244, _e245, f0_4);
    float ambient = staticLightParams.z;
    float4 _e254 = cameraPos;
    float fogFactor = exp((-(distance(input.worldPos, _e254.xyz)) * 0.08));
    float3 _e261 = baseColor;
    color = (_e261 * (ambient + _e246.screenIntensity));
    float3 _e266 = color;
    color = (_e266 + _e239);
    float3 _e269 = color;
    color = (_e269 + _e246.shading);
    float3 _e271 = emissive;
    float3 _e272 = color;
    color = (_e272 + _e271);
    float3 _e274 = color;
    float3 _e275 = color;
    color = (_e274 / (_e275 + (1.0).xxx));
    float3 _e280 = color;
    color = pow(_e280, (0.45454547).xxx);
    float4 _e286 = fogColor;
    float3 _e288 = color;
    color = lerp(_e286.xyz, _e288, fogFactor);
    float3 _e290 = color;
    return float4(_e290, 1.0);
}