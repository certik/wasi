<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU Simple Test</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1000;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="crosshair"></div>
    <script type="module">
        // Test with single colored triangle to verify basic setup
        async function init() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Catch WebGPU errors
            device.addEventListener('uncapturederror', (event) => {
                console.error('WebGPU uncaptured error:', event.error);
            });
            const context = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format });

            // Build geometry: floor + 4 walls
            const wallHeight = 2.0;
            const positionsArray = [];
            const uvsArray = [];
            const surfaceTypeArray = []; // 0=floor, 1=wall
            const indicesArray = [];
            let indexOffset = 0;

            // Floor quad (2x2 at y=0)
            positionsArray.push(
                -1, 0, -1,  1, 0, -1,  -1, 0, 1,  1, 0, 1
            );
            uvsArray.push(0, 0,  1, 0,  0, 1,  1, 1);
            surfaceTypeArray.push(0, 0, 0, 0); // floor
            indicesArray.push(0, 1, 2,  1, 3, 2);
            indexOffset = 4;

            // North wall (z = -1) - facing inward (+Z direction)
            // Vertices ordered: bottom-left, bottom-right, top-left, top-right (as seen from inside)
            positionsArray.push(
                -1, 0, -1,  1, 0, -1,  -1, wallHeight, -1,  1, wallHeight, -1
            );
            uvsArray.push(0, 0,  1, 0,  0, 1,  1, 1);
            surfaceTypeArray.push(1, 1, 1, 1); // wall
            indicesArray.push(indexOffset, indexOffset+1, indexOffset+2,  indexOffset+1, indexOffset+3, indexOffset+2);
            indexOffset += 4;

            // South wall (z = 1) - facing inward (-Z direction)
            positionsArray.push(
                1, 0, 1,  -1, 0, 1,  1, wallHeight, 1,  -1, wallHeight, 1
            );
            uvsArray.push(0, 0,  1, 0,  0, 1,  1, 1);
            surfaceTypeArray.push(1, 1, 1, 1); // wall
            indicesArray.push(indexOffset, indexOffset+1, indexOffset+2,  indexOffset+1, indexOffset+3, indexOffset+2);
            indexOffset += 4;

            // West wall (x = -1) - facing inward (+X direction)
            positionsArray.push(
                -1, 0, -1,  -1, 0, 1,  -1, wallHeight, -1,  -1, wallHeight, 1
            );
            uvsArray.push(0, 0,  1, 0,  0, 1,  1, 1);
            surfaceTypeArray.push(1, 1, 1, 1); // wall
            indicesArray.push(indexOffset, indexOffset+1, indexOffset+2,  indexOffset+1, indexOffset+3, indexOffset+2);
            indexOffset += 4;

            // East wall (x = 1) - facing inward (-X direction)
            positionsArray.push(
                1, 0, 1,  1, 0, -1,  1, wallHeight, 1,  1, wallHeight, -1
            );
            uvsArray.push(0, 0,  1, 0,  0, 1,  1, 1);
            surfaceTypeArray.push(1, 1, 1, 1); // wall
            indicesArray.push(indexOffset, indexOffset+1, indexOffset+2,  indexOffset+1, indexOffset+3, indexOffset+2);
            indexOffset += 4;

            // Ceiling quad (2x2 at y=wallHeight, facing downward)
            positionsArray.push(
                -1, wallHeight, -1,  1, wallHeight, -1,  -1, wallHeight, 1,  1, wallHeight, 1
            );
            uvsArray.push(0, 0,  1, 0,  0, 1,  1, 1);
            surfaceTypeArray.push(2, 2, 2, 2); // ceiling
            indicesArray.push(indexOffset, indexOffset+2, indexOffset+1,  indexOffset+1, indexOffset+2, indexOffset+3);
            indexOffset += 4;

            const positions = new Float32Array(positionsArray);
            const uvs = new Float32Array(uvsArray);
            const surfaceTypes = new Float32Array(surfaceTypeArray);
            const indices = new Uint16Array(indicesArray);

            const positionBuffer = device.createBuffer({
                size: positions.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(positionBuffer.getMappedRange()).set(positions);
            positionBuffer.unmap();

            const uvBuffer = device.createBuffer({
                size: uvs.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(uvBuffer.getMappedRange()).set(uvs);
            uvBuffer.unmap();

            const surfaceTypeBuffer = device.createBuffer({
                size: surfaceTypes.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true
            });
            new Float32Array(surfaceTypeBuffer.getMappedRange()).set(surfaceTypes);
            surfaceTypeBuffer.unmap();

            const indexBuffer = device.createBuffer({
                size: indices.byteLength,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true
            });
            new Uint16Array(indexBuffer.getMappedRange()).set(indices);
            indexBuffer.unmap();

            // Uniform buffer - use individual floats to avoid vec/matrix alignment issues
            // Layout: cameraPosX, cameraPosY, cameraPosZ, yaw, pitch, fov, viewWidth, viewHeight
            const uniformBuffer = device.createBuffer({
                size: 32, // 8 floats * 4 bytes
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            console.log('Uniform buffer created with individual floats (no vectors/matrices)');

            const vsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                };

                @vertex fn vs_main(
                    @location(0) position: vec3<f32>,
                    @location(1) uv: vec2<f32>,
                    @location(2) surfaceType: f32
                ) -> VertexOutput {
                    var output: VertexOutput;

                    // Transform to camera space
                    let cy = cos(u.yaw);
                    let sy = sin(u.yaw);
                    let cp = cos(u.pitch);
                    let sp = sin(u.pitch);

                    // Position relative to camera
                    let dx = position.x - u.cameraPosX;
                    let dy = position.y - u.cameraPosY;
                    let dz = position.z - u.cameraPosZ;

                    // Transform to view space
                    // Forward direction is (cos(yaw), 0, sin(yaw)) in world space
                    // Right direction is (-sin(yaw), 0, cos(yaw)) in world space
                    let viewX = -dx * sy + dz * cy;
                    let viewZ_noPitch = dx * cy + dz * sy;

                    // Rotate by pitch (around X axis in view space)
                    let viewY = dy * cp - viewZ_noPitch * sp;
                    let viewZ = dy * sp + viewZ_noPitch * cp;

                    // Calculate distance from camera for fog
                    let viewDist = sqrt(viewX * viewX + viewY * viewY + viewZ * viewZ);

                    // Perspective projection
                    let aspect = u.viewWidth / u.viewHeight;
                    let f = tan(u.fov * 0.5);
                    let near = 0.01;
                    let far = 100.0;

                    // Output clip-space coordinates (before perspective divide)
                    // Let GPU handle perspective divide by setting w = viewZ
                    let clipX = viewX / (f * aspect);
                    let clipY = viewY / f;
                    let clipZ = ((far + near) * viewZ - 2.0 * far * near) / (far - near);
                    let clipW = viewZ;

                    output.clipPos = vec4<f32>(clipX, clipY, clipZ, clipW);
                    output.worldPos = position;
                    output.surfaceType = surfaceType;
                    output.viewDist = viewDist;
                    return output;
                }
            `;

            const fsSource = `
                struct Uniforms {
                    cameraPosX: f32,
                    cameraPosY: f32,
                    cameraPosZ: f32,
                    yaw: f32,
                    pitch: f32,
                    fov: f32,
                    viewWidth: f32,
                    viewHeight: f32,
                };
                @group(0) @binding(0) var<uniform> u: Uniforms;

                struct VertexOutput {
                    @builtin(position) clipPos: vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) surfaceType: f32,
                    @location(2) viewDist: f32,
                };

                @fragment fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
                    // Calculate perspective-correct UVs from world position
                    var texU: f32;
                    var texV: f32;

                    if (in.surfaceType > 1.5) {
                        // Ceiling (surfaceType = 2)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    } else if (in.surfaceType > 0.5) {
                        // Wall (surfaceType = 1)
                        // Determine which wall by checking which coordinate is closer to boundary
                        let absX = abs(in.worldPos.x);
                        let absZ = abs(in.worldPos.z);
                        if (absX > absZ) {
                            // East or West wall (x-aligned)
                            texU = fract(in.worldPos.z);
                        } else {
                            // North or South wall (z-aligned)
                            texU = fract(in.worldPos.x);
                        }
                        texV = in.worldPos.y / 2.0; // wallHeight = 2.0
                    } else {
                        // Floor (surfaceType = 0)
                        texU = fract(in.worldPos.x);
                        texV = fract(in.worldPos.z);
                    }

                    // Checkerboard pattern
                    let checkerU = floor(texU * 4.0);
                    let checkerV = floor(texV * 4.0);
                    let checker = (i32(checkerU) + i32(checkerV)) & 1;
                    let checkerFactor = select(0.7, 1.0, checker == 0);

                    // Different colors based on surface type
                    var baseColor: vec4<f32>;
                    if (in.surfaceType > 1.5) {
                        // Ceiling
                        baseColor = vec4<f32>(0.0, 1.0, 0.0, 1.0); // Green ceiling
                    } else if (in.surfaceType > 0.5) {
                        // Wall
                        baseColor = vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red walls
                    } else {
                        // Floor
                        baseColor = vec4<f32>(0.0, 0.0, 1.0, 1.0); // Blue floor
                    }

                    let surfaceColor = baseColor * checkerFactor;

                    // Apply fog
                    let fogColor = vec4<f32>(0.5, 0.7, 1.0, 1.0); // Light blue fog (matches clear color)
                    let fogStart = 0.5;
                    let fogEnd = 3.0;
                    let fogFactor = clamp((fogEnd - in.viewDist) / (fogEnd - fogStart), 0.0, 1.0);

                    return mix(fogColor, surfaceColor, fogFactor);
                }
            `;

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [{
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' }
                }]
            });

            const pipelineLayout = device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            });

            const vsModule = device.createShaderModule({ code: vsSource });
            const fsModule = device.createShaderModule({ code: fsSource });

            // Check for compilation errors
            vsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.log('Vertex shader compilation info:', info.messages);
                }
            });
            fsModule.getCompilationInfo().then(info => {
                if (info.messages.length > 0) {
                    console.log('Fragment shader compilation info:', info.messages);
                }
            });

            const pipeline = device.createRenderPipeline({
                layout: pipelineLayout,
                vertex: {
                    module: vsModule,
                    entryPoint: 'vs_main',
                    buffers: [
                        {
                            arrayStride: 12,
                            attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }]
                        },
                        {
                            arrayStride: 8,
                            attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }]
                        },
                        {
                            arrayStride: 4,
                            attributes: [{ shaderLocation: 2, offset: 0, format: 'float32' }]
                        }
                    ]
                },
                fragment: {
                    module: fsModule,
                    entryPoint: 'fs_main',
                    targets: [{ format }]
                },
                primitive: { topology: 'triangle-list', cullMode: 'none' },
                depthStencil: {
                    format: 'depth24plus',
                    depthWriteEnabled: true,
                    depthCompare: 'less'
                }
            });

            console.log('Pipeline created with explicit layout');

            const depthTexture = device.createTexture({
                size: [canvas.width, canvas.height],
                format: 'depth24plus',
                usage: GPUTextureUsage.RENDER_ATTACHMENT
            });

            // Create bind group AFTER buffer is initialized
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
            });
            console.log('Bind group created after buffer init');

            console.log('Positions:', positions);
            console.log('Indices:', indices);
            console.log('UVs:', uvs);

            // Camera setup - inside the box
            let yaw = 0;
            let pitch = 0;
            const cameraPos = [0, 1.0, 0];
            const moveSpeed = 0.05;
            const keys = {};

            // Keyboard controls
            document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            // Mouse controls
            canvas.addEventListener('click', () => canvas.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    document.addEventListener('mousemove', onMouseMove);
                } else {
                    document.removeEventListener('mousemove', onMouseMove);
                }
            });

            function onMouseMove(e) {
                yaw += e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, pitch));
            }

            function updateCamera() {
                const cy = Math.cos(yaw);
                const sy = Math.sin(yaw);

                if (keys['w']) {
                    cameraPos[0] += cy * moveSpeed;
                    cameraPos[2] += sy * moveSpeed;
                }
                if (keys['s']) {
                    cameraPos[0] -= cy * moveSpeed;
                    cameraPos[2] -= sy * moveSpeed;
                }
                if (keys['a']) {
                    cameraPos[0] += sy * moveSpeed;
                    cameraPos[2] -= cy * moveSpeed;
                }
                if (keys['d']) {
                    cameraPos[0] -= sy * moveSpeed;
                    cameraPos[2] += cy * moveSpeed;
                }
            }

            function perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                // Column-major for WGSL
                return new Float32Array([
                    f / aspect, 0, 0, 0,           // column 0
                    0, f, 0, 0,                     // column 1
                    0, 0, (far + near) * nf, (2 * far * near) * nf,  // column 2
                    0, 0, -1, 0                     // column 3
                ]);
            }

            function lookAt(eye, target, up) {
                const zAxis = normalize([eye[0] - target[0], eye[1] - target[1], eye[2] - target[2]]);
                const xAxis = normalize(cross(up, zAxis));
                const yAxis = cross(zAxis, xAxis);
                // Column-major for WGSL
                return new Float32Array([
                    xAxis[0], xAxis[1], xAxis[2], 0,  // column 0
                    yAxis[0], yAxis[1], yAxis[2], 0,  // column 1
                    zAxis[0], zAxis[1], zAxis[2], 0,  // column 2
                    -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1  // column 3
                ]);
            }

            function normalize(v) {
                const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
                return [v[0]/len, v[1]/len, v[2]/len];
            }

            function cross(a, b) {
                return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]];
            }

            function dot(a, b) {
                return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
            }

            function multiply(a, b) {
                // Column-major matrix multiplication for WGSL
                const result = new Float32Array(16);
                for (let col = 0; col < 4; col++) {
                    for (let row = 0; row < 4; row++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) {
                            sum += a[k * 4 + row] * b[col * 4 + k];
                        }
                        result[col * 4 + row] = sum;
                    }
                }
                return result;
            }

            let frameCount = 0;
            function render() {
                updateCamera();

                // Update uniforms
                const data = new Float32Array(8);
                data[0] = cameraPos[0];
                data[1] = cameraPos[1];
                data[2] = cameraPos[2];
                data[3] = yaw;
                data[4] = pitch;
                data[5] = Math.PI / 3; // fov
                data[6] = canvas.width;
                data[7] = canvas.height;

                device.queue.writeBuffer(uniformBuffer, 0, data);

                if (frameCount < 1) {
                    console.log('Camera:', cameraPos, 'yaw:', yaw.toFixed(2), 'pitch:', pitch.toFixed(2));
                    console.log('Total vertices:', positions.length / 3, 'indices:', indices.length);
                }

                const encoder = device.createCommandEncoder();
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        clearValue: { r: 0.5, g: 0.7, b: 1.0, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }],
                    depthStencilAttachment: {
                        view: depthTexture.createView(),
                        depthClearValue: 1.0,
                        depthLoadOp: 'clear',
                        depthStoreOp: 'store'
                    }
                });

                pass.setPipeline(pipeline);
                pass.setBindGroup(0, bindGroup);
                if (frameCount === 0) {
                    console.log('Bind group set in render pass');
                }
                pass.setVertexBuffer(0, positionBuffer);
                pass.setVertexBuffer(1, uvBuffer);
                pass.setVertexBuffer(2, surfaceTypeBuffer);
                pass.setIndexBuffer(indexBuffer, 'uint16');
                pass.drawIndexed(indices.length); // Draw all indices
                pass.end();

                if (frameCount < 2) {
                    console.log('Frame', frameCount, 'drawing', indices.length, 'indices');
                }

                device.queue.submit([encoder.finish()]);

                frameCount++;
                requestAnimationFrame(render);
            }

            render();
        }

        init();
    </script>
</body>
</html>
